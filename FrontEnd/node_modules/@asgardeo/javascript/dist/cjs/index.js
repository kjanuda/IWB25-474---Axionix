var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  ApplicationNativeAuthenticationConstants: () => ApplicationNativeAuthenticationConstants_default,
  AsgardeoAPIError: () => AsgardeoAPIError,
  AsgardeoAuthClient: () => AsgardeoAuthClient,
  AsgardeoAuthException: () => AsgardeoAuthException,
  AsgardeoError: () => AsgardeoError,
  AsgardeoJavaScriptClient: () => AsgardeoJavaScriptClient_default,
  AsgardeoRuntimeError: () => AsgardeoRuntimeError,
  EmbeddedFlowComponentType: () => EmbeddedFlowComponentType,
  EmbeddedFlowResponseType: () => EmbeddedFlowResponseType,
  EmbeddedFlowStatus: () => EmbeddedFlowStatus,
  EmbeddedFlowType: () => EmbeddedFlowType,
  EmbeddedSignInFlowAuthenticatorKnownIdPType: () => EmbeddedSignInFlowAuthenticatorKnownIdPType,
  EmbeddedSignInFlowAuthenticatorParamType: () => EmbeddedSignInFlowAuthenticatorParamType,
  EmbeddedSignInFlowAuthenticatorPromptType: () => EmbeddedSignInFlowAuthenticatorPromptType,
  EmbeddedSignInFlowStatus: () => EmbeddedSignInFlowStatus,
  EmbeddedSignInFlowStepType: () => EmbeddedSignInFlowStepType,
  EmbeddedSignInFlowType: () => EmbeddedSignInFlowType,
  FieldType: () => FieldType,
  FlowMode: () => FlowMode,
  IsomorphicCrypto: () => IsomorphicCrypto,
  OIDCRequestConstants: () => OIDCRequestConstants_default,
  StorageManager: () => StorageManager_default,
  TokenConstants: () => TokenConstants_default,
  VendorConstants: () => VendorConstants_default,
  WellKnownSchemaIds: () => WellKnownSchemaIds,
  createOrganization: () => createOrganization_default,
  createPatchOperations: () => createPatchOperations,
  createTheme: () => createTheme_default,
  deepMerge: () => deepMerge_default,
  deriveOrganizationHandleFromBaseUrl: () => deriveOrganizationHandleFromBaseUrl_default,
  executeEmbeddedSignInFlow: () => executeEmbeddedSignInFlow_default,
  executeEmbeddedSignUpFlow: () => executeEmbeddedSignUpFlow_default,
  extractPkceStorageKeyFromState: () => extractPkceStorageKeyFromState_default,
  extractUserClaimsFromIdToken: () => extractUserClaimsFromIdToken_default,
  flattenUserSchema: () => flattenUserSchema_default,
  generateFlattenedUserProfile: () => generateFlattenedUserProfile_default,
  generateUserProfile: () => generateUserProfile_default,
  get: () => get_default,
  getAllOrganizations: () => getAllOrganizations_default,
  getBrandingPreference: () => getBrandingPreference_default,
  getI18nBundles: () => getI18nBundles_default,
  getLatestStateParam: () => getLatestStateParam_default,
  getMeOrganizations: () => getMeOrganizations_default,
  getOrganization: () => getOrganization_default,
  getSchemas: () => getSchemas_default,
  getScim2Me: () => getScim2Me_default,
  getUserInfo: () => getUserInfo_default,
  initializeEmbeddedSignInFlow: () => initializeEmbeddedSignInFlow_default,
  isEmpty: () => isEmpty_default,
  processOpenIDScopes: () => processOpenIDScopes_default,
  processUsername: () => processUsername_default,
  removeTrailingSlash: () => removeTrailingSlash_default,
  resolveFieldName: () => resolveFieldName_default,
  resolveFieldType: () => resolveFieldType_default,
  set: () => set_default,
  transformBrandingPreferenceToTheme: () => transformBrandingPreferenceToTheme_default,
  updateMeProfile: () => updateMeProfile_default,
  updateOrganization: () => updateOrganization_default,
  withVendorCSSClassPrefix: () => withVendorCSSClassPrefix_default
});
module.exports = __toCommonJS(index_exports);

// src/StorageManager.ts
var ASGARDEO_SESSION_ACTIVE = "asgardeo-session-active";
var StorageManager = class {
  constructor(instanceID, store) {
    __publicField(this, "_id");
    __publicField(this, "_store");
    this._id = instanceID;
    this._store = store;
  }
  async setDataInBulk(key, data) {
    const existingDataJSON = await this._store.getData(key) ?? null;
    const existingData = existingDataJSON && JSON.parse(existingDataJSON);
    const dataToBeSaved = { ...existingData, ...data };
    const dataToBeSavedJSON = JSON.stringify(dataToBeSaved);
    await this._store.setData(key, dataToBeSavedJSON);
  }
  async setValue(key, attribute, value) {
    const existingDataJSON = await this._store.getData(key) ?? null;
    const existingData = existingDataJSON && JSON.parse(existingDataJSON);
    const dataToBeSaved = { ...existingData, [attribute]: value };
    const dataToBeSavedJSON = JSON.stringify(dataToBeSaved);
    await this._store.setData(key, dataToBeSavedJSON);
  }
  async removeValue(key, attribute) {
    const existingDataJSON = await this._store.getData(key) ?? null;
    const existingData = existingDataJSON && JSON.parse(existingDataJSON);
    const dataToBeSaved = { ...existingData };
    delete dataToBeSaved[attribute];
    const dataToBeSavedJSON = JSON.stringify(dataToBeSaved);
    await this._store.setData(key, dataToBeSavedJSON);
  }
  _resolveKey(store, userId) {
    return userId ? `${store}-${this._id}-${userId}` : `${store}-${this._id}`;
  }
  isLocalStorageAvailable() {
    try {
      const testValue = "__ASGARDEO_AUTH_CORE_LOCAL_STORAGE_TEST__";
      localStorage.setItem(testValue, testValue);
      localStorage.removeItem(testValue);
      return true;
    } catch (error) {
      return false;
    }
  }
  async setConfigData(config) {
    await this.setDataInBulk(this._resolveKey("config_data" /* ConfigData */), config);
  }
  async setOIDCProviderMetaData(oidcProviderMetaData) {
    this.setDataInBulk(this._resolveKey("oidc_provider_meta_data" /* OIDCProviderMetaData */), oidcProviderMetaData);
  }
  async setTemporaryData(temporaryData, userId) {
    this.setDataInBulk(this._resolveKey("temporary_data" /* TemporaryData */, userId), temporaryData);
  }
  async setSessionData(sessionData, userId) {
    this.setDataInBulk(this._resolveKey("session_data" /* SessionData */, userId), sessionData);
  }
  async setCustomData(key, customData, userId) {
    this.setDataInBulk(this._resolveKey(key, userId), customData);
  }
  async getConfigData(userId) {
    return JSON.parse(await this._store.getData(this._resolveKey("config_data" /* ConfigData */, userId)) ?? null);
  }
  async loadOpenIDProviderConfiguration() {
    return JSON.parse(await this._store.getData(this._resolveKey("oidc_provider_meta_data" /* OIDCProviderMetaData */)) ?? null);
  }
  async getTemporaryData(userId) {
    return JSON.parse(await this._store.getData(this._resolveKey("temporary_data" /* TemporaryData */, userId)) ?? null);
  }
  async getSessionData(userId) {
    return JSON.parse(await this._store.getData(this._resolveKey("session_data" /* SessionData */, userId)) ?? null);
  }
  async getCustomData(key, userId) {
    return JSON.parse(await this._store.getData(this._resolveKey(key, userId)) ?? null);
  }
  setSessionStatus(status) {
    this.isLocalStorageAvailable() && localStorage.setItem(`${ASGARDEO_SESSION_ACTIVE}`, status);
  }
  getSessionStatus() {
    return this.isLocalStorageAvailable() ? localStorage.getItem(`${ASGARDEO_SESSION_ACTIVE}`) ?? "" : "";
  }
  removeSessionStatus() {
    this.isLocalStorageAvailable() && localStorage.removeItem(`${ASGARDEO_SESSION_ACTIVE}`);
  }
  async removeConfigData() {
    await this._store.removeData(this._resolveKey("config_data" /* ConfigData */));
  }
  async removeOIDCProviderMetaData() {
    await this._store.removeData(this._resolveKey("oidc_provider_meta_data" /* OIDCProviderMetaData */));
  }
  async removeTemporaryData(userId) {
    await this._store.removeData(this._resolveKey("temporary_data" /* TemporaryData */, userId));
  }
  async removeSessionData(userId) {
    await this._store.removeData(this._resolveKey("session_data" /* SessionData */, userId));
  }
  async getConfigDataParameter(key) {
    const data = await this._store.getData(this._resolveKey("config_data" /* ConfigData */));
    return data && JSON.parse(data)[key];
  }
  async getOIDCProviderMetaDataParameter(key) {
    const data = await this._store.getData(this._resolveKey("oidc_provider_meta_data" /* OIDCProviderMetaData */));
    return data && JSON.parse(data)[key];
  }
  async getTemporaryDataParameter(key, userId) {
    const data = await this._store.getData(this._resolveKey("temporary_data" /* TemporaryData */, userId));
    return data && JSON.parse(data)[key];
  }
  async getSessionDataParameter(key, userId) {
    const data = await this._store.getData(this._resolveKey("session_data" /* SessionData */, userId));
    return data && JSON.parse(data)[key];
  }
  async setConfigDataParameter(key, value) {
    await this.setValue(this._resolveKey("config_data" /* ConfigData */), key, value);
  }
  async setOIDCProviderMetaDataParameter(key, value) {
    await this.setValue(this._resolveKey("oidc_provider_meta_data" /* OIDCProviderMetaData */), key, value);
  }
  async setTemporaryDataParameter(key, value, userId) {
    await this.setValue(this._resolveKey("temporary_data" /* TemporaryData */, userId), key, value);
  }
  async setSessionDataParameter(key, value, userId) {
    await this.setValue(this._resolveKey("session_data" /* SessionData */, userId), key, value);
  }
  async removeConfigDataParameter(key) {
    await this.removeValue(this._resolveKey("config_data" /* ConfigData */), key);
  }
  async removeOIDCProviderMetaDataParameter(key) {
    await this.removeValue(this._resolveKey("oidc_provider_meta_data" /* OIDCProviderMetaData */), key);
  }
  async removeTemporaryDataParameter(key, userId) {
    await this.removeValue(this._resolveKey("temporary_data" /* TemporaryData */, userId), key);
  }
  async removeSessionDataParameter(key, userId) {
    await this.removeValue(this._resolveKey("session_data" /* SessionData */, userId), key);
  }
};
var StorageManager_default = StorageManager;

// src/constants/OIDCDiscoveryConstants.ts
var OIDCDiscoveryConstants = {
  /**
   * Collection of standard OIDC endpoint paths used for authentication flows.
   * These endpoints are relative paths that should be appended to the base URL
   * of your identity provider.
   */
  Endpoints: {
    /**
     * Authorization endpoint for initiating the OAuth2/OIDC flow.
     * This endpoint is used to request authorization and receive an authorization code.
     */
    AUTHORIZATION: "/oauth2/authorize",
    /**
     * Session check iframe endpoint for session management.
     * Used to monitor the user's session state through a hidden iframe.
     */
    SESSION_IFRAME: "/oidc/checksession",
    /**
     * End session endpoint for logout functionality.
     * Used to terminate the user's session and perform logout operations.
     */
    END_SESSION: "/oidc/logout",
    /**
     * Token issuer endpoint.
     * The endpoint that issues OAuth2/OIDC tokens.
     */
    ISSUER: "/oauth2/token",
    /**
     * JSON Web Key Set endpoint for key validation.
     * Provides the public keys used to verify token signatures.
     */
    JWKS: "/oauth2/jwks",
    /**
     * Token revocation endpoint.
     * Used to invalidate access or refresh tokens before they expire.
     */
    REVOCATION: "/oauth2/revoke",
    /**
     * Token endpoint for obtaining access tokens.
     * Used to exchange authorization codes for access tokens and refresh tokens.
     */
    TOKEN: "/oauth2/token",
    /**
     * UserInfo endpoint for obtaining user claims.
     * Provides authenticated user information when called with a valid access token.
     */
    USERINFO: "/oauth2/userinfo"
  },
  /**
   * Storage related constants used for maintaining OIDC state.
   * These constants define the keys used to store OIDC-related data
   * in the browser's storage mechanisms.
   */
  Storage: {
    /**
     * Storage keys for various OIDC endpoints and configurations.
     * These keys are used to store endpoint URLs and configuration
     * states in the browser's storage.
     */
    StorageKeys: {
      /**
       * Collection of storage keys for OIDC endpoints.
       * These keys are used to store the discovered endpoint URLs
       * from the OpenID Provider's configuration.
       */
      Endpoints: {
        /**
         * Storage key for the authorization endpoint URL.
         * Used to store the URL where authorization requests should be sent.
         */
        AUTHORIZATION: "authorization_endpoint",
        /**
         * Storage key for the token endpoint URL.
         * Used to store the URL where token requests should be sent.
         */
        TOKEN: "token_endpoint",
        /**
         * Storage key for the revocation endpoint URL.
         * Used to store the URL where token revocation requests should be sent.
         */
        REVOCATION: "revocation_endpoint",
        /**
         * Storage key for the end session endpoint URL.
         * Used to store the URL where logout requests should be sent.
         */
        END_SESSION: "end_session_endpoint",
        /**
         * Storage key for the JWKS URI endpoint URL.
         * Used to store the URL where JSON Web Key Sets can be retrieved.
         */
        JWKS: "jwks_uri",
        /**
         * Storage key for the session check iframe URL.
         * Used to store the URL of the iframe used for session state monitoring.
         */
        SESSION_IFRAME: "check_session_iframe",
        /**
         * Storage key for the issuer identifier URL.
         * Used to store the URL that identifies the OpenID Provider.
         */
        ISSUER: "issuer",
        /**
         * Storage key for the userinfo endpoint URL.
         * Used to store the URL where user information can be retrieved.
         */
        USERINFO: "userinfo_endpoint"
      },
      /**
       * Flag to track if OpenID Provider configuration is initiated.
       * Used to determine if the OIDC discovery process has been started.
       * This helps prevent duplicate initialization attempts.
       */
      OPENID_PROVIDER_CONFIG_INITIATED: "op_config_initiated"
    }
  }
};
var OIDCDiscoveryConstants_default = OIDCDiscoveryConstants;

// src/constants/ScopeConstants.ts
var ScopeConstants = {
  /**
   * The scope for accessing the user's profile information from SCIM.
   * This scope allows the client to retrieve basic user information such as
   * name, email, profile picture, etc.
   */
  INTERNAL_LOGIN: "internal_login",
  /**
   * The base OpenID Connect scope.
   * Required for all OpenID Connect flows. Indicates that the client
   * is initiating an OpenID Connect authentication request.
   */
  OPENID: "openid",
  /**
   * The OpenID Connect profile scope.
   * This scope allows the client to access the user's profile information.
   * It includes details such as the user's name, email, and other profile attributes.
   */
  PROFILE: "profile"
};
var ScopeConstants_default = ScopeConstants;

// src/constants/OIDCRequestConstants.ts
var OIDCRequestConstants = {
  Params: {
    /**
     * The authorization code returned from the authorization endpoint.
     * Used in the authorization code flow.
     */
    AUTHORIZATION_CODE: "code",
    /**
     * Session state parameter used for session management between the client and the OP.
     */
    SESSION_STATE: "session_state",
    /**
     * State parameter used to maintain state between the request and the callback.
     * Helps in preventing CSRF attacks.
     */
    STATE: "state",
    /**
     * Indicates whether sign-out was successful during the end-session flow.
     * May be returned by the OP after a logout request.
     */
    SIGN_OUT_SUCCESS: "sign_out_success"
  },
  /**
   * Constants related to the OpenID Connect (OIDC) sign-in flow.
   */
  SignIn: {
    /**
     * Constants related to the payload of the OIDC sign-in request.
     */
    Payload: {
      /**
       * The default scopes used in OIDC sign-in requests.
       */
      DEFAULT_SCOPES: [ScopeConstants_default.OPENID, ScopeConstants_default.PROFILE, ScopeConstants_default.INTERNAL_LOGIN]
    }
  },
  /**
   * Sign-out related constants for managing the end-session flow in OIDC.
   */
  SignOut: {
    /**
     * Storage-related constants for managing sign-out state.
     */
    Storage: {
      /**
       * Collection of storage keys used in sign-out implementation
       */
      StorageKeys: {
        /**
         * Storage key for the sign-out URL.
         * Used to store the complete URL where the user should be redirected after
         * completing the OIDC logout process.
         */
        SIGN_OUT_URL: "sign_out_url"
      }
    }
  }
};
var OIDCRequestConstants_default = OIDCRequestConstants;

// src/errors/exception.ts
var AsgardeoAuthException = class {
  constructor(code, name, message) {
    __publicField(this, "name");
    __publicField(this, "code");
    __publicField(this, "message");
    this.message = message;
    this.name = name;
    this.code = code;
    Object.setPrototypeOf(this, new.target.prototype);
  }
};

// src/constants/TokenConstants.ts
var TokenConstants = {
  /**
   * Token signature validation constants.
   * Contains configurations related to token signature verification.
   */
  SignatureValidation: {
    /**
     * Fallback array of supported signature algorithms for OIDC token validation.
     * These values are used when the supported algorithms cannot be retrieved from
     * the .well-known/openid-configuration endpoint.
     *
     * Supported algorithms:
     * - `RS256` - RSASSA-PKCS1-v1_5 using SHA-256
     * - `RS512` - RSASSA-PKCS1-v1_5 using SHA-512
     * - `RS384` - RSASSA-PKCS1-v1_5 using SHA-384
     * - `PS256` - RSASSA-PSS using SHA-256 and MGF1 with SHA-256
     */
    SUPPORTED_ALGORITHMS: ["RS256", "RS512", "RS384", "PS256"]
  },
  /**
   * Storage-related constants for OIDC tokens.
   * Contains keys used to store token-related data in browser storage.
   */
  Storage: {
    /**
     * Collection of storage keys used in token management.
     * These keys are used to store and retrieve token-related
     * information from browser storage.
     */
    StorageKeys: {
      /**
       * Key used to store the refresh token timer identifier.
       * This timer is used to schedule token refresh operations
       * before the current token expires.
       */
      REFRESH_TOKEN_TIMER: "refresh_token_timer"
    }
  }
};
var TokenConstants_default = TokenConstants;

// src/IsomorphicCrypto.ts
var IsomorphicCrypto = class {
  constructor(cryptoUtils) {
    __publicField(this, "_cryptoUtils");
    this._cryptoUtils = cryptoUtils;
  }
  /**
   * Generate code verifier.
   *
   * @returns code verifier.
   */
  getCodeVerifier() {
    return this._cryptoUtils.base64URLEncode(this._cryptoUtils.generateRandomBytes(32));
  }
  /**
   * Derive code challenge from the code verifier.
   *
   * @param verifier - Code verifier.
   *
   * @returns - code challenge.
   */
  getCodeChallenge(verifier) {
    return this._cryptoUtils.base64URLEncode(this._cryptoUtils.hashSha256(verifier));
  }
  /**
   * Get JWK used for the id_token
   *
   * @param jwtHeader - header of the id_token.
   * @param keys - jwks response.
   *
   * @returns public key.
   *
   * @throws
   */
  /* eslint-disable @typescript-eslint/no-explicit-any */
  getJWKForTheIdToken(jwtHeader, keys) {
    const headerJSON = JSON.parse(this._cryptoUtils.base64URLDecode(jwtHeader));
    for (const key of keys) {
      if (headerJSON["kid"] === key.kid) {
        return key;
      }
    }
    throw new AsgardeoAuthException(
      "JS-CRYPTO_UTIL-GJFTIT-IV01",
      "kid not found.",
      "Failed to find the 'kid' specified in the id_token. 'kid' found in the header : " + headerJSON["kid"] + ", Expected values: " + keys.map((key) => key.kid).join(", ")
    );
  }
  /**
   * Verify id token.
   *
   * @param idToken - id_token received from the IdP.
   * @param jwk - public key used for signing.
   * @param clientId - app identification.
   * @param issuer - id_token issuer.
   * @param username - Username.
   * @param clockTolerance - Allowed leeway for id_tokens (in seconds).
   *
   * @returns whether the id_token is valid.
   *
   * @throws
   */
  isValidIdToken(idToken, jwk, clientId, issuer, username, clockTolerance, validateJwtIssuer) {
    return this._cryptoUtils.verifyJwt(
      idToken,
      jwk,
      TokenConstants_default.SignatureValidation.SUPPORTED_ALGORITHMS,
      clientId,
      issuer,
      username,
      clockTolerance,
      validateJwtIssuer
    ).then((response) => {
      if (response) {
        return Promise.resolve(true);
      }
      return Promise.reject(
        new AsgardeoAuthException(
          "JS-CRYPTO_HELPER-IVIT-IV01",
          "Invalid ID token.",
          "ID token validation returned false"
        )
      );
    });
  }
  /**
   * This function decodes the payload of an id token and returns it.
   *
   * @param idToken - The id token to be decoded.
   *
   * @returns - The decoded payload of the id token.
   *
   * @throws
   */
  decodeIdToken(idToken) {
    try {
      const utf8String = this._cryptoUtils.base64URLDecode(idToken?.split(".")[1]);
      const payload = JSON.parse(utf8String);
      return payload;
    } catch (error) {
      throw new AsgardeoAuthException("JS-CRYPTO_UTIL-DIT-IV01", "Decoding ID token failed.", error);
    }
  }
};

// src/constants/PKCEConstants.ts
var PKCEConstants = {
  DEFAULT_CODE_CHALLENGE_METHOD: "S256",
  /**
   * Storage-related constants for managing PKCE state
   */
  Storage: {
    /**
     * Collection of storage keys used in PKCE implementation
     */
    StorageKeys: {
      /**
       * Key used to store the PKCE code verifier in temporary storage.
       * The code verifier is a cryptographically random string that is
       * used to generate the code challenge.
       */
      CODE_VERIFIER: "pkce_code_verifier",
      /**
       * Separator used in storage keys to create unique identifiers
       * by combining different parts of the key.
       */
      SEPARATOR: "#"
    }
  }
};
var PKCEConstants_default = PKCEConstants;

// src/utils/extractPkceStorageKeyFromState.ts
var extractPkceStorageKeyFromState = (state) => {
  const index = parseInt(state.split("request_")[1]);
  return `${PKCEConstants_default.Storage.StorageKeys.CODE_VERIFIER}${PKCEConstants_default.Storage.StorageKeys.SEPARATOR}${index}`;
};
var extractPkceStorageKeyFromState_default = extractPkceStorageKeyFromState;

// src/constants/TokenExchangeConstants.ts
var TokenExchangeConstants = {
  /**
   * Collection of placeholder strings used in token exchange operations.
   * These placeholders are replaced with actual values when processing
   * token exchange requests.
   */
  Placeholders: {
    /**
     * Placeholder for the token value in exchange requests.
     * Usually replaced with an access token or refresh token.
     */
    ACCESS_TOKEN: "{{accessToken}}",
    /**
     * Placeholder for the username in token exchange operations.
     * Used when user identity needs to be included in the exchange.
     */
    USERNAME: "{{username}}",
    /**
     * Placeholder for OAuth scopes in token exchange requests.
     * Replaced with space-separated scope strings.
     */
    SCOPES: "{{scopes}}",
    /**
     * Placeholder for client ID in token exchange operations.
     * Required for client authentication.
     */
    CLIENT_ID: "{{clientId}}",
    /**
     * Placeholder for client secret in token exchange operations.
     * Used for client authentication in confidential client flows.
     */
    CLIENT_SECRET: "{{clientSecret}}"
  }
};
var TokenExchangeConstants_default = TokenExchangeConstants;

// src/utils/extractUserClaimsFromIdToken.ts
var extractUserClaimsFromIdToken = (payload) => {
  const filteredPayload = { ...payload };
  const protocolClaims = [
    "iss",
    "aud",
    "exp",
    "iat",
    "acr",
    "amr",
    "azp",
    "auth_time",
    "nonce",
    "c_hash",
    "at_hash",
    "nbf",
    "isk",
    "sid",
    "jti",
    "sub"
  ];
  protocolClaims.forEach((claim) => {
    delete filteredPayload[claim];
  });
  const userClaims = {};
  Object.entries(filteredPayload).forEach(([key, value]) => {
    const camelCasedKey = key.split("_").map((part, i) => i === 0 ? part : part[0].toUpperCase() + part.slice(1)).join("");
    userClaims[camelCasedKey] = value;
  });
  return userClaims;
};
var extractUserClaimsFromIdToken_default = extractUserClaimsFromIdToken;

// src/errors/AsgardeoError.ts
var AsgardeoError = class _AsgardeoError extends Error {
  constructor(message, code, origin) {
    const _origin = _AsgardeoError.resolveOrigin(origin);
    const prefix = `\u{1F6E1}\uFE0F Asgardeo - ${_origin}:`;
    const regex = new RegExp(`\u{1F6E1}\uFE0F\\s*Asgardeo\\s*-\\s*${_origin}:`, "i");
    const sanitized = message.replace(regex, "");
    const _message = `${prefix} ${sanitized.trim()}

(code="${code}")
`;
    super(_message);
    __publicField(this, "code");
    __publicField(this, "origin");
    this.name = new.target.name;
    this.code = code;
    this.origin = _origin;
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, new.target);
    }
  }
  static resolveOrigin(origin) {
    if (!origin) {
      return "@asgardeo/javascript";
    }
    return `@asgardeo/${origin}`;
  }
  toString() {
    return `[${this.name}]
Message: ${this.message}`;
  }
};

// src/errors/AsgardeoRuntimeError.ts
var AsgardeoRuntimeError = class extends AsgardeoError {
  /**
   * Creates an instance of AsgardeoRuntimeError.
   *
   * @param message - Human-readable description of the error
   * @param code - A unique error code that identifies the error type
   * @param details - Additional details about the error that might be helpful for debugging
   * @param origin - Optional. The SDK origin (e.g. 'react', 'vue'). Defaults to generic 'Asgardeo'
   * @constructor
   */
  constructor(message, code, origin, details) {
    super(message, code, origin);
    this.details = details;
    Object.defineProperty(this, "name", {
      value: "AsgardeoRuntimeError",
      configurable: true,
      writable: true
    });
  }
  /**
   * Returns a string representation of the runtime error
   * @returns Formatted error string with name, code, details, and message
   */
  toString() {
    const details = this.details ? `
Details: ${JSON.stringify(this.details, null, 2)}` : "";
    return `[${this.name}] (code="${this.code}")${details}
Message: ${this.message}`;
  }
};

// src/utils/processOpenIDScopes.ts
var processOpenIDScopes = (scopes) => {
  let processedScopes = [];
  if (scopes) {
    if (Array.isArray(scopes)) {
      processedScopes = scopes;
    } else if (typeof scopes === "string") {
      processedScopes = scopes.split(" ");
    } else {
      throw new AsgardeoRuntimeError(
        "Scopes must be a string or an array of strings.",
        "processOpenIDScopes-Invalid-001",
        "javascript",
        "The provided scopes are not in the expected format. Please provide a string or an array of strings."
      );
    }
  }
  OIDCRequestConstants_default.SignIn.Payload.DEFAULT_SCOPES.forEach((defaultScope) => {
    if (!processedScopes.includes(defaultScope)) {
      processedScopes.push(defaultScope);
    }
  });
  return processedScopes.join(" ");
};
var processOpenIDScopes_default = processOpenIDScopes;

// src/__legacy__/helpers/authentication-helper.ts
var AuthenticationHelper = class {
  constructor(storageManager, cryptoHelper) {
    __publicField(this, "_storageManager");
    __publicField(this, "_config");
    __publicField(this, "_oidcProviderMetaData");
    __publicField(this, "_cryptoHelper");
    this._storageManager = storageManager;
    this._config = async () => this._storageManager.getConfigData();
    this._oidcProviderMetaData = async () => this._storageManager.loadOpenIDProviderConfiguration();
    this._cryptoHelper = cryptoHelper;
  }
  async resolveEndpoints(response) {
    const oidcProviderMetaData = {};
    const configData = await this._config();
    configData.endpoints && Object.keys(configData.endpoints).forEach((endpointName) => {
      const snakeCasedName = endpointName.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
      oidcProviderMetaData[snakeCasedName] = configData?.endpoints ? configData.endpoints[endpointName] : "";
    });
    return { ...response, ...oidcProviderMetaData };
  }
  async resolveEndpointsExplicitly() {
    const oidcProviderMetaData = {};
    const configData = await this._config();
    const requiredEndpoints = [
      OIDCDiscoveryConstants_default.Storage.StorageKeys.Endpoints.AUTHORIZATION,
      OIDCDiscoveryConstants_default.Storage.StorageKeys.Endpoints.END_SESSION,
      OIDCDiscoveryConstants_default.Storage.StorageKeys.Endpoints.JWKS,
      OIDCDiscoveryConstants_default.Storage.StorageKeys.Endpoints.SESSION_IFRAME,
      OIDCDiscoveryConstants_default.Storage.StorageKeys.Endpoints.REVOCATION,
      OIDCDiscoveryConstants_default.Storage.StorageKeys.Endpoints.TOKEN,
      OIDCDiscoveryConstants_default.Storage.StorageKeys.Endpoints.ISSUER,
      OIDCDiscoveryConstants_default.Storage.StorageKeys.Endpoints.USERINFO
    ];
    const isRequiredEndpointsContains = configData.endpoints ? requiredEndpoints.every(
      (reqEndpointName) => configData.endpoints ? Object.keys(configData.endpoints).some((endpointName) => {
        const snakeCasedName = endpointName.replace(
          /[A-Z]/g,
          (letter) => `_${letter.toLowerCase()}`
        );
        return snakeCasedName === reqEndpointName;
      }) : false
    ) : false;
    if (!isRequiredEndpointsContains) {
      throw new AsgardeoAuthException(
        "JS-AUTH_HELPER-REE-NF01",
        "Required endpoints missing",
        "Some or all of the required endpoints are missing in the object passed to the `endpoints` attribute of the`AuthConfig` object."
      );
    }
    configData.endpoints && Object.keys(configData.endpoints).forEach((endpointName) => {
      const snakeCasedName = endpointName.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
      oidcProviderMetaData[snakeCasedName] = configData?.endpoints ? configData.endpoints[endpointName] : "";
    });
    return { ...oidcProviderMetaData };
  }
  async resolveEndpointsByBaseURL() {
    const oidcProviderMetaData = {};
    const configData = await this._config();
    const { baseUrl } = configData;
    if (!baseUrl) {
      throw new AsgardeoAuthException(
        "JS-AUTH_HELPER_REBO-NF01",
        "Base URL not defined.",
        "Base URL is not defined in AuthClient config."
      );
    }
    configData.endpoints && Object.keys(configData.endpoints).forEach((endpointName) => {
      const snakeCasedName = endpointName.replace(/[A-Z]/g, (letter) => `_${letter.toLowerCase()}`);
      oidcProviderMetaData[snakeCasedName] = configData?.endpoints ? configData.endpoints[endpointName] : "";
    });
    const defaultEndpoints = {
      [OIDCDiscoveryConstants_default.Storage.StorageKeys.Endpoints.AUTHORIZATION]: `${baseUrl}${OIDCDiscoveryConstants_default.Endpoints.AUTHORIZATION}`,
      [OIDCDiscoveryConstants_default.Storage.StorageKeys.Endpoints.END_SESSION]: `${baseUrl}${OIDCDiscoveryConstants_default.Endpoints.END_SESSION}`,
      [OIDCDiscoveryConstants_default.Storage.StorageKeys.Endpoints.ISSUER]: `${baseUrl}${OIDCDiscoveryConstants_default.Endpoints.ISSUER}`,
      [OIDCDiscoveryConstants_default.Storage.StorageKeys.Endpoints.JWKS]: `${baseUrl}${OIDCDiscoveryConstants_default.Endpoints.JWKS}`,
      [OIDCDiscoveryConstants_default.Storage.StorageKeys.Endpoints.SESSION_IFRAME]: `${baseUrl}${OIDCDiscoveryConstants_default.Endpoints.SESSION_IFRAME}`,
      [OIDCDiscoveryConstants_default.Storage.StorageKeys.Endpoints.REVOCATION]: `${baseUrl}${OIDCDiscoveryConstants_default.Endpoints.REVOCATION}`,
      [OIDCDiscoveryConstants_default.Storage.StorageKeys.Endpoints.TOKEN]: `${baseUrl}${OIDCDiscoveryConstants_default.Endpoints.TOKEN}`,
      [OIDCDiscoveryConstants_default.Storage.StorageKeys.Endpoints.USERINFO]: `${baseUrl}${OIDCDiscoveryConstants_default.Endpoints.USERINFO}`
    };
    return { ...defaultEndpoints, ...oidcProviderMetaData };
  }
  async validateIdToken(idToken) {
    const jwksEndpoint = (await this._storageManager.loadOpenIDProviderConfiguration()).jwks_uri;
    const configData = await this._config();
    if (!jwksEndpoint || jwksEndpoint.trim().length === 0) {
      throw new AsgardeoAuthException(
        "JS_AUTH_HELPER-VIT-NF01",
        "JWKS endpoint not found.",
        "No JWKS endpoint was found in the OIDC provider meta data returned by the well-known endpoint or the JWKS endpoint passed to the SDK is empty."
      );
    }
    let response;
    try {
      response = await fetch(jwksEndpoint, {
        credentials: configData.sendCookiesInRequests ? "include" : "same-origin"
      });
    } catch (error) {
      throw new AsgardeoAuthException(
        "JS-AUTH_HELPER-VIT-NE02",
        "Request to jwks endpoint failed.",
        error ?? "The request sent to get the jwks from the server failed."
      );
    }
    if (response.status !== 200 || !response.ok) {
      throw new AsgardeoAuthException(
        "JS-AUTH_HELPER-VIT-HE03",
        `Invalid response status received for jwks request (${response.statusText}).`,
        await response.json()
      );
    }
    const { issuer } = await this._oidcProviderMetaData();
    const { keys } = await response.json();
    const jwk = await this._cryptoHelper.getJWKForTheIdToken(idToken.split(".")[0], keys);
    return this._cryptoHelper.isValidIdToken(
      idToken,
      jwk,
      (await this._config()).clientId,
      issuer ?? "",
      this._cryptoHelper.decodeIdToken(idToken).sub,
      (await this._config()).clockTolerance,
      (await this._config()).validateIDTokenIssuer ?? true
    );
  }
  getAuthenticatedUserInfo(idToken) {
    const payload = this._cryptoHelper.decodeIdToken(idToken);
    const username = payload?.["username"] ?? "";
    const givenName = payload?.["given_name"] ?? "";
    const familyName = payload?.["family_name"] ?? "";
    const fullName = givenName && familyName ? `${givenName} ${familyName}` : givenName || familyName || "";
    const displayName = payload.preferred_username ?? fullName;
    return {
      displayName,
      username,
      ...extractUserClaimsFromIdToken_default(payload)
    };
  }
  async replaceCustomGrantTemplateTags(text, userId) {
    const configData = await this._config();
    const sessionData = await this._storageManager.getSessionData(userId);
    const scope = processOpenIDScopes_default(configData.scopes);
    if (typeof text !== "string") {
      return text;
    }
    return text.replace(TokenExchangeConstants_default.Placeholders.ACCESS_TOKEN, sessionData.access_token).replace(
      TokenExchangeConstants_default.Placeholders.USERNAME,
      this.getAuthenticatedUserInfo(sessionData.id_token).username
    ).replace(TokenExchangeConstants_default.Placeholders.SCOPES, scope).replace(TokenExchangeConstants_default.Placeholders.CLIENT_ID, configData.clientId).replace(TokenExchangeConstants_default.Placeholders.CLIENT_SECRET, configData.clientSecret ?? "");
  }
  async clearSession(userId) {
    await this._storageManager.removeTemporaryData(userId);
    await this._storageManager.removeSessionData(userId);
  }
  async handleTokenResponse(response, userId) {
    if (response.status !== 200 || !response.ok) {
      throw new AsgardeoAuthException(
        "JS-AUTH_HELPER-HTR-NE01",
        `Invalid response status received for token request (${response.statusText}).`,
        await response.json()
      );
    }
    const parsedResponse = await response.json();
    parsedResponse.created_at = (/* @__PURE__ */ new Date()).getTime();
    const shouldValidateIdToken = (await this._config()).validateIDToken;
    if (shouldValidateIdToken) {
      return this.validateIdToken(parsedResponse.id_token).then(async () => {
        await this._storageManager.setSessionData(parsedResponse, userId);
        const tokenResponse2 = {
          accessToken: parsedResponse.access_token,
          createdAt: parsedResponse.created_at,
          expiresIn: parsedResponse.expires_in,
          idToken: parsedResponse.id_token,
          refreshToken: parsedResponse.refresh_token,
          scope: parsedResponse.scope,
          tokenType: parsedResponse.token_type
        };
        return Promise.resolve(tokenResponse2);
      });
    }
    const tokenResponse = {
      accessToken: parsedResponse.access_token,
      createdAt: parsedResponse.created_at,
      expiresIn: parsedResponse.expires_in,
      idToken: parsedResponse.id_token,
      refreshToken: parsedResponse.refresh_token,
      scope: parsedResponse.scope,
      tokenType: parsedResponse.token_type
    };
    await this._storageManager.setSessionData(parsedResponse, userId);
    return Promise.resolve(tokenResponse);
  }
};

// src/utils/generatePkceStorageKey.ts
var generatePkceStorageKey = (tempStore) => {
  const keys = [];
  Object.keys(tempStore).forEach((key) => {
    if (key.startsWith(PKCEConstants_default.Storage.StorageKeys.CODE_VERIFIER)) {
      keys.push(key);
    }
  });
  const lastKey = keys.sort().pop();
  const index = parseInt(lastKey?.split(PKCEConstants_default.Storage.StorageKeys.SEPARATOR)[1] ?? "-1");
  return `${PKCEConstants_default.Storage.StorageKeys.CODE_VERIFIER}${PKCEConstants_default.Storage.StorageKeys.SEPARATOR}${index + 1}`;
};
var generatePkceStorageKey_default = generatePkceStorageKey;

// src/utils/generateStateParamForRequestCorrelation.ts
var generateStateParamForRequestCorrelation = (pkceKey, state) => {
  const index = parseInt(pkceKey.split(PKCEConstants_default.Storage.StorageKeys.SEPARATOR)[1]);
  return state ? `${state}_request_${index}` : `request_${index}`;
};
var generateStateParamForRequestCorrelation_default = generateStateParamForRequestCorrelation;

// src/utils/getAuthorizeRequestUrlParams.ts
var getAuthorizeRequestUrlParams = (options, pkceOptions, customParams) => {
  const { redirectUri, clientId, clientSecret, scopes, responseMode, codeChallenge, codeChallengeMethod, prompt } = options;
  const authorizeRequestParams = /* @__PURE__ */ new Map();
  authorizeRequestParams.set("response_type", "code");
  authorizeRequestParams.set("client_id", clientId);
  authorizeRequestParams.set("scope", scopes);
  authorizeRequestParams.set("redirect_uri", redirectUri);
  if (responseMode) {
    authorizeRequestParams.set("response_mode", responseMode);
  }
  const pkceKey = pkceOptions?.key;
  if (codeChallenge) {
    authorizeRequestParams.set("code_challenge", codeChallenge);
    if (codeChallengeMethod) {
      authorizeRequestParams.set("code_challenge_method", codeChallengeMethod);
    } else {
      throw new AsgardeoRuntimeError(
        "Code challenge method is required when code challenge is provided.",
        "getAuthorizeRequestUrlParams-ValidationError-001",
        "javascript",
        "When PKCE is enabled, the code challenge method must be provided along with the code challenge."
      );
    }
  }
  if (prompt) {
    authorizeRequestParams.set("prompt", prompt);
  }
  if (customParams) {
    for (const [key, value] of Object.entries(customParams)) {
      if (key !== "" && value !== "" && key !== OIDCRequestConstants_default.Params.STATE) {
        authorizeRequestParams.set(key, value.toString());
      }
    }
  }
  authorizeRequestParams.set(
    OIDCRequestConstants_default.Params.STATE,
    generateStateParamForRequestCorrelation_default(
      pkceKey,
      customParams ? customParams[OIDCRequestConstants_default.Params.STATE]?.toString() : ""
    )
  );
  return authorizeRequestParams;
};
var getAuthorizeRequestUrlParams_default = getAuthorizeRequestUrlParams;

// src/__legacy__/client.ts
var DefaultConfig = {
  clockTolerance: 300,
  enablePKCE: true,
  responseMode: "query",
  sendCookiesInRequests: true,
  validateIDToken: true,
  validateIDTokenIssuer: true
};
var _AsgardeoAuthClient = class _AsgardeoAuthClient {
  /**
   * This is the constructor method that returns an instance of the .
   *
   * @param store - The store object.
   *
   * @example
   * ```
   * const _store: Store = new DataStore();
   * const auth = new AsgardeoAuthClient<CustomClientConfig>(_store);
   * ```
   *
   * {@link https://github.com/asgardeo/asgardeo-auth-js-sdk/tree/master#constructor}
   *
   * @preserve
   */
  constructor() {
    __publicField(this, "_storageManager");
    __publicField(this, "_config");
    __publicField(this, "_oidcProviderMetaData");
    __publicField(this, "_authenticationHelper");
    __publicField(this, "_cryptoUtils");
    __publicField(this, "_cryptoHelper");
  }
  /**
   *
   * This method initializes the SDK with the config data.
   *
   * @param config - The config object to initialize with.
   *
   * @example
   * const config = \{
   *     afterSignInUrl: "http://localhost:3000/sign-in",
   *     clientId: "client ID",
   *     baseUrl: "https://localhost:9443"
   * \}
   *
   * await auth.initialize(config);
   *
   * {@link https://github.com/asgardeo/asgardeo-auth-js-sdk/tree/master#initialize}
   *
   * @preserve
   */
  async initialize(config, store, cryptoUtils, instanceID) {
    const clientId = config.clientId;
    if (!_AsgardeoAuthClient._instanceID) {
      _AsgardeoAuthClient._instanceID = 0;
    } else {
      _AsgardeoAuthClient._instanceID += 1;
    }
    if (instanceID) {
      _AsgardeoAuthClient._instanceID = instanceID;
    }
    if (!clientId) {
      this._storageManager = new StorageManager_default(`instance_${_AsgardeoAuthClient._instanceID}`, store);
    } else {
      this._storageManager = new StorageManager_default(`instance_${_AsgardeoAuthClient._instanceID}-${clientId}`, store);
    }
    this._cryptoUtils = cryptoUtils;
    this._cryptoHelper = new IsomorphicCrypto(cryptoUtils);
    this._authenticationHelper = new AuthenticationHelper(this._storageManager, this._cryptoHelper);
    this._config = async () => await this._storageManager.getConfigData();
    this._oidcProviderMetaData = async () => await this._storageManager.loadOpenIDProviderConfiguration();
    _AsgardeoAuthClient._authenticationHelper = this._authenticationHelper;
    await this._storageManager.setConfigData({
      ...DefaultConfig,
      ...config,
      scope: processOpenIDScopes_default(config.scopes)
    });
  }
  /**
   * This method returns the `StorageManager` object that allows you to access authentication data.
   *
   * @returns - The `StorageManager` object.
   *
   * @example
   * ```
   * const data = auth.getStorageManager();
   * ```
   *
   * {@link https://github.com/asgardeo/asgardeo-auth-js-sdk/tree/master#getStorageManager}
   *
   * @preserve
   */
  getStorageManager() {
    return this._storageManager;
  }
  /**
   * This method returns the `instanceID` variable of the given instance.
   *
   * @returns - The `instanceID` number.
   *
   * @example
   * ```
   * const instanceId = auth.getInstanceId();
   * ```
   *
   * @preserve
   */
  getInstanceId() {
    return _AsgardeoAuthClient._instanceID;
  }
  /**
   * This is an async method that returns a Promise that resolves with the authorization URL.
   *
   * @param config - (Optional) A config object to force initialization and pass
   * custom path parameters such as the fidp parameter.
   * @param userId - (Optional) A unique ID of the user to be authenticated. This is useful in multi-user
   * scenarios where each user should be uniquely identified.
   *
   * @returns - A promise that resolves with the authorization URL.
   *
   * @example
   * ```
   * auth.getSignInUrl().then((url)=>{
   *  // console.log(url);
   * }).catch((error)=>{
   *  // console.error(error);
   * });
   * ```
   *
   * {@link https://github.com/asgardeo/asgardeo-auth-js-sdk/tree/master#getSignInUrl}
   *
   * @preserve
   */
  async getSignInUrl(requestConfig, userId) {
    const authRequestConfig = { ...requestConfig };
    delete authRequestConfig?.forceInit;
    const __TODO__ = async () => {
      const authorizeEndpoint = await this._storageManager.getOIDCProviderMetaDataParameter(
        OIDCDiscoveryConstants_default.Storage.StorageKeys.Endpoints.AUTHORIZATION
      );
      if (!authorizeEndpoint || authorizeEndpoint.trim().length === 0) {
        throw new AsgardeoAuthException(
          "JS-AUTH_CORE-GAU-NF01",
          "No authorization endpoint found.",
          "No authorization endpoint was found in the OIDC provider meta data from the well-known endpoint or the authorization endpoint passed to the SDK is empty."
        );
      }
      const authorizeRequest = new URL(authorizeEndpoint);
      const configData = await this._config();
      const tempStore = await this._storageManager.getTemporaryData(userId);
      const pkceKey = await generatePkceStorageKey_default(tempStore);
      let codeVerifier;
      let codeChallenge;
      if (configData.enablePKCE) {
        codeVerifier = this._cryptoHelper?.getCodeVerifier();
        codeChallenge = this._cryptoHelper?.getCodeChallenge(codeVerifier);
        await this._storageManager.setTemporaryDataParameter(pkceKey, codeVerifier, userId);
      }
      if (authRequestConfig["client_secret"]) {
        authRequestConfig["client_secret"] = configData.clientSecret;
      }
      const authorizeRequestParams = getAuthorizeRequestUrlParams_default(
        {
          redirectUri: configData.afterSignInUrl,
          clientId: configData.clientId,
          scopes: processOpenIDScopes_default(configData.scopes),
          responseMode: configData.responseMode,
          codeChallengeMethod: PKCEConstants_default.DEFAULT_CODE_CHALLENGE_METHOD,
          codeChallenge,
          prompt: configData.prompt
        },
        { key: pkceKey },
        authRequestConfig
      );
      for (const [key, value] of authorizeRequestParams.entries()) {
        authorizeRequest.searchParams.append(key, value);
      }
      return authorizeRequest.toString();
    };
    if (await this._storageManager.getTemporaryDataParameter(
      OIDCDiscoveryConstants_default.Storage.StorageKeys.OPENID_PROVIDER_CONFIG_INITIATED
    )) {
      return __TODO__();
    }
    return this.loadOpenIDProviderConfiguration(requestConfig?.forceInit).then(() => {
      return __TODO__();
    });
  }
  /**
   * This is an async method that sends a request to obtain the access token and returns a Promise
   * that resolves with the token and other relevant data.
   *
   * @param authorizationCode - The authorization code.
   * @param sessionState - The session state.
   * @param userId - (Optional) A unique ID of the user to be authenticated. This is useful in multi-user
   * scenarios where each user should be uniquely identified.
   *
   * @returns - A Promise that resolves with the token response.
   *
   * @example
   * ```
   * auth.requestAccessToken(authCode, sessionState).then((token)=>{
   *  // console.log(token);
   * }).catch((error)=>{
   *  // console.error(error);
   * });
   * ```
   *
   * {@link https://github.com/asgardeo/asgardeo-auth-js-sdk/tree/master#requestAccessToken}
   *
   *
   * @preserve
   */
  async requestAccessToken(authorizationCode, sessionState, state, userId, tokenRequestConfig) {
    const __TODO__ = async () => {
      const tokenEndpoint = (await this._oidcProviderMetaData()).token_endpoint;
      const configData = await this._config();
      if (!tokenEndpoint || tokenEndpoint.trim().length === 0) {
        throw new AsgardeoAuthException(
          "JS-AUTH_CORE-RAT1-NF01",
          "Token endpoint not found.",
          "No token endpoint was found in the OIDC provider meta data returned by the well-known endpoint or the token endpoint passed to the SDK is empty."
        );
      }
      sessionState && await this._storageManager.setSessionDataParameter(
        OIDCRequestConstants_default.Params.SESSION_STATE,
        sessionState,
        userId
      );
      const body = new URLSearchParams();
      body.set("client_id", configData.clientId);
      if (configData.clientSecret && configData.clientSecret.trim().length > 0) {
        body.set("client_secret", configData.clientSecret);
      }
      const code = authorizationCode;
      body.set("code", code);
      body.set("grant_type", "authorization_code");
      body.set("redirect_uri", configData.afterSignInUrl);
      if (tokenRequestConfig?.params) {
        Object.entries(tokenRequestConfig.params).forEach(([key, value]) => {
          body.append(key, value);
        });
      }
      if (configData.enablePKCE) {
        body.set(
          "code_verifier",
          `${await this._storageManager.getTemporaryDataParameter(extractPkceStorageKeyFromState_default(state), userId)}`
        );
        await this._storageManager.removeTemporaryDataParameter(extractPkceStorageKeyFromState_default(state), userId);
      }
      let tokenResponse;
      try {
        tokenResponse = await fetch(tokenEndpoint, {
          body,
          credentials: configData.sendCookiesInRequests ? "include" : "same-origin",
          headers: {
            Accept: "application/json",
            "Content-Type": "application/x-www-form-urlencoded"
          },
          method: "POST"
        });
      } catch (error) {
        throw new AsgardeoAuthException(
          "JS-AUTH_CORE-RAT1-NE02",
          "Requesting access token failed",
          error ?? "The request to get the access token from the server failed."
        );
      }
      if (!tokenResponse.ok) {
        throw new AsgardeoAuthException(
          "JS-AUTH_CORE-RAT1-HE03",
          `Requesting access token failed with ${tokenResponse.statusText}`,
          await tokenResponse.json()
        );
      }
      return await this._authenticationHelper.handleTokenResponse(tokenResponse, userId);
    };
    if (await this._storageManager.getTemporaryDataParameter(
      OIDCDiscoveryConstants_default.Storage.StorageKeys.OPENID_PROVIDER_CONFIG_INITIATED
    )) {
      return __TODO__();
    }
    return this.loadOpenIDProviderConfiguration(false).then(() => {
      return __TODO__();
    });
  }
  async loadOpenIDProviderConfiguration(forceInit) {
    const configData = await this._config();
    if (!forceInit && await this._storageManager.getTemporaryDataParameter(
      OIDCDiscoveryConstants_default.Storage.StorageKeys.OPENID_PROVIDER_CONFIG_INITIATED
    )) {
      return Promise.resolve();
    }
    const wellKnownEndpoint = configData.wellKnownEndpoint;
    if (wellKnownEndpoint) {
      let response;
      try {
        response = await fetch(wellKnownEndpoint);
        if (response.status !== 200 || !response.ok) {
          throw new Error();
        }
      } catch {
        throw new AsgardeoAuthException(
          "JS-AUTH_CORE-GOPMD-HE01",
          "Invalid well-known response",
          "The well known endpoint response has been failed with an error."
        );
      }
      await this._storageManager.setOIDCProviderMetaData(
        await this._authenticationHelper.resolveEndpoints(await response.json())
      );
      await this._storageManager.setTemporaryDataParameter(
        OIDCDiscoveryConstants_default.Storage.StorageKeys.OPENID_PROVIDER_CONFIG_INITIATED,
        true
      );
      return Promise.resolve();
    } else if (configData.baseUrl) {
      try {
        await this._storageManager.setOIDCProviderMetaData(
          await this._authenticationHelper.resolveEndpointsByBaseURL()
        );
      } catch (error) {
        throw new AsgardeoAuthException(
          "JS-AUTH_CORE-GOPMD-IV02",
          "Resolving endpoints failed.",
          error ?? "Resolving endpoints by base url failed."
        );
      }
      await this._storageManager.setTemporaryDataParameter(
        OIDCDiscoveryConstants_default.Storage.StorageKeys.OPENID_PROVIDER_CONFIG_INITIATED,
        true
      );
      return Promise.resolve();
    } else {
      await this._storageManager.setOIDCProviderMetaData(await this._authenticationHelper.resolveEndpointsExplicitly());
      await this._storageManager.setTemporaryDataParameter(
        OIDCDiscoveryConstants_default.Storage.StorageKeys.OPENID_PROVIDER_CONFIG_INITIATED,
        true
      );
      return Promise.resolve();
    }
  }
  /**
   * This method returns the sign-out URL.
   *
   * @param userId - (Optional) A unique ID of the user to be authenticated. This is useful in multi-user
   * scenarios where each user should be uniquely identified.
   *
   * **This doesn't clear the authentication data.**
   *
   * @returns - A Promise that resolves with the sign-out URL.
   *
   * @example
   * ```
   * const signOutUrl = await auth.getSignOutUrl();
   * ```
   *
   * {@link https://github.com/asgardeo/asgardeo-auth-js-sdk/tree/master#getSignOutUrl}
   *
   * @preserve
   */
  async getSignOutUrl(userId) {
    const logoutEndpoint = (await this._oidcProviderMetaData())?.end_session_endpoint;
    const configData = await this._config();
    if (!logoutEndpoint || logoutEndpoint.trim().length === 0) {
      throw new AsgardeoAuthException(
        "JS-AUTH_CORE-GSOU-NF01",
        "Sign-out endpoint not found.",
        "No sign-out endpoint was found in the OIDC provider meta data returned by the well-known endpoint or the sign-out endpoint passed to the SDK is empty."
      );
    }
    const callbackURL = configData?.afterSignOutUrl ?? configData?.afterSignInUrl;
    if (!callbackURL || callbackURL.trim().length === 0) {
      throw new AsgardeoAuthException(
        "JS-AUTH_CORE-GSOU-NF03",
        "No sign-out redirect URL found.",
        "The sign-out redirect URL cannot be found or the URL passed to the SDK is empty. No sign-in redirect URL has been found either. "
      );
    }
    const queryParams = new URLSearchParams();
    queryParams.set("post_logout_redirect_uri", callbackURL);
    if (configData.sendIdTokenInLogoutRequest) {
      const idToken = (await this._storageManager.getSessionData(userId))?.id_token;
      if (!idToken || idToken.trim().length === 0) {
        throw new AsgardeoAuthException(
          "JS-AUTH_CORE-GSOU-NF02",
          "ID token not found.",
          "No ID token could be found. Either the session information is lost or you have not signed in."
        );
      }
      queryParams.set("id_token_hint", idToken);
    } else {
      queryParams.set("client_id", configData.clientId);
    }
    queryParams.set("state", OIDCRequestConstants_default.Params.SIGN_OUT_SUCCESS);
    return `${logoutEndpoint}?${queryParams.toString()}`;
  }
  /**
   * This method returns OIDC service endpoints that are fetched from the `.well-known` endpoint.
   *
   * @returns - A Promise that resolves with an object containing the OIDC service endpoints.
   *
   * @example
   * ```
   * const endpoints = await auth.getOpenIDProviderEndpoints();
   * ```
   *
   * {@link https://github.com/asgardeo/asgardeo-auth-js-sdk/tree/master#getOpenIDProviderEndpoints}
   *
   * @preserve
   */
  async getOpenIDProviderEndpoints() {
    const oidcProviderMetaData = await this._oidcProviderMetaData();
    return {
      authorizationEndpoint: oidcProviderMetaData.authorization_endpoint ?? "",
      checkSessionIframe: oidcProviderMetaData.check_session_iframe ?? "",
      endSessionEndpoint: oidcProviderMetaData.end_session_endpoint ?? "",
      introspectionEndpoint: oidcProviderMetaData.introspection_endpoint ?? "",
      issuer: oidcProviderMetaData.issuer ?? "",
      jwksUri: oidcProviderMetaData.jwks_uri ?? "",
      registrationEndpoint: oidcProviderMetaData.registration_endpoint ?? "",
      revocationEndpoint: oidcProviderMetaData.revocation_endpoint ?? "",
      tokenEndpoint: oidcProviderMetaData.token_endpoint ?? "",
      userinfoEndpoint: oidcProviderMetaData.userinfo_endpoint ?? ""
    };
  }
  /**
   * This method decodes the payload of the ID token and returns it.
   *
   * @param userId - (Optional) A unique ID of the user to be authenticated. This is useful in multi-user
   * scenarios where each user should be uniquely identified.
   *
   * @returns - A Promise that resolves with the decoded ID token payload.
   *
   * @example
   * ```
   * const decodedIdToken = await auth.getDecodedIdToken();
   * ```
   *
   * {@link https://github.com/asgardeo/asgardeo-auth-js-sdk/tree/master#getDecodedIdToken}
   *
   * @preserve
   */
  async getDecodedIdToken(userId) {
    const idToken = (await this._storageManager.getSessionData(userId)).id_token;
    const payload = this._cryptoHelper.decodeIdToken(idToken);
    return payload;
  }
  /**
   * This method returns the ID token.
   *
   * @param userId - (Optional) A unique ID of the user to be authenticated. This is useful in multi-user
   * scenarios where each user should be uniquely identified.
   *
   * @returns - A Promise that resolves with the ID token.
   *
   * @example
   * ```
   * const idToken = await auth.getIdToken();
   * ```
   *
   * {@link https://github.com/asgardeo/asgardeo-auth-js-sdk/tree/master#getIdToken}
   *
   * @preserve
   */
  async getIdToken(userId) {
    return (await this._storageManager.getSessionData(userId)).id_token;
  }
  /**
   * This method returns the basic user information obtained from the ID token.
   *
   * @param userId - (Optional) A unique ID of the user to be authenticated. This is useful in multi-user
   * scenarios where each user should be uniquely identified.
   *
   * @returns - A Promise that resolves with an object containing the basic user information.
   *
   * @example
   * ```
   * const userInfo = await auth.getUser();
   * ```
   *
   * {@link https://github.com/asgardeo/asgardeo-auth-js-sdk/tree/master#getUser}
   *
   * @preserve
   */
  async getUser(userId) {
    const sessionData = await this._storageManager.getSessionData(userId);
    const authenticatedUser = this._authenticationHelper.getAuthenticatedUserInfo(sessionData?.id_token);
    Object.keys(authenticatedUser).forEach((key) => {
      if (authenticatedUser[key] === void 0 || authenticatedUser[key] === "" || authenticatedUser[key] === null) {
        delete authenticatedUser[key];
      }
    });
    return authenticatedUser;
  }
  async getUserSession(userId) {
    const sessionData = await this._storageManager.getSessionData(userId);
    return {
      scopes: sessionData?.scope?.split(" "),
      sessionState: sessionData?.session_state ?? ""
    };
  }
  /**
   * This method returns the crypto helper object.
   *
   * @returns - A Promise that resolves with a IsomorphicCrypto object.
   *
   * @example
   * ```
   * const cryptoHelper = await auth.IsomorphicCrypto();
   * ```
   *
   * {@link https://github.com/asgardeo/asgardeo-auth-js-sdk/tree/master#getCrypto}
   *
   * @preserve
   */
  async getCrypto() {
    return this._cryptoHelper;
  }
  /**
   * This method revokes the access token.
   *
   * @param userId - (Optional) A unique ID of the user to be authenticated. This is useful in multi-user
   * scenarios where each user should be uniquely identified.
   *
   * **This method also clears the authentication data.**
   *
   * @returns - A Promise that returns the response of the revoke-access-token request.
   *
   * @example
   * ```
   * auth.revokeAccessToken().then((response)=>{
   *  // console.log(response);
   * }).catch((error)=>{
   *  // console.error(error);
   * });
   * ```
   *
   * {@link https://github.com/asgardeo/asgardeo-auth-js-sdk/tree/master#revokeAccessToken}
   *
   * @preserve
   */
  async revokeAccessToken(userId) {
    const revokeTokenEndpoint = (await this._oidcProviderMetaData()).revocation_endpoint;
    const configData = await this._config();
    if (!revokeTokenEndpoint || revokeTokenEndpoint.trim().length === 0) {
      throw new AsgardeoAuthException(
        "JS-AUTH_CORE-RAT3-NF01",
        "No revoke access token endpoint found.",
        "No revoke access token endpoint was found in the OIDC provider meta data returned by the well-known endpoint or the revoke access token endpoint passed to the SDK is empty."
      );
    }
    const body = [];
    body.push(`client_id=${configData.clientId}`);
    body.push(`token=${(await this._storageManager.getSessionData(userId)).access_token}`);
    body.push("token_type_hint=access_token");
    if (configData.clientSecret && configData.clientSecret.trim().length > 0) {
      body.push(`client_secret=${configData.clientSecret}`);
    }
    let response;
    try {
      response = await fetch(revokeTokenEndpoint, {
        body: body.join("&"),
        credentials: configData.sendCookiesInRequests ? "include" : "same-origin",
        headers: {
          Accept: "application/json",
          "Content-Type": "application/x-www-form-urlencoded"
        },
        method: "POST"
      });
    } catch (error) {
      throw new AsgardeoAuthException(
        "JS-AUTH_CORE-RAT3-NE02",
        "The request to revoke access token failed.",
        error ?? "The request sent to revoke the access token failed."
      );
    }
    if (response.status !== 200 || !response.ok) {
      throw new AsgardeoAuthException(
        "JS-AUTH_CORE-RAT3-HE03",
        `Invalid response status received for revoke access token request (${response.statusText}).`,
        await response.json()
      );
    }
    this._authenticationHelper.clearSession(userId);
    return Promise.resolve(response);
  }
  /**
   * This method refreshes the access token and returns a Promise that resolves with the new access
   * token and other relevant data.
   *
   * @param userId - (Optional) A unique ID of the user to be authenticated. This is useful in multi-user
   * scenarios where each user should be uniquely identified.
   *
   * @returns - A Promise that resolves with the token response.
   *
   * @example
   * ```
   * auth.refreshAccessToken().then((response)=>{
   *  // console.log(response);
   * }).catch((error)=>{
   *  // console.error(error);
   * });
   * ```
   *
   * {@link https://github.com/asgardeo/asgardeo-auth-js-sdk/tree/master#refreshAccessToken}
   *
   * @preserve
   */
  async refreshAccessToken(userId) {
    const tokenEndpoint = (await this._oidcProviderMetaData()).token_endpoint;
    const configData = await this._config();
    const sessionData = await this._storageManager.getSessionData(userId);
    if (!sessionData.refresh_token) {
      throw new AsgardeoAuthException(
        "JS-AUTH_CORE-RAT2-NF01",
        "No refresh token found.",
        "There was no refresh token found. Asgardeo doesn't return a refresh token if the refresh token grant is not enabled."
      );
    }
    if (!tokenEndpoint || tokenEndpoint.trim().length === 0) {
      throw new AsgardeoAuthException(
        "JS-AUTH_CORE-RAT2-NF02",
        "No refresh token endpoint found.",
        "No refresh token endpoint was in the OIDC provider meta data returned by the well-known endpoint or the refresh token endpoint passed to the SDK is empty."
      );
    }
    const body = [];
    body.push(`client_id=${configData.clientId}`);
    body.push(`refresh_token=${sessionData.refresh_token}`);
    body.push("grant_type=refresh_token");
    if (configData.clientSecret && configData.clientSecret.trim().length > 0) {
      body.push(`client_secret=${configData.clientSecret}`);
    }
    let tokenResponse;
    try {
      tokenResponse = await fetch(tokenEndpoint, {
        body: body.join("&"),
        credentials: configData.sendCookiesInRequests ? "include" : "same-origin",
        headers: {
          Accept: "application/json",
          "Content-Type": "application/x-www-form-urlencoded"
        },
        method: "POST"
      });
    } catch (error) {
      throw new AsgardeoAuthException(
        "JS-AUTH_CORE-RAT2-NR03",
        "Refresh access token request failed.",
        error ?? "The request to refresh the access token failed."
      );
    }
    if (!tokenResponse.ok) {
      throw new AsgardeoAuthException(
        "JS-AUTH_CORE-RAT2-HE04",
        `Refreshing access token failed with ${tokenResponse.statusText}`,
        await tokenResponse.json()
      );
    }
    return this._authenticationHelper.handleTokenResponse(tokenResponse, userId);
  }
  /**
   * This method returns the access token.
   *
   * @param userId - (Optional) A unique ID of the user to be authenticated. This is useful in multi-user
   * scenarios where each user should be uniquely identified.
   *
   * @returns - A Promise that resolves with the access token.
   *
   * @example
   * ```
   * const accessToken = await auth.getAccessToken();
   * ```
   *
   * {@link https://github.com/asgardeo/asgardeo-auth-js-sdk/tree/master#getAccessToken}
   *
   * @preserve
   */
  async getAccessToken(userId) {
    return (await this._storageManager.getSessionData(userId))?.access_token;
  }
  /**
   * This method sends a custom-grant request and returns a Promise that resolves with the response
   * depending on the config passed.
   *
   * @param config - A config object containing the custom grant configurations.
   * @param userId - (Optional) A unique ID of the user to be authenticated. This is useful in multi-user
   * scenarios where each user should be uniquely identified.
   *
   * @returns - A Promise that resolves with the response depending
   * on your configurations.
   *
   * @example
   * ```
   * const config = {
   *   attachToken: false,
   *   data: {
   *       client_id: "{{clientId}}",
   *       grant_type: "account_switch",
   *       scope: "{{scope}}",
   *       token: "{{token}}",
   *   },
   *   id: "account-switch",
   *   returnResponse: true,
   *   returnsSession: true,
   *   signInRequired: true
   * }
   *
   * auth.exchangeToken(config).then((response)=>{
   *  // console.log(response);
   * }).catch((error)=>{
   *  // console.error(error);
   * });
   * ```
   *
   * {@link https://github.com/asgardeo/asgardeo-auth-js-sdk/tree/master#exchangeToken}
   *
   * @preserve
   */
  async exchangeToken(config, userId) {
    const oidcProviderMetadata = await this._oidcProviderMetaData();
    const configData = await this._config();
    let tokenEndpoint;
    if (config.tokenEndpoint && config.tokenEndpoint.trim().length !== 0) {
      tokenEndpoint = config.tokenEndpoint;
    } else {
      tokenEndpoint = oidcProviderMetadata.token_endpoint;
    }
    if (!tokenEndpoint || tokenEndpoint.trim().length === 0) {
      throw new AsgardeoAuthException(
        "JS-AUTH_CORE-RCG-NF01",
        "Token endpoint not found.",
        "No token endpoint was found in the OIDC provider meta data returned by the well-known endpoint or the token endpoint passed to the SDK is empty."
      );
    }
    const data = await Promise.all(
      Object.entries(config.data).map(async ([key, value]) => {
        const newValue = await this._authenticationHelper.replaceCustomGrantTemplateTags(
          value,
          userId
        );
        return `${key}=${newValue}`;
      })
    );
    let requestHeaders = {
      Accept: "application/json",
      "Content-Type": "application/x-www-form-urlencoded"
    };
    if (config.attachToken) {
      requestHeaders = {
        ...requestHeaders,
        Authorization: `Bearer ${(await this._storageManager.getSessionData(userId)).access_token}`
      };
    }
    const requestConfig = {
      body: data.join("&"),
      credentials: configData.sendCookiesInRequests ? "include" : "same-origin",
      headers: new Headers(requestHeaders),
      method: "POST"
    };
    let response;
    try {
      response = await fetch(tokenEndpoint, requestConfig);
    } catch (error) {
      throw new AsgardeoAuthException(
        "JS-AUTH_CORE-RCG-NE02",
        "The custom grant request failed.",
        error ?? "The request sent to get the custom grant failed."
      );
    }
    if (response.status !== 200 || !response.ok) {
      throw new AsgardeoAuthException(
        "JS-AUTH_CORE-RCG-HE03",
        `Invalid response status received for the custom grant request. (${response.statusText})`,
        await response.json()
      );
    }
    if (config.returnsSession) {
      return this._authenticationHelper.handleTokenResponse(response, userId);
    } else {
      return Promise.resolve(await response.json());
    }
  }
  /**
   * This method returns if the user is authenticated or not.
   *
   * @param userId - (Optional) A unique ID of the user to be authenticated. This is useful in multi-user
   * scenarios where each user should be uniquely identified.
   *
   * @returns - A Promise that resolves with `true` if the user is authenticated, `false` otherwise.
   *
   * @example
   * ```
   * await auth.isSignedIn();
   * ```
   *
   * {@link https://github.com/asgardeo/asgardeo-auth-js-sdk/tree/master#isSignedIn}
   *
   * @preserve
   */
  async isSignedIn(userId) {
    const isAccessTokenAvailable = Boolean(await this.getAccessToken(userId));
    const createdAt = (await this._storageManager.getSessionData(userId))?.created_at;
    const expiresInString = (await this._storageManager.getSessionData(userId))?.expires_in;
    if (!expiresInString) {
      return false;
    }
    const expiresIn = parseInt(expiresInString) * 1e3;
    const currentTime = (/* @__PURE__ */ new Date()).getTime();
    const isAccessTokenValid = createdAt + expiresIn > currentTime;
    const isSignedIn = isAccessTokenAvailable && isAccessTokenValid;
    return isSignedIn;
  }
  /**
   * This method returns the PKCE code generated during the generation of the authentication URL.
   *
   * @param userId - (Optional) A unique ID of the user to be authenticated. This is useful in multi-user
   * scenarios where each user should be uniquely identified.
   * @param state - The state parameter that was passed in the authentication URL.
   *
   * @returns - A Promise that resolves with the PKCE code.
   *
   * @example
   * ```
   * const pkce = await getPKCECode();
   * ```
   *
   * {@link https://github.com/asgardeo/asgardeo-auth-js-sdk/tree/master#getPKCECode}
   *
   * @preserve
   */
  async getPKCECode(state, userId) {
    return await this._storageManager.getTemporaryDataParameter(
      extractPkceStorageKeyFromState_default(state),
      userId
    );
  }
  /**
   * This method sets the PKCE code to the data store.
   *
   * @param pkce - The PKCE code.
   * @param state - The state parameter that was passed in the authentication URL.
   * @param userId - (Optional) A unique ID of the user to be authenticated. This is useful in multi-user
   * scenarios where each user should be uniquely identified.
   *
   * @example
   * ```
   * await auth.setPKCECode("pkce_code")
   * ```
   *
   * {@link https://github.com/asgardeo/asgardeo-auth-js-sdk/tree/master#setPKCECode}
   *
   * @preserve
   */
  async setPKCECode(pkce, state, userId) {
    return await this._storageManager.setTemporaryDataParameter(extractPkceStorageKeyFromState_default(state), pkce, userId);
  }
  /**
   * This method returns if the sign-out is successful or not.
   *
   * @param signOutRedirectUrl - The URL to which the user has been redirected to after signing-out.
   *
   * **The server appends path parameters to the `afterSignOutUrl` and these path parameters
   *  are required for this method to function.**
   *
   * @returns - `true` if successful, `false` otherwise.
   *
   * {@link https://github.com/asgardeo/asgardeo-auth-js-sdk/tree/master#isSignOutSuccessful}
   *
   * @preserve
   */
  static isSignOutSuccessful(afterSignOutUrl) {
    const url = new URL(afterSignOutUrl);
    const stateParam = url.searchParams.get(OIDCRequestConstants_default.Params.STATE);
    const error = Boolean(url.searchParams.get("error"));
    return stateParam ? stateParam === OIDCRequestConstants_default.Params.SIGN_OUT_SUCCESS && !error : false;
  }
  /**
   * This method returns if the sign-out has failed or not.
   *
   * @param signOutRedirectUrl - The URL to which the user has been redirected to after signing-out.
   *
   * **The server appends path parameters to the `afterSignOutUrl` and these path parameters
   *  are required for this method to function.**
   *
   * @returns - `true` if successful, `false` otherwise.
   *
   * {@link https://github.com/asgardeo/asgardeo-auth-js-sdk/tree/master#didSignOutFail}
   *
   * @preserve
   */
  static didSignOutFail(afterSignOutUrl) {
    const url = new URL(afterSignOutUrl);
    const stateParam = url.searchParams.get(OIDCRequestConstants_default.Params.STATE);
    const error = Boolean(url.searchParams.get("error"));
    return stateParam ? stateParam === OIDCRequestConstants_default.Params.SIGN_OUT_SUCCESS && error : false;
  }
  /**
   * This method updates the configuration that was passed into the constructor when instantiating this class.
   *
   * @param config - A config object to update the SDK configurations with.
   *
   * @example
   * ```
   * const config = {
   *     afterSignInUrl: "http://localhost:3000/sign-in",
   *     clientId: "client ID",
   *     baseUrl: "https://localhost:9443"
   * }
   *
   * await auth.reInitialize(config);
   * ```
   * {@link https://github.com/asgardeo/asgardeo-auth-js-sdk/tree/master#reInitialize}
   *
   * @preserve
   */
  async reInitialize(config) {
    await this._storageManager.setConfigData(config);
    await this.loadOpenIDProviderConfiguration(true);
  }
  static async clearSession(userId) {
    await this._authenticationHelper.clearSession(userId);
  }
};
__publicField(_AsgardeoAuthClient, "_instanceID");
// FIXME: Validate this.
// Ref: https://github.com/asgardeo/asgardeo-auth-js-core/pull/205
__publicField(_AsgardeoAuthClient, "_authenticationHelper");
var AsgardeoAuthClient = _AsgardeoAuthClient;

// src/errors/AsgardeoAPIError.ts
var AsgardeoAPIError = class extends AsgardeoError {
  /**
   * Creates an instance of AsgardeoAPIError.
   *
   * @param message - Human-readable description of the error
   * @param code - A unique error code that identifies the error type
   * @param statusCode - HTTP status code of the failed request
   * @param statusText - HTTP status text of the failed request
   * @param origin - Optional. The SDK origin (e.g. 'react', 'vue'). Defaults to generic 'Asgardeo'
   * @constructor
   */
  constructor(message, code, origin, statusCode, statusText) {
    super(message, code, origin);
    this.statusCode = statusCode;
    this.statusText = statusText;
    Object.defineProperty(this, "name", {
      value: "AsgardeoAPIError",
      configurable: true,
      writable: true
    });
  }
  /**
   * Returns a string representation of the API error
   * @returns Formatted error string with name, code, status, and message
   */
  toString() {
    const status = this.statusCode ? ` (HTTP ${this.statusCode} - ${this.statusText})` : "";
    return `[${this.name}] (code="${this.code}")${status}
Message: ${this.message}`;
  }
};

// src/api/initializeEmbeddedSignInFlow.ts
var initializeEmbeddedSignInFlow = async ({
  url,
  baseUrl,
  payload,
  ...requestConfig
}) => {
  if (!payload) {
    throw new AsgardeoAPIError(
      "Authorization payload is required",
      "initializeEmbeddedSignInFlow-ValidationError-002",
      "javascript",
      400,
      "If an authorization payload is not provided, the request cannot be constructed correctly."
    );
  }
  const searchParams = new URLSearchParams();
  Object.entries(payload).forEach(([key, value]) => {
    if (value !== void 0 && value !== null) {
      searchParams.append(key, String(value));
    }
  });
  const response = await fetch(url ?? `${baseUrl}/oauth2/authorize`, {
    ...requestConfig,
    method: requestConfig.method || "POST",
    headers: {
      ...requestConfig.headers,
      "Content-Type": "application/x-www-form-urlencoded",
      Accept: "application/json"
    },
    body: searchParams.toString()
  });
  if (!response.ok) {
    const errorText = await response.text();
    throw new AsgardeoAPIError(
      `Authorization request failed: ${errorText}`,
      "initializeEmbeddedSignInFlow-ResponseError-001",
      "javascript",
      response.status,
      response.statusText
    );
  }
  return await response.json();
};
var initializeEmbeddedSignInFlow_default = initializeEmbeddedSignInFlow;

// src/api/executeEmbeddedSignInFlow.ts
var executeEmbeddedSignInFlow = async ({
  url,
  baseUrl,
  payload,
  ...requestConfig
}) => {
  if (!payload) {
    throw new AsgardeoAPIError(
      "Authorization payload is required",
      "executeEmbeddedSignInFlow-ValidationError-002",
      "javascript",
      400,
      "If an authorization payload is not provided, the request cannot be constructed correctly."
    );
  }
  const response = await fetch(url ?? `${baseUrl}/oauth2/authn`, {
    ...requestConfig,
    method: requestConfig.method || "POST",
    headers: {
      "Content-Type": "application/json",
      Accept: "application/json",
      ...requestConfig.headers
    },
    body: JSON.stringify(payload)
  });
  if (!response.ok) {
    const errorText = await response.text();
    throw new AsgardeoAPIError(
      `Authorization request failed: ${errorText}`,
      "initializeEmbeddedSignInFlow-ResponseError-001",
      "javascript",
      response.status,
      response.statusText
    );
  }
  return await response.json();
};
var executeEmbeddedSignInFlow_default = executeEmbeddedSignInFlow;

// src/models/embedded-flow.ts
var EmbeddedFlowType = /* @__PURE__ */ ((EmbeddedFlowType2) => {
  EmbeddedFlowType2["Registration"] = "REGISTRATION";
  return EmbeddedFlowType2;
})(EmbeddedFlowType || {});
var EmbeddedFlowStatus = /* @__PURE__ */ ((EmbeddedFlowStatus2) => {
  EmbeddedFlowStatus2["Complete"] = "COMPLETE";
  EmbeddedFlowStatus2["Incomplete"] = "INCOMPLETE";
  return EmbeddedFlowStatus2;
})(EmbeddedFlowStatus || {});
var EmbeddedFlowResponseType = /* @__PURE__ */ ((EmbeddedFlowResponseType2) => {
  EmbeddedFlowResponseType2["Redirection"] = "REDIRECTION";
  EmbeddedFlowResponseType2["View"] = "VIEW";
  return EmbeddedFlowResponseType2;
})(EmbeddedFlowResponseType || {});
var EmbeddedFlowComponentType = /* @__PURE__ */ ((EmbeddedFlowComponentType2) => {
  EmbeddedFlowComponentType2["Button"] = "BUTTON";
  EmbeddedFlowComponentType2["Checkbox"] = "CHECKBOX";
  EmbeddedFlowComponentType2["Divider"] = "DIVIDER";
  EmbeddedFlowComponentType2["Form"] = "FORM";
  EmbeddedFlowComponentType2["Image"] = "IMAGE";
  EmbeddedFlowComponentType2["Input"] = "INPUT";
  EmbeddedFlowComponentType2["Radio"] = "RADIO";
  EmbeddedFlowComponentType2["Select"] = "SELECT";
  EmbeddedFlowComponentType2["Typography"] = "TYPOGRAPHY";
  return EmbeddedFlowComponentType2;
})(EmbeddedFlowComponentType || {});

// src/api/executeEmbeddedSignUpFlow.ts
var executeEmbeddedSignUpFlow = async ({
  url,
  baseUrl,
  payload,
  ...requestConfig
}) => {
  if (!baseUrl && !url) {
    throw new AsgardeoAPIError(
      "Embedded SignUp flow execution failed: Base URL or URL is not provided.",
      "javascript-executeEmbeddedSignUpFlow-ValidationError-001",
      "javascript",
      400,
      "At least one of the baseUrl or url must be provided to execute the embedded sign up flow."
    );
  }
  const response = await fetch(url ?? `${baseUrl}/api/server/v1/flow/execute`, {
    ...requestConfig,
    method: requestConfig.method || "POST",
    headers: {
      "Content-Type": "application/json",
      Accept: "application/json",
      ...requestConfig.headers
    },
    body: JSON.stringify({
      ...payload ?? {},
      flowType: "REGISTRATION" /* Registration */
    })
  });
  if (!response.ok) {
    const errorText = await response.text();
    throw new AsgardeoAPIError(
      `Embedded SignUp flow execution failed: ${errorText}`,
      "javascript-executeEmbeddedSignUpFlow-ResponseError-100",
      "javascript",
      response.status,
      response.statusText
    );
  }
  return await response.json();
};
var executeEmbeddedSignUpFlow_default = executeEmbeddedSignUpFlow;

// src/api/getUserInfo.ts
var getUserInfo = async ({ url, ...requestConfig }) => {
  try {
    new URL(url);
  } catch (error) {
    throw new AsgardeoAPIError(
      "Invalid endpoint URL provided",
      "getUserInfo-ValidationError-001",
      "javascript",
      400,
      "Invalid Request"
    );
  }
  const response = await fetch(url, {
    ...requestConfig,
    method: "GET",
    headers: {
      "Content-Type": "application/json",
      Accept: "application/json",
      ...requestConfig.headers
    }
  });
  if (!response.ok) {
    const errorText = await response.text();
    throw new AsgardeoAPIError(
      `Failed to fetch user info: ${errorText}`,
      "getUserInfo-ResponseError-001",
      "javascript",
      response.status,
      response.statusText
    );
  }
  return await response.json();
};
var getUserInfo_default = getUserInfo;

// src/utils/processUsername.ts
var USERSTORE_PREFIX_REGEX = /^[A-Z_][A-Z0-9_]*\//;
var removeUserstorePrefix = (username) => {
  if (!username) {
    return "";
  }
  return username.replace(USERSTORE_PREFIX_REGEX, "");
};
var processUsername = (user) => {
  if (!user) {
    return user;
  }
  const processedUser = { ...user };
  if (processedUser.username) {
    processedUser.username = removeUserstorePrefix(processedUser.username);
  }
  if (processedUser.userName) {
    processedUser.userName = removeUserstorePrefix(processedUser.userName);
  }
  if (processedUser.user_name) {
    processedUser.user_name = removeUserstorePrefix(processedUser.user_name);
  }
  return processedUser;
};
var processUsername_default = processUsername;

// src/api/getScim2Me.ts
var getScim2Me = async ({ url, baseUrl, fetcher, ...requestConfig }) => {
  try {
    new URL(url ?? baseUrl);
  } catch (error) {
    throw new AsgardeoAPIError(
      `Invalid URL provided. ${error?.toString()}`,
      "getScim2Me-ValidationError-001",
      "javascript",
      400,
      "The provided `url` or `baseUrl` path does not adhere to the URL schema."
    );
  }
  const fetchFn = fetcher || fetch;
  const resolvedUrl = url ?? `${baseUrl}/scim2/Me`;
  const requestInit = {
    ...requestConfig,
    method: "GET",
    headers: {
      "Content-Type": "application/scim+json",
      Accept: "application/json",
      ...requestConfig.headers
    }
  };
  try {
    const response = await fetchFn(resolvedUrl, requestInit);
    if (!response?.ok) {
      const errorText = await response.text();
      throw new AsgardeoAPIError(
        `Failed to fetch user profile: ${errorText}`,
        "getScim2Me-ResponseError-001",
        "javascript",
        response.status,
        response.statusText
      );
    }
    const user = await response.json();
    return processUsername_default(user);
  } catch (error) {
    if (error instanceof AsgardeoAPIError) {
      throw error;
    }
    throw new AsgardeoAPIError(
      `Network or parsing error: ${error instanceof Error ? error.message : "Unknown error"}`,
      "getScim2Me-NetworkError-001",
      "javascript",
      0,
      "Network Error"
    );
  }
};
var getScim2Me_default = getScim2Me;

// src/api/getSchemas.ts
var getSchemas = async ({ url, baseUrl, fetcher, ...requestConfig }) => {
  try {
    new URL(url ?? baseUrl);
  } catch (error) {
    throw new AsgardeoAPIError(
      `Invalid URL provided. ${error?.toString()}`,
      "getSchemas-ValidationError-001",
      "javascript",
      400,
      "The provided `url` or `baseUrl` path does not adhere to the URL schema."
    );
  }
  const fetchFn = fetcher || fetch;
  const resolvedUrl = url ?? `${baseUrl}/scim2/Schemas`;
  const requestInit = {
    ...requestConfig,
    method: "GET",
    headers: {
      "Content-Type": "application/json",
      Accept: "application/json",
      ...requestConfig.headers
    }
  };
  try {
    const response = await fetchFn(resolvedUrl, requestInit);
    if (!response?.ok) {
      const errorText = await response.text();
      throw new AsgardeoAPIError(
        `Failed to fetch SCIM2 schemas: ${errorText}`,
        "getSchemas-ResponseError-001",
        "javascript",
        response.status,
        response.statusText
      );
    }
    return await response.json();
  } catch (error) {
    if (error instanceof AsgardeoAPIError) {
      throw error;
    }
    throw new AsgardeoAPIError(
      `Network or parsing error: ${error instanceof Error ? error.message : "Unknown error"}`,
      "getSchemas-NetworkError-001",
      "javascript",
      0,
      "Network Error"
    );
  }
};
var getSchemas_default = getSchemas;

// src/api/getAllOrganizations.ts
var getAllOrganizations = async ({
  baseUrl,
  filter = "",
  limit = 10,
  recursive = false,
  fetcher,
  ...requestConfig
}) => {
  try {
    new URL(baseUrl);
  } catch (error) {
    throw new AsgardeoAPIError(
      `Invalid base URL provided. ${error?.toString()}`,
      "getAllOrganizations-ValidationError-001",
      "javascript",
      400,
      "The provided `baseUrl` does not adhere to the URL schema."
    );
  }
  const queryParams = new URLSearchParams(
    Object.fromEntries(
      Object.entries({
        filter,
        limit: limit.toString(),
        recursive: recursive.toString()
      }).filter(([, value]) => Boolean(value))
    )
  );
  const fetchFn = fetcher || fetch;
  const resolvedUrl = `${baseUrl}/api/server/v1/organizations?${queryParams.toString()}`;
  const requestInit = {
    ...requestConfig,
    method: "GET",
    headers: {
      ...requestConfig.headers,
      "Content-Type": "application/json",
      Accept: "application/json"
    }
  };
  try {
    const response = await fetchFn(resolvedUrl, requestInit);
    if (!response?.ok) {
      const errorText = await response.text();
      throw new AsgardeoAPIError(
        `Failed to get organizations: ${errorText}`,
        "getAllOrganizations-ResponseError-001",
        "javascript",
        response.status,
        response.statusText
      );
    }
    const data = await response.json();
    return {
      hasMore: data.hasMore,
      nextCursor: data.nextCursor,
      organizations: data.organizations || [],
      totalCount: data.totalCount
    };
  } catch (error) {
    if (error instanceof AsgardeoAPIError) {
      throw error;
    }
    throw new AsgardeoAPIError(
      `Network or parsing error: ${error instanceof Error ? error.message : "Unknown error"}`,
      "getAllOrganizations-NetworkError-001",
      "javascript",
      0,
      "Network Error"
    );
  }
};
var getAllOrganizations_default = getAllOrganizations;

// src/api/createOrganization.ts
var createOrganization = async ({
  baseUrl,
  payload,
  fetcher,
  ...requestConfig
}) => {
  try {
    new URL(baseUrl);
  } catch (error) {
    throw new AsgardeoAPIError(
      `Invalid base URL provided. ${error?.toString()}`,
      "createOrganization-ValidationError-001",
      "javascript",
      400,
      "The provided `baseUrl` does not adhere to the URL schema."
    );
  }
  if (!payload) {
    throw new AsgardeoAPIError(
      "Organization payload is required",
      "createOrganization-ValidationError-002",
      "javascript",
      400,
      "Invalid Request"
    );
  }
  const organizationPayload = {
    ...payload,
    type: "TENANT"
  };
  const fetchFn = fetcher || fetch;
  const resolvedUrl = `${baseUrl}/api/server/v1/organizations`;
  const requestInit = {
    ...requestConfig,
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Accept: "application/json",
      ...requestConfig.headers
    },
    body: JSON.stringify(organizationPayload)
  };
  try {
    const response = await fetchFn(resolvedUrl, requestInit);
    if (!response?.ok) {
      const errorText = await response.text();
      throw new AsgardeoAPIError(
        `Failed to create organization: ${errorText}`,
        "createOrganization-ResponseError-001",
        "javascript",
        response.status,
        response.statusText
      );
    }
    return await response.json();
  } catch (error) {
    if (error instanceof AsgardeoAPIError) {
      throw error;
    }
    throw new AsgardeoAPIError(
      `Network or parsing error: ${error instanceof Error ? error.message : "Unknown error"}`,
      "createOrganization-NetworkError-001",
      "javascript",
      0,
      "Network Error"
    );
  }
};
var createOrganization_default = createOrganization;

// src/api/getMeOrganizations.ts
var getMeOrganizations = async ({
  baseUrl,
  after = "",
  authorizedAppName = "",
  before = "",
  filter = "",
  limit = 10,
  recursive = false,
  fetcher,
  ...requestConfig
}) => {
  try {
    new URL(baseUrl);
  } catch (error) {
    throw new AsgardeoAPIError(
      `Invalid base URL provided. ${error?.toString()}`,
      "getMeOrganizations-ValidationError-001",
      "javascript",
      400,
      "The provided `baseUrl` does not adhere to the URL schema."
    );
  }
  const queryParams = new URLSearchParams(
    Object.fromEntries(
      Object.entries({
        after,
        authorizedAppName,
        before,
        filter,
        limit: limit.toString(),
        recursive: recursive.toString()
      }).filter(([, value]) => Boolean(value))
    )
  );
  const fetchFn = fetcher || fetch;
  const resolvedUrl = `${baseUrl}/api/users/v1/me/organizations?${queryParams.toString()}`;
  const requestInit = {
    ...requestConfig,
    method: "GET",
    headers: {
      "Content-Type": "application/json",
      Accept: "application/json",
      ...requestConfig.headers
    }
  };
  try {
    const response = await fetchFn(resolvedUrl, requestInit);
    if (!response?.ok) {
      const errorText = await response.text();
      throw new AsgardeoAPIError(
        `Failed to fetch associated organizations of the user: ${errorText}`,
        "getMeOrganizations-ResponseError-001",
        "javascript",
        response.status,
        response.statusText
      );
    }
    const data = await response.json();
    return data.organizations || [];
  } catch (error) {
    if (error instanceof AsgardeoAPIError) {
      throw error;
    }
    throw new AsgardeoAPIError(
      `Network or parsing error: ${error instanceof Error ? error.message : "Unknown error"}`,
      "getMeOrganizations-NetworkError-001",
      "javascript",
      0,
      "Network Error"
    );
  }
};
var getMeOrganizations_default = getMeOrganizations;

// src/api/getOrganization.ts
var getOrganization = async ({
  baseUrl,
  organizationId,
  fetcher,
  ...requestConfig
}) => {
  try {
    new URL(baseUrl);
  } catch (error) {
    throw new AsgardeoAPIError(
      `Invalid base URL provided. ${error?.toString()}`,
      "getOrganization-ValidationError-001",
      "javascript",
      400,
      "The provided `baseUrl` does not adhere to the URL schema."
    );
  }
  if (!organizationId) {
    throw new AsgardeoAPIError(
      "Organization ID is required",
      "getOrganization-ValidationError-002",
      "javascript",
      400,
      "Invalid Request"
    );
  }
  const fetchFn = fetcher || fetch;
  const resolvedUrl = `${baseUrl}/api/server/v1/organizations/${organizationId}`;
  const requestInit = {
    ...requestConfig,
    method: "GET",
    headers: {
      "Content-Type": "application/json",
      Accept: "application/json",
      ...requestConfig.headers
    }
  };
  try {
    const response = await fetchFn(resolvedUrl, requestInit);
    if (!response?.ok) {
      const errorText = await response.text();
      throw new AsgardeoAPIError(
        `Failed to fetch organization details: ${errorText}`,
        "getOrganization-ResponseError-001",
        "javascript",
        response.status,
        response.statusText
      );
    }
    return await response.json();
  } catch (error) {
    if (error instanceof AsgardeoAPIError) {
      throw error;
    }
    throw new AsgardeoAPIError(
      `Network or parsing error: ${error instanceof Error ? error.message : "Unknown error"}`,
      "getOrganization-NetworkError-001",
      "javascript",
      0,
      "Network Error"
    );
  }
};
var getOrganization_default = getOrganization;

// src/utils/isEmpty.ts
var isEmpty = (value) => {
  if (value === null || value === void 0) {
    return true;
  }
  if (typeof value === "string") {
    return value.trim() === "";
  }
  if (Array.isArray(value)) {
    return value.length === 0;
  }
  if (typeof value === "object" && value.constructor === Object) {
    return Object.keys(value).length === 0;
  }
  return false;
};
var isEmpty_default = isEmpty;

// src/api/updateOrganization.ts
var updateOrganization = async ({
  baseUrl,
  organizationId,
  operations,
  fetcher,
  ...requestConfig
}) => {
  try {
    new URL(baseUrl);
  } catch (error) {
    throw new AsgardeoAPIError(
      `Invalid base URL provided. ${error?.toString()}`,
      "updateOrganization-ValidationError-001",
      "javascript",
      400,
      "The provided `baseUrl` does not adhere to the URL schema."
    );
  }
  if (!organizationId) {
    throw new AsgardeoAPIError(
      "Organization ID is required",
      "updateOrganization-ValidationError-002",
      "javascript",
      400,
      "Invalid Request"
    );
  }
  if (!operations || !Array.isArray(operations) || operations.length === 0) {
    throw new AsgardeoAPIError(
      "Operations array is required and cannot be empty",
      "updateOrganization-ValidationError-003",
      "javascript",
      400,
      "Invalid Request"
    );
  }
  const fetchFn = fetcher || fetch;
  const resolvedUrl = `${baseUrl}/api/server/v1/organizations/${organizationId}`;
  const requestInit = {
    ...requestConfig,
    method: "PATCH",
    headers: {
      "Content-Type": "application/json",
      Accept: "application/json",
      ...requestConfig.headers
    },
    body: JSON.stringify(operations)
  };
  try {
    const response = await fetchFn(resolvedUrl, requestInit);
    if (!response?.ok) {
      const errorText = await response.text();
      throw new AsgardeoAPIError(
        `Failed to update organization: ${errorText}`,
        "updateOrganization-ResponseError-001",
        "javascript",
        response.status,
        response.statusText
      );
    }
    return await response.json();
  } catch (error) {
    if (error instanceof AsgardeoAPIError) {
      throw error;
    }
    throw new AsgardeoAPIError(
      `Network or parsing error: ${error instanceof Error ? error.message : "Unknown error"}`,
      "updateOrganization-NetworkError-001",
      "javascript",
      0,
      "Network Error"
    );
  }
};
var createPatchOperations = (payload) => {
  return Object.entries(payload).map(([key, value]) => {
    if (isEmpty_default(value)) {
      return {
        operation: "REMOVE",
        path: `/${key}`
      };
    }
    return {
      operation: "REPLACE",
      path: `/${key}`,
      value
    };
  });
};
var updateOrganization_default = updateOrganization;

// src/api/updateMeProfile.ts
var updateMeProfile = async ({
  url,
  baseUrl,
  payload,
  fetcher,
  ...requestConfig
}) => {
  try {
    new URL(url ?? baseUrl);
  } catch (error) {
    throw new AsgardeoAPIError(
      `Invalid URL provided. ${error?.toString()}`,
      "updateMeProfile-ValidationError-001",
      "javascript",
      400,
      "The provided `url` or `baseUrl` path does not adhere to the URL schema."
    );
  }
  const data = {
    Operations: [
      {
        op: "replace",
        value: payload
      }
    ],
    schemas: ["urn:ietf:params:scim:api:messages:2.0:PatchOp"]
  };
  const fetchFn = fetcher || fetch;
  const resolvedUrl = url ?? `${baseUrl}/scim2/Me`;
  const requestInit = {
    method: "PATCH",
    ...requestConfig,
    headers: {
      ...requestConfig.headers,
      "Content-Type": "application/scim+json",
      Accept: "application/json"
    },
    body: JSON.stringify(data)
  };
  try {
    const response = await fetchFn(resolvedUrl, requestInit);
    if (!response?.ok) {
      const errorText = await response.text();
      throw new AsgardeoAPIError(
        `Failed to update user profile: ${errorText}`,
        "updateMeProfile-ResponseError-001",
        "javascript",
        response.status,
        response.statusText
      );
    }
    return await response.json();
  } catch (error) {
    if (error instanceof AsgardeoAPIError) {
      throw error;
    }
    throw new AsgardeoAPIError(
      `Network or parsing error: ${error instanceof Error ? error.message : "Unknown error"}`,
      "updateMeProfile-NetworkError-001",
      "javascript",
      0,
      "Network Error"
    );
  }
};
var updateMeProfile_default = updateMeProfile;

// src/api/getBrandingPreference.ts
var getBrandingPreference = async ({
  baseUrl,
  locale,
  name,
  type,
  fetcher,
  ...requestConfig
}) => {
  try {
    new URL(baseUrl);
  } catch (error) {
    throw new AsgardeoAPIError(
      `Invalid base URL provided. ${error?.toString()}`,
      "getBrandingPreference-ValidationError-001",
      "javascript",
      400,
      "The provided `baseUrl` does not adhere to the URL schema."
    );
  }
  const queryParams = new URLSearchParams(
    Object.fromEntries(
      Object.entries({
        locale: locale || "",
        name: name || "",
        type: type || ""
      }).filter(([, value]) => Boolean(value))
    )
  );
  const fetchFn = fetcher || fetch;
  const resolvedUrl = `${baseUrl}/api/server/v1/branding-preference/resolve${queryParams.toString() ? `?${queryParams.toString()}` : ""}`;
  const requestInit = {
    ...requestConfig,
    method: "GET",
    headers: {
      "Content-Type": "application/json",
      Accept: "application/json",
      ...requestConfig.headers
    }
  };
  try {
    const response = await fetchFn(resolvedUrl, requestInit);
    if (!response?.ok) {
      const errorText = await response.text();
      throw new AsgardeoAPIError(
        `Failed to get branding preference: ${errorText}`,
        "getBrandingPreference-ResponseError-001",
        "javascript",
        response.status,
        response.statusText
      );
    }
    const data = await response.json();
    return data;
  } catch (error) {
    if (error instanceof AsgardeoAPIError) {
      throw error;
    }
    throw new AsgardeoAPIError(
      `Network or parsing error: ${error instanceof Error ? error.message : "Unknown error"}`,
      "getBrandingPreference-NetworkError-001",
      "javascript",
      0,
      "Network Error"
    );
  }
};
var getBrandingPreference_default = getBrandingPreference;

// src/constants/ApplicationNativeAuthenticationConstants.ts
var ApplicationNativeAuthenticationConstants = {
  SupportedAuthenticators: {
    IdentifierFirst: "SWRlbnRpZmllckV4ZWN1dG9yOkxPQ0FM",
    EmailOtp: "ZW1haWwtb3RwLWF1dGhlbnRpY2F0b3I6TE9DQUw",
    Totp: "dG90cDpMT0NBTA",
    UsernamePassword: "QmFzaWNBdXRoZW50aWNhdG9yOkxPQ0FM",
    PushNotification: "cHVzaC1ub3RpZmljYXRpb24tYXV0aGVudGljYXRvcjpMT0NBTA",
    Passkey: "RklET0F1dGhlbnRpY2F0b3I6TE9DQUw",
    SmsOtp: "c21zLW90cC1hdXRoZW50aWNhdG9yOkxPQ0FM",
    MagicLink: "TWFnaWNMaW5rQXV0aGVudGljYXRvcjpMT0NBTA",
    Google: "R29vZ2xlT0lEQ0F1dGhlbnRpY2F0b3I6R29vZ2xl",
    GitHub: "R2l0aHViQXV0aGVudGljYXRvcjpHaXRIdWI",
    Microsoft: "T3BlbklEQ29ubmVjdEF1dGhlbnRpY2F0b3I6TWljcm9zb2Z0",
    Facebook: "RmFjZWJvb2tBdXRoZW50aWNhdG9yOkZhY2Vib29r",
    LinkedIn: "TGlua2VkSW5PSURDOkxpbmtlZElu",
    SignInWithEthereum: "T3BlbklEQ29ubmVjdEF1dGhlbnRpY2F0b3I6U2lnbiBJbiBXaXRoIEV0aGVyZXVt"
  }
};
var ApplicationNativeAuthenticationConstants_default = ApplicationNativeAuthenticationConstants;

// src/constants/VendorConstants.ts
var VendorConstants = {
  /**
   * The prefix used for vendor-specific API endpoints, CSS classes, or other identifiers.
   */
  VENDOR_PREFIX: "asgardeo"
};
var VendorConstants_default = VendorConstants;

// src/models/embedded-signin-flow.ts
var EmbeddedSignInFlowStatus = /* @__PURE__ */ ((EmbeddedSignInFlowStatus2) => {
  EmbeddedSignInFlowStatus2["FailCompleted"] = "FAIL_COMPLETED";
  EmbeddedSignInFlowStatus2["FailIncomplete"] = "FAIL_INCOMPLETE";
  EmbeddedSignInFlowStatus2["Incomplete"] = "INCOMPLETE";
  EmbeddedSignInFlowStatus2["SuccessCompleted"] = "SUCCESS_COMPLETED";
  return EmbeddedSignInFlowStatus2;
})(EmbeddedSignInFlowStatus || {});
var EmbeddedSignInFlowType = /* @__PURE__ */ ((EmbeddedSignInFlowType2) => {
  EmbeddedSignInFlowType2["Authentication"] = "AUTHENTICATION";
  return EmbeddedSignInFlowType2;
})(EmbeddedSignInFlowType || {});
var EmbeddedSignInFlowStepType = /* @__PURE__ */ ((EmbeddedSignInFlowStepType2) => {
  EmbeddedSignInFlowStepType2["AuthenticatorPrompt"] = "AUTHENTICATOR_PROMPT";
  EmbeddedSignInFlowStepType2["MultiOptionsPrompt"] = "MULTI_OPTIONS_PROMPT";
  return EmbeddedSignInFlowStepType2;
})(EmbeddedSignInFlowStepType || {});
var EmbeddedSignInFlowAuthenticatorParamType = /* @__PURE__ */ ((EmbeddedSignInFlowAuthenticatorParamType2) => {
  EmbeddedSignInFlowAuthenticatorParamType2["Integer"] = "INTEGER";
  EmbeddedSignInFlowAuthenticatorParamType2["MultiValued"] = "MULTI_VALUED";
  EmbeddedSignInFlowAuthenticatorParamType2["String"] = "STRING";
  return EmbeddedSignInFlowAuthenticatorParamType2;
})(EmbeddedSignInFlowAuthenticatorParamType || {});
var EmbeddedSignInFlowAuthenticatorKnownIdPType = /* @__PURE__ */ ((EmbeddedSignInFlowAuthenticatorKnownIdPType2) => {
  EmbeddedSignInFlowAuthenticatorKnownIdPType2["Local"] = "LOCAL";
  return EmbeddedSignInFlowAuthenticatorKnownIdPType2;
})(EmbeddedSignInFlowAuthenticatorKnownIdPType || {});
var EmbeddedSignInFlowAuthenticatorPromptType = /* @__PURE__ */ ((EmbeddedSignInFlowAuthenticatorPromptType2) => {
  EmbeddedSignInFlowAuthenticatorPromptType2["InternalPrompt"] = "INTERNAL_PROMPT";
  EmbeddedSignInFlowAuthenticatorPromptType2["RedirectionPrompt"] = "REDIRECTION_PROMPT";
  EmbeddedSignInFlowAuthenticatorPromptType2["UserPrompt"] = "USER_PROMPT";
  return EmbeddedSignInFlowAuthenticatorPromptType2;
})(EmbeddedSignInFlowAuthenticatorPromptType || {});

// src/models/flow.ts
var FlowMode = /* @__PURE__ */ ((FlowMode2) => {
  FlowMode2["Embedded"] = "DIRECT";
  FlowMode2["Redirect"] = "REDIRECTION";
  return FlowMode2;
})(FlowMode || {});

// src/models/scim2-schema.ts
var WellKnownSchemaIds = /* @__PURE__ */ ((WellKnownSchemaIds2) => {
  WellKnownSchemaIds2["Core"] = "urn:ietf:params:scim:schemas:core:2.0";
  WellKnownSchemaIds2["User"] = "urn:ietf:params:scim:schemas:core:2.0:User";
  WellKnownSchemaIds2["EnterpriseUser"] = "urn:ietf:params:scim:schemas:extension:enterprise:2.0:User";
  WellKnownSchemaIds2["SystemUser"] = "urn:scim:wso2:schema";
  WellKnownSchemaIds2["CustomUser"] = "urn:scim:schemas:extension:custom:User";
  return WellKnownSchemaIds2;
})(WellKnownSchemaIds || {});

// src/models/field.ts
var FieldType = /* @__PURE__ */ ((FieldType2) => {
  FieldType2["Text"] = "TEXT";
  FieldType2["Password"] = "PASSWORD";
  FieldType2["Email"] = "EMAIL";
  FieldType2["Number"] = "NUMBER";
  FieldType2["Select"] = "SELECT";
  FieldType2["Checkbox"] = "CHECKBOX";
  FieldType2["Radio"] = "RADIO";
  FieldType2["Otp"] = "OTP";
  FieldType2["Date"] = "DATE";
  FieldType2["Time"] = "TIME";
  FieldType2["Textarea"] = "TEXTAREA";
  return FieldType2;
})(FieldType || {});

// src/AsgardeoJavaScriptClient.ts
var AsgardeoJavaScriptClient = class {
};
var AsgardeoJavaScriptClient_default = AsgardeoJavaScriptClient;

// src/theme/createTheme.ts
var lightTheme = {
  colors: {
    action: {
      active: "rgba(0, 0, 0, 0.54)",
      hover: "rgba(0, 0, 0, 0.04)",
      hoverOpacity: 0.04,
      selected: "rgba(0, 0, 0, 0.08)",
      selectedOpacity: 0.08,
      disabled: "rgba(0, 0, 0, 0.26)",
      disabledBackground: "rgba(0, 0, 0, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(0, 0, 0, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.12
    },
    primary: {
      main: "#1a73e8",
      contrastText: "#ffffff"
    },
    secondary: {
      main: "#424242",
      contrastText: "#ffffff"
    },
    background: {
      surface: "#ffffff",
      disabled: "#f0f0f0",
      body: {
        main: "#1a1a1a"
      }
    },
    error: {
      main: "#d32f2f",
      contrastText: "#ffffff"
    },
    success: {
      main: "#4caf50",
      contrastText: "#ffffff"
    },
    warning: {
      main: "#ff9800",
      contrastText: "#ffffff"
    },
    text: {
      primary: "#1a1a1a",
      secondary: "#666666"
    },
    border: "#e0e0e0"
  },
  spacing: {
    unit: 8
  },
  borderRadius: {
    small: "4px",
    medium: "8px",
    large: "16px"
  },
  shadows: {
    small: "0 2px 8px rgba(0, 0, 0, 0.1)",
    medium: "0 4px 16px rgba(0, 0, 0, 0.15)",
    large: "0 8px 32px rgba(0, 0, 0, 0.2)"
  },
  typography: {
    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
    fontSizes: {
      xs: "0.75rem",
      // 12px
      sm: "0.875rem",
      // 14px
      md: "1rem",
      // 16px
      lg: "1.125rem",
      // 18px
      xl: "1.25rem",
      // 20px
      "2xl": "1.5rem",
      // 24px
      "3xl": "2.125rem"
      // 34px
    },
    fontWeights: {
      normal: 400,
      medium: 500,
      semibold: 600,
      bold: 700
    },
    lineHeights: {
      tight: 1.2,
      normal: 1.4,
      relaxed: 1.6
    }
  },
  images: {
    favicon: {},
    logo: {}
  }
};
var darkTheme = {
  colors: {
    action: {
      active: "rgba(255, 255, 255, 0.70)",
      hover: "rgba(255, 255, 255, 0.04)",
      hoverOpacity: 0.04,
      selected: "rgba(255, 255, 255, 0.08)",
      selectedOpacity: 0.08,
      disabled: "rgba(255, 255, 255, 0.26)",
      disabledBackground: "rgba(255, 255, 255, 0.12)",
      disabledOpacity: 0.38,
      focus: "rgba(255, 255, 255, 0.12)",
      focusOpacity: 0.12,
      activatedOpacity: 0.12
    },
    primary: {
      main: "#1a73e8",
      contrastText: "#ffffff"
    },
    secondary: {
      main: "#424242",
      contrastText: "#ffffff"
    },
    background: {
      surface: "#121212",
      disabled: "#1f1f1f",
      body: {
        main: "#ffffff"
      }
    },
    error: {
      main: "#d32f2f",
      contrastText: "#ffffff"
    },
    success: {
      main: "#4caf50",
      contrastText: "#ffffff"
    },
    warning: {
      main: "#ff9800",
      contrastText: "#ffffff"
    },
    text: {
      primary: "#ffffff",
      secondary: "#b3b3b3"
    },
    border: "#404040"
  },
  spacing: {
    unit: 8
  },
  borderRadius: {
    small: "4px",
    medium: "8px",
    large: "16px"
  },
  shadows: {
    small: "0 2px 8px rgba(0, 0, 0, 0.3)",
    medium: "0 4px 16px rgba(0, 0, 0, 0.4)",
    large: "0 8px 32px rgba(0, 0, 0, 0.5)"
  },
  typography: {
    fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif',
    fontSizes: {
      xs: "0.75rem",
      // 12px
      sm: "0.875rem",
      // 14px
      md: "1rem",
      // 16px
      lg: "1.125rem",
      // 18px
      xl: "1.25rem",
      // 20px
      "2xl": "1.5rem",
      // 24px
      "3xl": "2.125rem"
      // 34px
    },
    fontWeights: {
      normal: 400,
      medium: 500,
      semibold: 600,
      bold: 700
    },
    lineHeights: {
      tight: 1.2,
      normal: 1.4,
      relaxed: 1.6
    }
  },
  images: {
    favicon: {},
    logo: {}
  }
};
var toCssVariables = (theme) => {
  const cssVars = {};
  const prefix = theme.cssVarPrefix || VendorConstants_default.VENDOR_PREFIX;
  if (theme.colors?.action?.active) {
    cssVars[`--${prefix}-color-action-active`] = theme.colors.action.active;
  }
  if (theme.colors?.action?.hover) {
    cssVars[`--${prefix}-color-action-hover`] = theme.colors.action.hover;
  }
  if (theme.colors?.action?.hoverOpacity !== void 0) {
    cssVars[`--${prefix}-color-action-hoverOpacity`] = theme.colors.action.hoverOpacity.toString();
  }
  if (theme.colors?.action?.selected) {
    cssVars[`--${prefix}-color-action-selected`] = theme.colors.action.selected;
  }
  if (theme.colors?.action?.selectedOpacity !== void 0) {
    cssVars[`--${prefix}-color-action-selectedOpacity`] = theme.colors.action.selectedOpacity.toString();
  }
  if (theme.colors?.action?.disabled) {
    cssVars[`--${prefix}-color-action-disabled`] = theme.colors.action.disabled;
  }
  if (theme.colors?.action?.disabledBackground) {
    cssVars[`--${prefix}-color-action-disabledBackground`] = theme.colors.action.disabledBackground;
  }
  if (theme.colors?.action?.disabledOpacity !== void 0) {
    cssVars[`--${prefix}-color-action-disabledOpacity`] = theme.colors.action.disabledOpacity.toString();
  }
  if (theme.colors?.action?.focus) {
    cssVars[`--${prefix}-color-action-focus`] = theme.colors.action.focus;
  }
  if (theme.colors?.action?.focusOpacity !== void 0) {
    cssVars[`--${prefix}-color-action-focusOpacity`] = theme.colors.action.focusOpacity.toString();
  }
  if (theme.colors?.action?.activatedOpacity !== void 0) {
    cssVars[`--${prefix}-color-action-activatedOpacity`] = theme.colors.action.activatedOpacity.toString();
  }
  if (theme.colors?.primary?.main) {
    cssVars[`--${prefix}-color-primary-main`] = theme.colors.primary.main;
  }
  if (theme.colors?.primary?.contrastText) {
    cssVars[`--${prefix}-color-primary-contrastText`] = theme.colors.primary.contrastText;
  }
  if (theme.colors?.secondary?.main) {
    cssVars[`--${prefix}-color-secondary-main`] = theme.colors.secondary.main;
  }
  if (theme.colors?.secondary?.contrastText) {
    cssVars[`--${prefix}-color-secondary-contrastText`] = theme.colors.secondary.contrastText;
  }
  if (theme.colors?.background?.surface) {
    cssVars[`--${prefix}-color-background-surface`] = theme.colors.background.surface;
  }
  if (theme.colors?.background?.disabled) {
    cssVars[`--${prefix}-color-background-disabled`] = theme.colors.background.disabled;
  }
  if (theme.colors?.background?.body?.main) {
    cssVars[`--${prefix}-color-background-body-main`] = theme.colors.background.body.main;
  }
  if (theme.colors?.error?.main) {
    cssVars[`--${prefix}-color-error-main`] = theme.colors.error.main;
  }
  if (theme.colors?.error?.contrastText) {
    cssVars[`--${prefix}-color-error-contrastText`] = theme.colors.error.contrastText;
  }
  if (theme.colors?.success?.main) {
    cssVars[`--${prefix}-color-success-main`] = theme.colors.success.main;
  }
  if (theme.colors?.success?.contrastText) {
    cssVars[`--${prefix}-color-success-contrastText`] = theme.colors.success.contrastText;
  }
  if (theme.colors?.warning?.main) {
    cssVars[`--${prefix}-color-warning-main`] = theme.colors.warning.main;
  }
  if (theme.colors?.warning?.contrastText) {
    cssVars[`--${prefix}-color-warning-contrastText`] = theme.colors.warning.contrastText;
  }
  if (theme.colors?.text?.primary) {
    cssVars[`--${prefix}-color-text-primary`] = theme.colors.text.primary;
  }
  if (theme.colors?.text?.secondary) {
    cssVars[`--${prefix}-color-text-secondary`] = theme.colors.text.secondary;
  }
  if (theme.colors?.border) {
    cssVars[`--${prefix}-color-border`] = theme.colors.border;
  }
  if (theme.spacing?.unit !== void 0) {
    cssVars[`--${prefix}-spacing-unit`] = `${theme.spacing.unit}px`;
  }
  if (theme.borderRadius?.small) {
    cssVars[`--${prefix}-border-radius-small`] = theme.borderRadius.small;
  }
  if (theme.borderRadius?.medium) {
    cssVars[`--${prefix}-border-radius-medium`] = theme.borderRadius.medium;
  }
  if (theme.borderRadius?.large) {
    cssVars[`--${prefix}-border-radius-large`] = theme.borderRadius.large;
  }
  if (theme.shadows?.small) {
    cssVars[`--${prefix}-shadow-small`] = theme.shadows.small;
  }
  if (theme.shadows?.medium) {
    cssVars[`--${prefix}-shadow-medium`] = theme.shadows.medium;
  }
  if (theme.shadows?.large) {
    cssVars[`--${prefix}-shadow-large`] = theme.shadows.large;
  }
  if (theme.typography?.fontFamily) {
    cssVars[`--${prefix}-typography-fontFamily`] = theme.typography.fontFamily;
  }
  if (theme.typography?.fontSizes?.xs) {
    cssVars[`--${prefix}-typography-fontSize-xs`] = theme.typography.fontSizes.xs;
  }
  if (theme.typography?.fontSizes?.sm) {
    cssVars[`--${prefix}-typography-fontSize-sm`] = theme.typography.fontSizes.sm;
  }
  if (theme.typography?.fontSizes?.md) {
    cssVars[`--${prefix}-typography-fontSize-md`] = theme.typography.fontSizes.md;
  }
  if (theme.typography?.fontSizes?.lg) {
    cssVars[`--${prefix}-typography-fontSize-lg`] = theme.typography.fontSizes.lg;
  }
  if (theme.typography?.fontSizes?.xl) {
    cssVars[`--${prefix}-typography-fontSize-xl`] = theme.typography.fontSizes.xl;
  }
  if (theme.typography?.fontSizes?.["2xl"]) {
    cssVars[`--${prefix}-typography-fontSize-2xl`] = theme.typography.fontSizes["2xl"];
  }
  if (theme.typography?.fontSizes?.["3xl"]) {
    cssVars[`--${prefix}-typography-fontSize-3xl`] = theme.typography.fontSizes["3xl"];
  }
  if (theme.typography?.fontWeights?.normal !== void 0) {
    cssVars[`--${prefix}-typography-fontWeight-normal`] = theme.typography.fontWeights.normal.toString();
  }
  if (theme.typography?.fontWeights?.medium !== void 0) {
    cssVars[`--${prefix}-typography-fontWeight-medium`] = theme.typography.fontWeights.medium.toString();
  }
  if (theme.typography?.fontWeights?.semibold !== void 0) {
    cssVars[`--${prefix}-typography-fontWeight-semibold`] = theme.typography.fontWeights.semibold.toString();
  }
  if (theme.typography?.fontWeights?.bold !== void 0) {
    cssVars[`--${prefix}-typography-fontWeight-bold`] = theme.typography.fontWeights.bold.toString();
  }
  if (theme.typography?.lineHeights?.tight !== void 0) {
    cssVars[`--${prefix}-typography-lineHeight-tight`] = theme.typography.lineHeights.tight.toString();
  }
  if (theme.typography?.lineHeights?.normal !== void 0) {
    cssVars[`--${prefix}-typography-lineHeight-normal`] = theme.typography.lineHeights.normal.toString();
  }
  if (theme.typography?.lineHeights?.relaxed !== void 0) {
    cssVars[`--${prefix}-typography-lineHeight-relaxed`] = theme.typography.lineHeights.relaxed.toString();
  }
  if (theme.images) {
    Object.keys(theme.images).forEach((imageKey) => {
      const imageConfig = theme.images[imageKey];
      if (imageConfig?.url) {
        cssVars[`--${prefix}-image-${imageKey}-url`] = imageConfig.url;
      }
      if (imageConfig?.title) {
        cssVars[`--${prefix}-image-${imageKey}-title`] = imageConfig.title;
      }
      if (imageConfig?.alt) {
        cssVars[`--${prefix}-image-${imageKey}-alt`] = imageConfig.alt;
      }
    });
  }
  return cssVars;
};
var toThemeVars = (theme) => {
  const prefix = theme.cssVarPrefix || VendorConstants_default.VENDOR_PREFIX;
  const themeVars = {
    colors: {
      action: {
        active: `var(--${prefix}-color-action-active)`,
        hover: `var(--${prefix}-color-action-hover)`,
        hoverOpacity: `var(--${prefix}-color-action-hoverOpacity)`,
        selected: `var(--${prefix}-color-action-selected)`,
        selectedOpacity: `var(--${prefix}-color-action-selectedOpacity)`,
        disabled: `var(--${prefix}-color-action-disabled)`,
        disabledBackground: `var(--${prefix}-color-action-disabledBackground)`,
        disabledOpacity: `var(--${prefix}-color-action-disabledOpacity)`,
        focus: `var(--${prefix}-color-action-focus)`,
        focusOpacity: `var(--${prefix}-color-action-focusOpacity)`,
        activatedOpacity: `var(--${prefix}-color-action-activatedOpacity)`
      },
      primary: {
        main: `var(--${prefix}-color-primary-main)`,
        contrastText: `var(--${prefix}-color-primary-contrastText)`
      },
      secondary: {
        main: `var(--${prefix}-color-secondary-main)`,
        contrastText: `var(--${prefix}-color-secondary-contrastText)`
      },
      background: {
        surface: `var(--${prefix}-color-background-surface)`,
        disabled: `var(--${prefix}-color-background-disabled)`,
        body: {
          main: `var(--${prefix}-color-background-body-main)`
        }
      },
      error: {
        main: `var(--${prefix}-color-error-main)`,
        contrastText: `var(--${prefix}-color-error-contrastText)`
      },
      success: {
        main: `var(--${prefix}-color-success-main)`,
        contrastText: `var(--${prefix}-color-success-contrastText)`
      },
      warning: {
        main: `var(--${prefix}-color-warning-main)`,
        contrastText: `var(--${prefix}-color-warning-contrastText)`
      },
      text: {
        primary: `var(--${prefix}-color-text-primary)`,
        secondary: `var(--${prefix}-color-text-secondary)`
      },
      border: `var(--${prefix}-color-border)`
    },
    spacing: {
      unit: `var(--${prefix}-spacing-unit)`
    },
    borderRadius: {
      small: `var(--${prefix}-border-radius-small)`,
      medium: `var(--${prefix}-border-radius-medium)`,
      large: `var(--${prefix}-border-radius-large)`
    },
    shadows: {
      small: `var(--${prefix}-shadow-small)`,
      medium: `var(--${prefix}-shadow-medium)`,
      large: `var(--${prefix}-shadow-large)`
    },
    typography: {
      fontFamily: `var(--${prefix}-typography-fontFamily)`,
      fontSizes: {
        xs: `var(--${prefix}-typography-fontSize-xs)`,
        sm: `var(--${prefix}-typography-fontSize-sm)`,
        md: `var(--${prefix}-typography-fontSize-md)`,
        lg: `var(--${prefix}-typography-fontSize-lg)`,
        xl: `var(--${prefix}-typography-fontSize-xl)`,
        "2xl": `var(--${prefix}-typography-fontSize-2xl)`,
        "3xl": `var(--${prefix}-typography-fontSize-3xl)`
      },
      fontWeights: {
        normal: `var(--${prefix}-typography-fontWeight-normal)`,
        medium: `var(--${prefix}-typography-fontWeight-medium)`,
        semibold: `var(--${prefix}-typography-fontWeight-semibold)`,
        bold: `var(--${prefix}-typography-fontWeight-bold)`
      },
      lineHeights: {
        tight: `var(--${prefix}-typography-lineHeight-tight)`,
        normal: `var(--${prefix}-typography-lineHeight-normal)`,
        relaxed: `var(--${prefix}-typography-lineHeight-relaxed)`
      }
    }
  };
  if (theme.images) {
    themeVars.images = {};
    Object.keys(theme.images).forEach((imageKey) => {
      const imageConfig = theme.images[imageKey];
      themeVars.images[imageKey] = {
        url: imageConfig?.url ? `var(--${prefix}-image-${imageKey}-url)` : void 0,
        title: imageConfig?.title ? `var(--${prefix}-image-${imageKey}-title)` : void 0,
        alt: imageConfig?.alt ? `var(--${prefix}-image-${imageKey}-alt)` : void 0
      };
    });
  }
  return themeVars;
};
var createTheme = (config = {}, isDark = false) => {
  const baseTheme = isDark ? darkTheme : lightTheme;
  const mergedConfig = {
    ...baseTheme,
    ...config,
    colors: {
      ...baseTheme.colors,
      ...config.colors,
      action: {
        ...baseTheme.colors.action,
        ...config.colors?.action || {}
      },
      secondary: {
        ...baseTheme.colors.secondary,
        ...config.colors?.secondary || {}
      }
    },
    spacing: {
      ...baseTheme.spacing,
      ...config.spacing
    },
    borderRadius: {
      ...baseTheme.borderRadius,
      ...config.borderRadius
    },
    shadows: {
      ...baseTheme.shadows,
      ...config.shadows
    },
    typography: {
      ...baseTheme.typography,
      ...config.typography,
      fontSizes: {
        ...baseTheme.typography.fontSizes,
        ...config.typography?.fontSizes || {}
      },
      fontWeights: {
        ...baseTheme.typography.fontWeights,
        ...config.typography?.fontWeights || {}
      },
      lineHeights: {
        ...baseTheme.typography.lineHeights,
        ...config.typography?.lineHeights || {}
      }
    },
    images: {
      ...baseTheme.images,
      ...config.images
    }
  };
  return {
    ...mergedConfig,
    cssVariables: toCssVariables(mergedConfig),
    vars: toThemeVars(mergedConfig)
  };
};
var createTheme_default = createTheme;

// src/utils/deepMerge.ts
var isPlainObject = (value) => {
  return typeof value === "object" && value !== null && !Array.isArray(value) && !(value instanceof Date) && !(value instanceof RegExp) && Object.prototype.toString.call(value) === "[object Object]";
};
var deepMerge = (target, ...sources) => {
  if (!target || typeof target !== "object") {
    throw new Error("Target must be an object");
  }
  const result = { ...target };
  sources.forEach((source) => {
    if (!source || typeof source !== "object") {
      return;
    }
    Object.keys(source).forEach((key) => {
      const sourceValue = source[key];
      const targetValue = result[key];
      if (isPlainObject(sourceValue) && isPlainObject(targetValue)) {
        result[key] = deepMerge(targetValue, sourceValue);
      } else if (sourceValue !== void 0) {
        result[key] = sourceValue;
      }
    });
  });
  return result;
};
var deepMerge_default = deepMerge;

// src/utils/deriveOrganizationHandleFromBaseUrl.ts
var deriveOrganizationHandleFromBaseUrl = (baseUrl) => {
  if (!baseUrl) {
    throw new AsgardeoRuntimeError(
      "Base URL is required to derive organization handle.",
      "javascript-deriveOrganizationHandleFromBaseUrl-ValidationError-001",
      "javascript",
      "A valid base URL must be provided to extract the organization handle."
    );
  }
  let parsedUrl;
  try {
    parsedUrl = new URL(baseUrl);
  } catch (error) {
    throw new AsgardeoRuntimeError(
      `Invalid base URL format: ${baseUrl}`,
      "javascript-deriveOrganizationHandleFromBaseUrl-ValidationError-002",
      "javascript",
      "The provided base URL does not conform to valid URL syntax."
    );
  }
  const hostname = parsedUrl.hostname.toLowerCase();
  if (!hostname.endsWith(".asgardeo.io")) {
    throw new AsgardeoRuntimeError(
      "Organization handle is required since a custom domain is configured.",
      "javascript-deriveOrganizationHandleFromBaseUrl-CustomDomainError-001",
      "javascript",
      "The provided base URL uses a custom domain. Please provide the organizationHandle explicitly in the configuration."
    );
  }
  const pathSegments = parsedUrl.pathname.split("/").filter((segment) => segment.length > 0);
  if (pathSegments.length < 2 || pathSegments[0] !== "t") {
    throw new AsgardeoRuntimeError(
      "Organization handle is required since a custom domain is configured.",
      "javascript-deriveOrganizationHandleFromBaseUrl-CustomDomainError-002",
      "javascript",
      "The provided base URL does not follow the expected Asgardeo URL pattern (/t/{orgHandle}). Please provide the organizationHandle explicitly in the configuration."
    );
  }
  const organizationHandle = pathSegments[1];
  if (!organizationHandle || organizationHandle.trim().length === 0) {
    throw new AsgardeoRuntimeError(
      "Organization handle is required since a custom domain is configured.",
      "javascript-deriveOrganizationHandleFromBaseUrl-CustomDomainError-003",
      "javascript",
      "The organization handle could not be extracted from the base URL. Please provide the organizationHandle explicitly in the configuration."
    );
  }
  return organizationHandle;
};
var deriveOrganizationHandleFromBaseUrl_default = deriveOrganizationHandleFromBaseUrl;

// src/utils/flattenUserSchema.ts
var flattenUserSchema = (schemas) => {
  const flattenedAttributes = [];
  schemas.forEach((schema) => {
    if (schema.attributes && Array.isArray(schema.attributes)) {
      schema.attributes.forEach((attribute) => {
        if (attribute.subAttributes && Array.isArray(attribute.subAttributes)) {
          attribute.subAttributes.forEach((subAttribute) => {
            flattenedAttributes.push({
              ...subAttribute,
              name: `${attribute.name}.${subAttribute.name}`,
              schemaId: schema.id
            });
          });
        } else {
          flattenedAttributes.push({
            ...attribute,
            schemaId: schema.id
          });
        }
      });
    }
  });
  return flattenedAttributes;
};
var flattenUserSchema_default = flattenUserSchema;

// src/utils/get.ts
var get = (object, path, defaultValue) => {
  if (!object || !path) return defaultValue;
  const pathArray = Array.isArray(path) ? path : path.split(".");
  const result = pathArray.reduce((current, key) => {
    return current?.[key];
  }, object);
  return result !== void 0 ? result : defaultValue;
};
var get_default = get;

// src/utils/set.ts
var set = (object, path, value) => {
  if (!object || !path) return object;
  const pathArray = Array.isArray(path) ? path : path.split(".");
  const lastIndex = pathArray.length - 1;
  pathArray.reduce((current, key, index) => {
    if (index === lastIndex) {
      current[key] = value;
    } else {
      if (!(key in current) || typeof current[key] !== "object" || current[key] === null) {
        const nextKey = pathArray[index + 1];
        current[key] = /^\d+$/.test(nextKey) ? [] : {};
      }
    }
    return current[key];
  }, object);
  return object;
};
var set_default = set;

// src/utils/generateUserProfile.ts
var generateUserProfile = (meResponse, processedSchemas) => {
  const profile = {};
  processedSchemas.forEach((schema) => {
    const { name, type, multiValued } = schema;
    if (!name) return;
    let value = get_default(meResponse, name);
    if (value !== void 0) {
      if (multiValued && !Array.isArray(value)) {
        value = [value];
      }
    } else {
      if (multiValued) {
        value = void 0;
      } else if (type === "STRING") {
        value = "";
      } else {
        value = void 0;
      }
    }
    set_default(profile, name, value);
  });
  return profile;
};
var generateUserProfile_default = generateUserProfile;

// src/utils/getLatestStateParam.ts
var getLatestPkceStorageKey = (tempStore) => {
  const keys = [];
  Object.keys(tempStore).forEach((key) => {
    if (key.startsWith(PKCEConstants_default.Storage.StorageKeys.CODE_VERIFIER)) {
      keys.push(key);
    }
  });
  const lastKey = keys.sort().pop();
  return lastKey ?? null;
};
var getLatestStateParam = (tempStore, state) => {
  const latestPkceKey = getLatestPkceStorageKey(tempStore);
  if (!latestPkceKey) {
    return null;
  }
  return generateStateParamForRequestCorrelation_default(latestPkceKey, state);
};
var getLatestStateParam_default = getLatestStateParam;

// src/utils/generateFlattenedUserProfile.ts
var generateFlattenedUserProfile = (meResponse, processedSchemas) => {
  const profile = {};
  const allSchemaNames = processedSchemas.map((schema) => schema.name).filter(Boolean);
  processedSchemas.forEach((schema) => {
    const { name, type, multiValued } = schema;
    if (!name) return;
    const hasChildProperties = allSchemaNames.some(
      (schemaName) => schemaName !== name && schemaName.startsWith(`${name}.`)
    );
    if (hasChildProperties) {
      return;
    }
    let value = get_default(meResponse, name);
    if (value === void 0) {
      const schemaNamespaces = [
        "urn:ietf:params:scim:schemas:core:2.0:User",
        "urn:ietf:params:scim:schemas:extension:enterprise:2.0:User",
        "urn:scim:wso2:schema",
        "urn:scim:schemas:extension:custom:User"
      ];
      schemaNamespaces.some((namespace) => {
        if (meResponse[namespace]) {
          if (meResponse[namespace][name] !== void 0) {
            value = meResponse[namespace][name];
            return true;
          }
          const nestedValue = get_default(meResponse[namespace], name);
          if (nestedValue !== void 0) {
            value = nestedValue;
            return true;
          }
        }
        return false;
      });
    }
    if (value !== void 0) {
      if (multiValued && !Array.isArray(value)) {
        value = [value];
      }
    } else if (multiValued) {
      value = void 0;
    } else if (type === "STRING") {
      value = "";
    } else {
      value = void 0;
    }
    profile[name] = value;
  });
  const flattenObject = (obj, prefix = "") => {
    if (obj && typeof obj === "object" && !Array.isArray(obj)) {
      Object.keys(obj).forEach((key) => {
        const fullKey = prefix ? `${prefix}.${key}` : key;
        const value = obj[key];
        if (Object.prototype.hasOwnProperty.call(profile, fullKey)) {
          return;
        }
        const hasSchemaChildProperties = allSchemaNames.some(
          (schemaName) => schemaName.startsWith(`${fullKey}.`)
        );
        if (hasSchemaChildProperties) {
          flattenObject(value, fullKey);
        } else {
          profile[fullKey] = value;
        }
      });
    }
  };
  flattenObject(meResponse);
  return profile;
};
var generateFlattenedUserProfile_default = generateFlattenedUserProfile;

// src/i18n/index.ts
var i18n_exports = {};
__export(i18n_exports, {
  en_US: () => en_US_default
});

// src/i18n/en-US.ts
var translations = {
  /* |---------------------------------------------------------------| */
  /* |                        Elements                               | */
  /* |---------------------------------------------------------------| */
  //* Buttons */
  "elements.buttons.signIn": "Sign In",
  "elements.buttons.signOut": "Sign Out",
  "elements.buttons.signUp": "Sign Up",
  "elements.buttons.facebook": "Continue with Facebook",
  "elements.buttons.google": "Continue with Google",
  "elements.buttons.github": "Continue with GitHub",
  "elements.buttons.microsoft": "Continue with Microsoft",
  "elements.buttons.linkedin": "Continue with LinkedIn",
  "elements.buttons.ethereum": "Continue with Sign In Ethereum",
  "elements.buttons.multi.option": "Continue with {connection}",
  "elements.buttons.social": "Continue with {connection}",
  /* Fields */
  "elements.fields.placeholder": "Enter your {field}",
  /* |---------------------------------------------------------------| */
  /* |                        Widgets                                | */
  /* |---------------------------------------------------------------| */
  /* Base Sign In */
  "signin.title": "Sign In",
  "signin.subtitle": "Enter your credentials to continue.",
  /* Base Sign Up */
  "signup.title": "Sign Up",
  "signup.subtitle": "Create a new account to get started.",
  /* Email OTP */
  "email.otp.title": "OTP Verification",
  "email.otp.subtitle": "Enter the code sent to your email address.",
  "email.otp.submit.button": "Continue",
  /* Identifier First */
  "identifier.first.title": "Sign In",
  "identifier.first.subtitle": "Enter your username or email address.",
  "identifier.first.submit.button": "Continue",
  /* SMS OTP */
  "sms.otp.title": "OTP Verification",
  "sms.otp.subtitle": "Enter the code sent to your phone number.",
  "sms.otp.submit.button": "Continue",
  /* TOTP */
  "totp.title": "Verify Your Identity",
  "totp.subtitle": "Enter the code from your authenticator app.",
  "totp.submit.button": "Continue",
  /* Username Password */
  "username.password.submit.button": "Continue",
  "username.password.title": "Sign In",
  "username.password.subtitle": "Enter your username and password to continue.",
  /* |---------------------------------------------------------------| */
  /* |                     Organization Switcher                     | */
  /* |---------------------------------------------------------------| */
  "organization.switcher.select.organization": "Select Organization",
  "organization.switcher.switch.organization": "Switch Organization",
  "organization.switcher.loading.organizations": "Loading organizations...",
  "organization.switcher.members": "members",
  "organization.switcher.member": "member",
  "organization.switcher.create.organization": "Create Organization",
  "organization.switcher.manage.organizations": "Manage Organizations",
  "organization.switcher.manage.button": "Manage",
  "organization.switcher.organizations.title": "Organizations",
  "organization.switcher.switch.button": "Switch",
  "organization.switcher.no.access": "No Access",
  "organization.switcher.status.label": "Status:",
  "organization.switcher.showing.count": "Showing {showing} of {total} organizations",
  "organization.switcher.refresh.button": "Refresh",
  "organization.switcher.load.more": "Load More Organizations",
  "organization.switcher.loading.more": "Loading...",
  "organization.switcher.no.organizations": "No organizations found",
  "organization.switcher.error.prefix": "Error:",
  "organization.profile.title": "Organization Profile",
  "organization.profile.loading": "Loading organization...",
  "organization.profile.error": "Failed to load organization",
  "organization.create.title": "Create Organization",
  "organization.create.name.label": "Organization Name",
  "organization.create.name.placeholder": "Enter organization name",
  "organization.create.handle.label": "Organization Handle",
  "organization.create.handle.placeholder": "my-organization",
  "organization.create.description.label": "Description",
  "organization.create.description.placeholder": "Enter organization description",
  "organization.create.button": "Create Organization",
  "organization.create.creating": "Creating...",
  "organization.create.cancel": "Cancel",
  /* |---------------------------------------------------------------| */
  /* |                        Messages                               | */
  /* |---------------------------------------------------------------| */
  "messages.loading": "Loading...",
  /* |---------------------------------------------------------------| */
  /* |                        Errors                                 | */
  /* |---------------------------------------------------------------| */
  "errors.title": "Error",
  "errors.sign.in.initialization": "An error occurred while initializing. Please try again later.",
  "errors.sign.in.flow.failure": "An error occurred during the sign-in flow. Please try again later.",
  "errors.sign.in.flow.completion.failure": "An error occurred while completing the sign-in flow. Please try again later.",
  "errors.sign.in.flow.passkeys.failure": "An error occurred while signing in with passkeys. Please try again later.",
  "errors.sign.in.flow.passkeys.completion.failure": "An error occurred while completing the passkeys sign-in flow. Please try again later."
};
var metadata = {
  localeCode: "en-US",
  countryCode: "US",
  languageCode: "en",
  displayName: "English (United States)",
  direction: "ltr"
};
var en_US = {
  metadata,
  translations
};
var en_US_default = en_US;

// src/utils/getI18nBundles.ts
var getI18nBundles = () => {
  return i18n_exports;
};
var getI18nBundles_default = getI18nBundles;

// src/utils/removeTrailingSlash.ts
var removeTrailingSlash = (path) => path.endsWith("/") ? path.slice(0, -1) : path;
var removeTrailingSlash_default = removeTrailingSlash;

// src/utils/resolveFieldType.ts
var resolveFieldType = (field) => {
  if (field.type === "STRING" /* String */) {
    if (field.param === "OTPCode" /* Otp */) {
      return "OTP" /* Otp */;
    } else if (field?.confidential) {
      return "PASSWORD" /* Password */;
    }
    return "TEXT" /* Text */;
  }
  throw new AsgardeoRuntimeError(
    "Field type is not supported: " + field.type,
    "resolveFieldType-Invalid-001",
    "javascript",
    "The provided field type is not supported. Please check the field configuration."
  );
};
var resolveFieldType_default = resolveFieldType;

// src/utils/resolveFieldName.ts
var resolveFieldName = (field) => {
  if (field.param) {
    return field.param;
  }
  throw new AsgardeoRuntimeError(
    "Field name is not supported: ",
    "resolveFieldName-Invalid-001",
    "javascript",
    "The provided field name is not supported. Please check the field configuration."
  );
};
var resolveFieldName_default = resolveFieldName;

// src/utils/withVendorCSSClassPrefix.ts
var withVendorCSSClassPrefix = (className) => `${VendorConstants_default.VENDOR_PREFIX}-${className}`;
var withVendorCSSClassPrefix_default = withVendorCSSClassPrefix;

// src/utils/transformBrandingPreferenceToTheme.ts
var extractColorValue = (colorVariant) => {
  return colorVariant?.main;
};
var extractContrastText = (colorVariant) => {
  return colorVariant?.contrastText;
};
var transformThemeVariant = (themeVariant, isDark = false) => {
  const colors = themeVariant.colors;
  const buttons = themeVariant.buttons;
  const inputs = themeVariant.inputs;
  const images = themeVariant.images;
  return {
    colors: {
      action: {
        active: isDark ? "rgba(255, 255, 255, 0.70)" : "rgba(0, 0, 0, 0.54)",
        hover: isDark ? "rgba(255, 255, 255, 0.04)" : "rgba(0, 0, 0, 0.04)",
        hoverOpacity: 0.04,
        selected: isDark ? "rgba(255, 255, 255, 0.08)" : "rgba(0, 0, 0, 0.08)",
        selectedOpacity: 0.08,
        disabled: isDark ? "rgba(255, 255, 255, 0.26)" : "rgba(0, 0, 0, 0.26)",
        disabledBackground: isDark ? "rgba(255, 255, 255, 0.12)" : "rgba(0, 0, 0, 0.12)",
        disabledOpacity: 0.38,
        focus: isDark ? "rgba(255, 255, 255, 0.12)" : "rgba(0, 0, 0, 0.12)",
        focusOpacity: 0.12,
        activatedOpacity: 0.12
      },
      primary: {
        main: extractColorValue(colors?.primary),
        contrastText: extractContrastText(colors?.primary)
      },
      secondary: {
        main: extractColorValue(colors?.secondary),
        contrastText: extractContrastText(colors?.secondary)
      },
      background: {
        surface: extractColorValue(colors?.background?.surface),
        disabled: extractColorValue(colors?.background?.surface),
        body: {
          main: extractColorValue(colors?.background?.body)
        }
      },
      text: {
        primary: colors?.text?.primary,
        secondary: colors?.text?.secondary
      },
      border: colors?.outlined?.default,
      error: {
        main: extractColorValue(colors?.alerts?.error),
        contrastText: extractContrastText(colors?.alerts?.error)
      },
      success: {
        main: extractColorValue(colors?.alerts?.info),
        contrastText: extractContrastText(colors?.alerts?.info)
      },
      warning: {
        main: extractColorValue(colors?.alerts?.warning),
        contrastText: extractContrastText(colors?.alerts?.warning)
      }
    },
    // Extract border radius from buttons or inputs
    borderRadius: {
      small: buttons?.primary?.base?.border?.borderRadius || inputs?.base?.border?.borderRadius,
      medium: buttons?.secondary?.base?.border?.borderRadius,
      large: buttons?.externalConnection?.base?.border?.borderRadius
    },
    // Extract and transform images
    images: {
      favicon: images?.favicon ? {
        url: images.favicon.imgURL,
        title: images.favicon.title,
        alt: images.favicon.altText
      } : void 0,
      logo: images?.logo ? {
        url: images.logo.imgURL,
        title: images.logo.title,
        alt: images.logo.altText
      } : void 0
    }
  };
};
var transformBrandingPreferenceToTheme = (brandingPreference, forceTheme) => {
  const themeConfig = brandingPreference?.preference?.theme;
  if (!themeConfig) {
    return createTheme_default({}, false);
  }
  let activeThemeKey;
  if (forceTheme) {
    activeThemeKey = forceTheme.toUpperCase();
  } else {
    activeThemeKey = themeConfig.activeTheme || "LIGHT";
  }
  const themeVariant = themeConfig[activeThemeKey];
  if (!themeVariant) {
    const fallbackVariant = themeConfig.LIGHT || themeConfig.DARK;
    if (fallbackVariant) {
      const transformedConfig2 = transformThemeVariant(fallbackVariant, activeThemeKey === "DARK");
      return createTheme_default(transformedConfig2, activeThemeKey === "DARK");
    }
    return createTheme_default({}, activeThemeKey === "DARK");
  }
  const transformedConfig = transformThemeVariant(themeVariant, activeThemeKey === "DARK");
  return createTheme_default(transformedConfig, activeThemeKey === "DARK");
};
var transformBrandingPreferenceToTheme_default = transformBrandingPreferenceToTheme;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ApplicationNativeAuthenticationConstants,
  AsgardeoAPIError,
  AsgardeoAuthClient,
  AsgardeoAuthException,
  AsgardeoError,
  AsgardeoJavaScriptClient,
  AsgardeoRuntimeError,
  EmbeddedFlowComponentType,
  EmbeddedFlowResponseType,
  EmbeddedFlowStatus,
  EmbeddedFlowType,
  EmbeddedSignInFlowAuthenticatorKnownIdPType,
  EmbeddedSignInFlowAuthenticatorParamType,
  EmbeddedSignInFlowAuthenticatorPromptType,
  EmbeddedSignInFlowStatus,
  EmbeddedSignInFlowStepType,
  EmbeddedSignInFlowType,
  FieldType,
  FlowMode,
  IsomorphicCrypto,
  OIDCRequestConstants,
  StorageManager,
  TokenConstants,
  VendorConstants,
  WellKnownSchemaIds,
  createOrganization,
  createPatchOperations,
  createTheme,
  deepMerge,
  deriveOrganizationHandleFromBaseUrl,
  executeEmbeddedSignInFlow,
  executeEmbeddedSignUpFlow,
  extractPkceStorageKeyFromState,
  extractUserClaimsFromIdToken,
  flattenUserSchema,
  generateFlattenedUserProfile,
  generateUserProfile,
  get,
  getAllOrganizations,
  getBrandingPreference,
  getI18nBundles,
  getLatestStateParam,
  getMeOrganizations,
  getOrganization,
  getSchemas,
  getScim2Me,
  getUserInfo,
  initializeEmbeddedSignInFlow,
  isEmpty,
  processOpenIDScopes,
  processUsername,
  removeTrailingSlash,
  resolveFieldName,
  resolveFieldType,
  set,
  transformBrandingPreferenceToTheme,
  updateMeProfile,
  updateOrganization,
  withVendorCSSClassPrefix
});
//# sourceMappingURL=index.js.map
