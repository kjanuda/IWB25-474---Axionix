
      import { Buffer } from 'buffer/';
      if (typeof window !== 'undefined' && !window.Buffer) {
        window.Buffer = Buffer;
      }
    
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __reExport = (target, mod, secondTarget) => (__copyProps(target, mod, "default"), secondTarget && __copyProps(secondTarget, mod, "default"));
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i = decorators.length - 1, decorator; i >= 0; i--)
    if (decorator = decorators[i])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result) __defProp(target, key, result);
  return result;
};
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// ../../node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "../../node_modules/.pnpm/base64-js@1.5.1/node_modules/base64-js/index.js"(exports) {
    "use strict";
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// ../../node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js
var require_ieee754 = __commonJS({
  "../../node_modules/.pnpm/ieee754@1.2.1/node_modules/ieee754/index.js"(exports) {
    exports.read = function(buffer, offset, isLE, mLen, nBytes) {
      var e, m;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var nBits = -7;
      var i = isLE ? nBytes - 1 : 0;
      var d = isLE ? -1 : 1;
      var s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
      }
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : (s ? -1 : 1) * Infinity;
      } else {
        m = m + Math.pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
    };
    exports.write = function(buffer, value, offset, isLE, mLen, nBytes) {
      var e, m, c;
      var eLen = nBytes * 8 - mLen - 1;
      var eMax = (1 << eLen) - 1;
      var eBias = eMax >> 1;
      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
      var i = isLE ? 0 : nBytes - 1;
      var d = isLE ? 1 : -1;
      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value = Math.abs(value);
      if (isNaN(value) || value === Infinity) {
        m = isNaN(value) ? 1 : 0;
        e = eMax;
      } else {
        e = Math.floor(Math.log(value) / Math.LN2);
        if (value * (c = Math.pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * Math.pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * Math.pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
      }
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
      }
      buffer[offset + i - d] |= s * 128;
    };
  }
});

// ../../node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js
var require_buffer = __commonJS({
  "../../node_modules/.pnpm/buffer@6.0.3/node_modules/buffer/index.js"(exports) {
    "use strict";
    var base64 = require_base64_js();
    var ieee754 = require_ieee754();
    var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
    exports.Buffer = Buffer3;
    exports.SlowBuffer = SlowBuffer;
    exports.INSPECT_MAX_BYTES = 50;
    var K_MAX_LENGTH = 2147483647;
    exports.kMaxLength = K_MAX_LENGTH;
    Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();
    if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
      console.error(
        "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
      );
    }
    function typedArraySupport() {
      try {
        const arr = new Uint8Array(1);
        const proto = { foo: function() {
          return 42;
        } };
        Object.setPrototypeOf(proto, Uint8Array.prototype);
        Object.setPrototypeOf(arr, proto);
        return arr.foo() === 42;
      } catch (e) {
        return false;
      }
    }
    Object.defineProperty(Buffer3.prototype, "parent", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this)) return void 0;
        return this.buffer;
      }
    });
    Object.defineProperty(Buffer3.prototype, "offset", {
      enumerable: true,
      get: function() {
        if (!Buffer3.isBuffer(this)) return void 0;
        return this.byteOffset;
      }
    });
    function createBuffer(length) {
      if (length > K_MAX_LENGTH) {
        throw new RangeError('The value "' + length + '" is invalid for option "size"');
      }
      const buf = new Uint8Array(length);
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function Buffer3(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        if (typeof encodingOrOffset === "string") {
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        }
        return allocUnsafe(arg);
      }
      return from(arg, encodingOrOffset, length);
    }
    Buffer3.poolSize = 8192;
    function from(value, encodingOrOffset, length) {
      if (typeof value === "string") {
        return fromString(value, encodingOrOffset);
      }
      if (ArrayBuffer.isView(value)) {
        return fromArrayView(value);
      }
      if (value == null) {
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
        );
      }
      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
        return fromArrayBuffer(value, encodingOrOffset, length);
      }
      if (typeof value === "number") {
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      }
      const valueOf = value.valueOf && value.valueOf();
      if (valueOf != null && valueOf !== value) {
        return Buffer3.from(valueOf, encodingOrOffset, length);
      }
      const b = fromObject(value);
      if (b) return b;
      if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
        return Buffer3.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
      }
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value
      );
    }
    Buffer3.from = function(value, encodingOrOffset, length) {
      return from(value, encodingOrOffset, length);
    };
    Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);
    Object.setPrototypeOf(Buffer3, Uint8Array);
    function assertSize(size) {
      if (typeof size !== "number") {
        throw new TypeError('"size" argument must be of type number');
      } else if (size < 0) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
    }
    function alloc(size, fill, encoding) {
      assertSize(size);
      if (size <= 0) {
        return createBuffer(size);
      }
      if (fill !== void 0) {
        return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
      }
      return createBuffer(size);
    }
    Buffer3.alloc = function(size, fill, encoding) {
      return alloc(size, fill, encoding);
    };
    function allocUnsafe(size) {
      assertSize(size);
      return createBuffer(size < 0 ? 0 : checked(size) | 0);
    }
    Buffer3.allocUnsafe = function(size) {
      return allocUnsafe(size);
    };
    Buffer3.allocUnsafeSlow = function(size) {
      return allocUnsafe(size);
    };
    function fromString(string, encoding) {
      if (typeof encoding !== "string" || encoding === "") {
        encoding = "utf8";
      }
      if (!Buffer3.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      const length = byteLength(string, encoding) | 0;
      let buf = createBuffer(length);
      const actual = buf.write(string, encoding);
      if (actual !== length) {
        buf = buf.slice(0, actual);
      }
      return buf;
    }
    function fromArrayLike(array) {
      const length = array.length < 0 ? 0 : checked(array.length) | 0;
      const buf = createBuffer(length);
      for (let i = 0; i < length; i += 1) {
        buf[i] = array[i] & 255;
      }
      return buf;
    }
    function fromArrayView(arrayView) {
      if (isInstance(arrayView, Uint8Array)) {
        const copy = new Uint8Array(arrayView);
        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
      }
      return fromArrayLike(arrayView);
    }
    function fromArrayBuffer(array, byteOffset, length) {
      if (byteOffset < 0 || array.byteLength < byteOffset) {
        throw new RangeError('"offset" is outside of buffer bounds');
      }
      if (array.byteLength < byteOffset + (length || 0)) {
        throw new RangeError('"length" is outside of buffer bounds');
      }
      let buf;
      if (byteOffset === void 0 && length === void 0) {
        buf = new Uint8Array(array);
      } else if (length === void 0) {
        buf = new Uint8Array(array, byteOffset);
      } else {
        buf = new Uint8Array(array, byteOffset, length);
      }
      Object.setPrototypeOf(buf, Buffer3.prototype);
      return buf;
    }
    function fromObject(obj) {
      if (Buffer3.isBuffer(obj)) {
        const len = checked(obj.length) | 0;
        const buf = createBuffer(len);
        if (buf.length === 0) {
          return buf;
        }
        obj.copy(buf, 0, 0, len);
        return buf;
      }
      if (obj.length !== void 0) {
        if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
          return createBuffer(0);
        }
        return fromArrayLike(obj);
      }
      if (obj.type === "Buffer" && Array.isArray(obj.data)) {
        return fromArrayLike(obj.data);
      }
    }
    function checked(length) {
      if (length >= K_MAX_LENGTH) {
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
      }
      return length | 0;
    }
    function SlowBuffer(length) {
      if (+length != length) {
        length = 0;
      }
      return Buffer3.alloc(+length);
    }
    Buffer3.isBuffer = function isBuffer(b) {
      return b != null && b._isBuffer === true && b !== Buffer3.prototype;
    };
    Buffer3.compare = function compare(a, b) {
      if (isInstance(a, Uint8Array)) a = Buffer3.from(a, a.offset, a.byteLength);
      if (isInstance(b, Uint8Array)) b = Buffer3.from(b, b.offset, b.byteLength);
      if (!Buffer3.isBuffer(a) || !Buffer3.isBuffer(b)) {
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      }
      if (a === b) return 0;
      let x = a.length;
      let y = b.length;
      for (let i = 0, len = Math.min(x, y); i < len; ++i) {
        if (a[i] !== b[i]) {
          x = a[i];
          y = b[i];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };
    Buffer3.isEncoding = function isEncoding(encoding) {
      switch (String(encoding).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return true;
        default:
          return false;
      }
    };
    Buffer3.concat = function concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }
      if (list.length === 0) {
        return Buffer3.alloc(0);
      }
      let i;
      if (length === void 0) {
        length = 0;
        for (i = 0; i < list.length; ++i) {
          length += list[i].length;
        }
      }
      const buffer = Buffer3.allocUnsafe(length);
      let pos = 0;
      for (i = 0; i < list.length; ++i) {
        let buf = list[i];
        if (isInstance(buf, Uint8Array)) {
          if (pos + buf.length > buffer.length) {
            if (!Buffer3.isBuffer(buf)) buf = Buffer3.from(buf);
            buf.copy(buffer, pos);
          } else {
            Uint8Array.prototype.set.call(
              buffer,
              buf,
              pos
            );
          }
        } else if (!Buffer3.isBuffer(buf)) {
          throw new TypeError('"list" argument must be an Array of Buffers');
        } else {
          buf.copy(buffer, pos);
        }
        pos += buf.length;
      }
      return buffer;
    };
    function byteLength(string, encoding) {
      if (Buffer3.isBuffer(string)) {
        return string.length;
      }
      if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
        return string.byteLength;
      }
      if (typeof string !== "string") {
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string
        );
      }
      const len = string.length;
      const mustMatch = arguments.length > 2 && arguments[2] === true;
      if (!mustMatch && len === 0) return 0;
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "ascii":
          case "latin1":
          case "binary":
            return len;
          case "utf8":
          case "utf-8":
            return utf8ToBytes(string).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return len * 2;
          case "hex":
            return len >>> 1;
          case "base64":
            return base64ToBytes(string).length;
          default:
            if (loweredCase) {
              return mustMatch ? -1 : utf8ToBytes(string).length;
            }
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.byteLength = byteLength;
    function slowToString(encoding, start, end) {
      let loweredCase = false;
      if (start === void 0 || start < 0) {
        start = 0;
      }
      if (start > this.length) {
        return "";
      }
      if (end === void 0 || end > this.length) {
        end = this.length;
      }
      if (end <= 0) {
        return "";
      }
      end >>>= 0;
      start >>>= 0;
      if (end <= start) {
        return "";
      }
      if (!encoding) encoding = "utf8";
      while (true) {
        switch (encoding) {
          case "hex":
            return hexSlice(this, start, end);
          case "utf8":
          case "utf-8":
            return utf8Slice(this, start, end);
          case "ascii":
            return asciiSlice(this, start, end);
          case "latin1":
          case "binary":
            return latin1Slice(this, start, end);
          case "base64":
            return base64Slice(this, start, end);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return utf16leSlice(this, start, end);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = (encoding + "").toLowerCase();
            loweredCase = true;
        }
      }
    }
    Buffer3.prototype._isBuffer = true;
    function swap(b, n, m) {
      const i = b[n];
      b[n] = b[m];
      b[m] = i;
    }
    Buffer3.prototype.swap16 = function swap16() {
      const len = this.length;
      if (len % 2 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      }
      for (let i = 0; i < len; i += 2) {
        swap(this, i, i + 1);
      }
      return this;
    };
    Buffer3.prototype.swap32 = function swap32() {
      const len = this.length;
      if (len % 4 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      }
      for (let i = 0; i < len; i += 4) {
        swap(this, i, i + 3);
        swap(this, i + 1, i + 2);
      }
      return this;
    };
    Buffer3.prototype.swap64 = function swap64() {
      const len = this.length;
      if (len % 8 !== 0) {
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      }
      for (let i = 0; i < len; i += 8) {
        swap(this, i, i + 7);
        swap(this, i + 1, i + 6);
        swap(this, i + 2, i + 5);
        swap(this, i + 3, i + 4);
      }
      return this;
    };
    Buffer3.prototype.toString = function toString() {
      const length = this.length;
      if (length === 0) return "";
      if (arguments.length === 0) return utf8Slice(this, 0, length);
      return slowToString.apply(this, arguments);
    };
    Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;
    Buffer3.prototype.equals = function equals(b) {
      if (!Buffer3.isBuffer(b)) throw new TypeError("Argument must be a Buffer");
      if (this === b) return true;
      return Buffer3.compare(this, b) === 0;
    };
    Buffer3.prototype.inspect = function inspect() {
      let str = "";
      const max = exports.INSPECT_MAX_BYTES;
      str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
      if (this.length > max) str += " ... ";
      return "<Buffer " + str + ">";
    };
    if (customInspectSymbol) {
      Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;
    }
    Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
      if (isInstance(target, Uint8Array)) {
        target = Buffer3.from(target, target.offset, target.byteLength);
      }
      if (!Buffer3.isBuffer(target)) {
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target
        );
      }
      if (start === void 0) {
        start = 0;
      }
      if (end === void 0) {
        end = target ? target.length : 0;
      }
      if (thisStart === void 0) {
        thisStart = 0;
      }
      if (thisEnd === void 0) {
        thisEnd = this.length;
      }
      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
        throw new RangeError("out of range index");
      }
      if (thisStart >= thisEnd && start >= end) {
        return 0;
      }
      if (thisStart >= thisEnd) {
        return -1;
      }
      if (start >= end) {
        return 1;
      }
      start >>>= 0;
      end >>>= 0;
      thisStart >>>= 0;
      thisEnd >>>= 0;
      if (this === target) return 0;
      let x = thisEnd - thisStart;
      let y = end - start;
      const len = Math.min(x, y);
      const thisCopy = this.slice(thisStart, thisEnd);
      const targetCopy = target.slice(start, end);
      for (let i = 0; i < len; ++i) {
        if (thisCopy[i] !== targetCopy[i]) {
          x = thisCopy[i];
          y = targetCopy[i];
          break;
        }
      }
      if (x < y) return -1;
      if (y < x) return 1;
      return 0;
    };
    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
      if (buffer.length === 0) return -1;
      if (typeof byteOffset === "string") {
        encoding = byteOffset;
        byteOffset = 0;
      } else if (byteOffset > 2147483647) {
        byteOffset = 2147483647;
      } else if (byteOffset < -2147483648) {
        byteOffset = -2147483648;
      }
      byteOffset = +byteOffset;
      if (numberIsNaN(byteOffset)) {
        byteOffset = dir ? 0 : buffer.length - 1;
      }
      if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
      if (byteOffset >= buffer.length) {
        if (dir) return -1;
        else byteOffset = buffer.length - 1;
      } else if (byteOffset < 0) {
        if (dir) byteOffset = 0;
        else return -1;
      }
      if (typeof val === "string") {
        val = Buffer3.from(val, encoding);
      }
      if (Buffer3.isBuffer(val)) {
        if (val.length === 0) {
          return -1;
        }
        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
      } else if (typeof val === "number") {
        val = val & 255;
        if (typeof Uint8Array.prototype.indexOf === "function") {
          if (dir) {
            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
          } else {
            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
          }
        }
        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
      }
      throw new TypeError("val must be string, number or Buffer");
    }
    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
      let indexSize = 1;
      let arrLength = arr.length;
      let valLength = val.length;
      if (encoding !== void 0) {
        encoding = String(encoding).toLowerCase();
        if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
          if (arr.length < 2 || val.length < 2) {
            return -1;
          }
          indexSize = 2;
          arrLength /= 2;
          valLength /= 2;
          byteOffset /= 2;
        }
      }
      function read(buf, i2) {
        if (indexSize === 1) {
          return buf[i2];
        } else {
          return buf.readUInt16BE(i2 * indexSize);
        }
      }
      let i;
      if (dir) {
        let foundIndex = -1;
        for (i = byteOffset; i < arrLength; i++) {
          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
            if (foundIndex === -1) foundIndex = i;
            if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
          } else {
            if (foundIndex !== -1) i -= i - foundIndex;
            foundIndex = -1;
          }
        }
      } else {
        if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
        for (i = byteOffset; i >= 0; i--) {
          let found = true;
          for (let j = 0; j < valLength; j++) {
            if (read(arr, i + j) !== read(val, j)) {
              found = false;
              break;
            }
          }
          if (found) return i;
        }
      }
      return -1;
    }
    Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {
      return this.indexOf(val, byteOffset, encoding) !== -1;
    };
    Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
    };
    Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
    };
    function hexWrite(buf, string, offset, length) {
      offset = Number(offset) || 0;
      const remaining = buf.length - offset;
      if (!length) {
        length = remaining;
      } else {
        length = Number(length);
        if (length > remaining) {
          length = remaining;
        }
      }
      const strLen = string.length;
      if (length > strLen / 2) {
        length = strLen / 2;
      }
      let i;
      for (i = 0; i < length; ++i) {
        const parsed = parseInt(string.substr(i * 2, 2), 16);
        if (numberIsNaN(parsed)) return i;
        buf[offset + i] = parsed;
      }
      return i;
    }
    function utf8Write(buf, string, offset, length) {
      return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
    }
    function asciiWrite(buf, string, offset, length) {
      return blitBuffer(asciiToBytes(string), buf, offset, length);
    }
    function base64Write(buf, string, offset, length) {
      return blitBuffer(base64ToBytes(string), buf, offset, length);
    }
    function ucs2Write(buf, string, offset, length) {
      return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
    }
    Buffer3.prototype.write = function write(string, offset, length, encoding) {
      if (offset === void 0) {
        encoding = "utf8";
        length = this.length;
        offset = 0;
      } else if (length === void 0 && typeof offset === "string") {
        encoding = offset;
        length = this.length;
        offset = 0;
      } else if (isFinite(offset)) {
        offset = offset >>> 0;
        if (isFinite(length)) {
          length = length >>> 0;
          if (encoding === void 0) encoding = "utf8";
        } else {
          encoding = length;
          length = void 0;
        }
      } else {
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      }
      const remaining = this.length - offset;
      if (length === void 0 || length > remaining) length = remaining;
      if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
        throw new RangeError("Attempt to write outside buffer bounds");
      }
      if (!encoding) encoding = "utf8";
      let loweredCase = false;
      for (; ; ) {
        switch (encoding) {
          case "hex":
            return hexWrite(this, string, offset, length);
          case "utf8":
          case "utf-8":
            return utf8Write(this, string, offset, length);
          case "ascii":
          case "latin1":
          case "binary":
            return asciiWrite(this, string, offset, length);
          case "base64":
            return base64Write(this, string, offset, length);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ucs2Write(this, string, offset, length);
          default:
            if (loweredCase) throw new TypeError("Unknown encoding: " + encoding);
            encoding = ("" + encoding).toLowerCase();
            loweredCase = true;
        }
      }
    };
    Buffer3.prototype.toJSON = function toJSON() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function base64Slice(buf, start, end) {
      if (start === 0 && end === buf.length) {
        return base64.fromByteArray(buf);
      } else {
        return base64.fromByteArray(buf.slice(start, end));
      }
    }
    function utf8Slice(buf, start, end) {
      end = Math.min(buf.length, end);
      const res = [];
      let i = start;
      while (i < end) {
        const firstByte = buf[i];
        let codePoint = null;
        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
        if (i + bytesPerSequence <= end) {
          let secondByte, thirdByte, fourthByte, tempCodePoint;
          switch (bytesPerSequence) {
            case 1:
              if (firstByte < 128) {
                codePoint = firstByte;
              }
              break;
            case 2:
              secondByte = buf[i + 1];
              if ((secondByte & 192) === 128) {
                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                if (tempCodePoint > 127) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 3:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                  codePoint = tempCodePoint;
                }
              }
              break;
            case 4:
              secondByte = buf[i + 1];
              thirdByte = buf[i + 2];
              fourthByte = buf[i + 3];
              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                  codePoint = tempCodePoint;
                }
              }
          }
        }
        if (codePoint === null) {
          codePoint = 65533;
          bytesPerSequence = 1;
        } else if (codePoint > 65535) {
          codePoint -= 65536;
          res.push(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        res.push(codePoint);
        i += bytesPerSequence;
      }
      return decodeCodePointsArray(res);
    }
    var MAX_ARGUMENTS_LENGTH = 4096;
    function decodeCodePointsArray(codePoints) {
      const len = codePoints.length;
      if (len <= MAX_ARGUMENTS_LENGTH) {
        return String.fromCharCode.apply(String, codePoints);
      }
      let res = "";
      let i = 0;
      while (i < len) {
        res += String.fromCharCode.apply(
          String,
          codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
        );
      }
      return res;
    }
    function asciiSlice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i] & 127);
      }
      return ret;
    }
    function latin1Slice(buf, start, end) {
      let ret = "";
      end = Math.min(buf.length, end);
      for (let i = start; i < end; ++i) {
        ret += String.fromCharCode(buf[i]);
      }
      return ret;
    }
    function hexSlice(buf, start, end) {
      const len = buf.length;
      if (!start || start < 0) start = 0;
      if (!end || end < 0 || end > len) end = len;
      let out = "";
      for (let i = start; i < end; ++i) {
        out += hexSliceLookupTable[buf[i]];
      }
      return out;
    }
    function utf16leSlice(buf, start, end) {
      const bytes = buf.slice(start, end);
      let res = "";
      for (let i = 0; i < bytes.length - 1; i += 2) {
        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
      }
      return res;
    }
    Buffer3.prototype.slice = function slice(start, end) {
      const len = this.length;
      start = ~~start;
      end = end === void 0 ? len : ~~end;
      if (start < 0) {
        start += len;
        if (start < 0) start = 0;
      } else if (start > len) {
        start = len;
      }
      if (end < 0) {
        end += len;
        if (end < 0) end = 0;
      } else if (end > len) {
        end = len;
      }
      if (end < start) end = start;
      const newBuf = this.subarray(start, end);
      Object.setPrototypeOf(newBuf, Buffer3.prototype);
      return newBuf;
    };
    function checkOffset(offset, ext, length) {
      if (offset % 1 !== 0 || offset < 0) throw new RangeError("offset is not uint");
      if (offset + ext > length) throw new RangeError("Trying to access beyond buffer length");
    }
    Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        checkOffset(offset, byteLength2, this.length);
      }
      let val = this[offset + --byteLength2];
      let mul = 1;
      while (byteLength2 > 0 && (mul *= 256)) {
        val += this[offset + --byteLength2] * mul;
      }
      return val;
    };
    Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      return this[offset];
    };
    Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] | this[offset + 1] << 8;
    };
    Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      return this[offset] << 8 | this[offset + 1];
    };
    Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
    };
    Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
    };
    Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const lo = first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24;
      const hi = this[++offset] + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + last * 2 ** 24;
      return BigInt(lo) + (BigInt(hi) << BigInt(32));
    });
    Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const hi = first * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      const lo = this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last;
      return (BigInt(hi) << BigInt(32)) + BigInt(lo);
    });
    Buffer3.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let val = this[offset];
      let mul = 1;
      let i = 0;
      while (++i < byteLength2 && (mul *= 256)) {
        val += this[offset + i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) checkOffset(offset, byteLength2, this.length);
      let i = byteLength2;
      let mul = 1;
      let val = this[offset + --i];
      while (i > 0 && (mul *= 256)) {
        val += this[offset + --i] * mul;
      }
      mul *= 128;
      if (val >= mul) val -= Math.pow(2, 8 * byteLength2);
      return val;
    };
    Buffer3.prototype.readInt8 = function readInt8(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 1, this.length);
      if (!(this[offset] & 128)) return this[offset];
      return (255 - this[offset] + 1) * -1;
    };
    Buffer3.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset] | this[offset + 1] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 2, this.length);
      const val = this[offset + 1] | this[offset] << 8;
      return val & 32768 ? val | 4294901760 : val;
    };
    Buffer3.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
    };
    Buffer3.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
    };
    Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = this[offset + 4] + this[offset + 5] * 2 ** 8 + this[offset + 6] * 2 ** 16 + (last << 24);
      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * 2 ** 8 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 24);
    });
    Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
      offset = offset >>> 0;
      validateNumber(offset, "offset");
      const first = this[offset];
      const last = this[offset + 7];
      if (first === void 0 || last === void 0) {
        boundsError(offset, this.length - 8);
      }
      const val = (first << 24) + // Overflow
      this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + this[++offset];
      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * 2 ** 24 + this[++offset] * 2 ** 16 + this[++offset] * 2 ** 8 + last);
    });
    Buffer3.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, true, 23, 4);
    };
    Buffer3.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 4, this.length);
      return ieee754.read(this, offset, false, 23, 4);
    };
    Buffer3.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, true, 52, 8);
    };
    Buffer3.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
      offset = offset >>> 0;
      if (!noAssert) checkOffset(offset, 8, this.length);
      return ieee754.read(this, offset, false, 52, 8);
    };
    function checkInt(buf, value, offset, ext, max, min) {
      if (!Buffer3.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
      if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
    }
    Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let mul = 1;
      let i = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      byteLength2 = byteLength2 >>> 0;
      if (!noAssert) {
        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;
        checkInt(this, value, offset, byteLength2, maxBytes, 0);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        this[offset + i] = value / mul & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 255, 0);
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 65535, 0);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 4294967295, 0);
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    function wrtBigUInt64LE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      lo = lo >> 8;
      buf[offset++] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      hi = hi >> 8;
      buf[offset++] = hi;
      return offset;
    }
    function wrtBigUInt64BE(buf, value, offset, min, max) {
      checkIntBI(value, min, max, buf, offset, 7);
      let lo = Number(value & BigInt(4294967295));
      buf[offset + 7] = lo;
      lo = lo >> 8;
      buf[offset + 6] = lo;
      lo = lo >> 8;
      buf[offset + 5] = lo;
      lo = lo >> 8;
      buf[offset + 4] = lo;
      let hi = Number(value >> BigInt(32) & BigInt(4294967295));
      buf[offset + 3] = hi;
      hi = hi >> 8;
      buf[offset + 2] = hi;
      hi = hi >> 8;
      buf[offset + 1] = hi;
      hi = hi >> 8;
      buf[offset] = hi;
      return offset + 8;
    }
    Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt("0xffffffffffffffff"));
    });
    Buffer3.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = 0;
      let mul = 1;
      let sub = 0;
      this[offset] = value & 255;
      while (++i < byteLength2 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        const limit = Math.pow(2, 8 * byteLength2 - 1);
        checkInt(this, value, offset, byteLength2, limit - 1, -limit);
      }
      let i = byteLength2 - 1;
      let mul = 1;
      let sub = 0;
      this[offset + i] = value & 255;
      while (--i >= 0 && (mul *= 256)) {
        if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
          sub = 1;
        }
        this[offset + i] = (value / mul >> 0) - sub & 255;
      }
      return offset + byteLength2;
    };
    Buffer3.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 1, 127, -128);
      if (value < 0) value = 255 + value + 1;
      this[offset] = value & 255;
      return offset + 1;
    };
    Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      return offset + 2;
    };
    Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 2, 32767, -32768);
      this[offset] = value >>> 8;
      this[offset + 1] = value & 255;
      return offset + 2;
    };
    Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      this[offset] = value & 255;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
      return offset + 4;
    };
    Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) checkInt(this, value, offset, 4, 2147483647, -2147483648);
      if (value < 0) value = 4294967295 + value + 1;
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 255;
      return offset + 4;
    };
    Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset = 0) {
      return wrtBigUInt64LE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset = 0) {
      return wrtBigUInt64BE(this, value, offset, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    });
    function checkIEEE754(buf, value, offset, ext, max, min) {
      if (offset + ext > buf.length) throw new RangeError("Index out of range");
      if (offset < 0) throw new RangeError("Index out of range");
    }
    function writeFloat(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
      }
      ieee754.write(buf, value, offset, littleEndian, 23, 4);
      return offset + 4;
    }
    Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
      return writeFloat(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
      return writeFloat(this, value, offset, false, noAssert);
    };
    function writeDouble(buf, value, offset, littleEndian, noAssert) {
      value = +value;
      offset = offset >>> 0;
      if (!noAssert) {
        checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
      }
      ieee754.write(buf, value, offset, littleEndian, 52, 8);
      return offset + 8;
    }
    Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
      return writeDouble(this, value, offset, true, noAssert);
    };
    Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
      return writeDouble(this, value, offset, false, noAssert);
    };
    Buffer3.prototype.copy = function copy(target, targetStart, start, end) {
      if (!Buffer3.isBuffer(target)) throw new TypeError("argument should be a Buffer");
      if (!start) start = 0;
      if (!end && end !== 0) end = this.length;
      if (targetStart >= target.length) targetStart = target.length;
      if (!targetStart) targetStart = 0;
      if (end > 0 && end < start) end = start;
      if (end === start) return 0;
      if (target.length === 0 || this.length === 0) return 0;
      if (targetStart < 0) {
        throw new RangeError("targetStart out of bounds");
      }
      if (start < 0 || start >= this.length) throw new RangeError("Index out of range");
      if (end < 0) throw new RangeError("sourceEnd out of bounds");
      if (end > this.length) end = this.length;
      if (target.length - targetStart < end - start) {
        end = target.length - targetStart + start;
      }
      const len = end - start;
      if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
        this.copyWithin(targetStart, start, end);
      } else {
        Uint8Array.prototype.set.call(
          target,
          this.subarray(start, end),
          targetStart
        );
      }
      return len;
    };
    Buffer3.prototype.fill = function fill(val, start, end, encoding) {
      if (typeof val === "string") {
        if (typeof start === "string") {
          encoding = start;
          start = 0;
          end = this.length;
        } else if (typeof end === "string") {
          encoding = end;
          end = this.length;
        }
        if (encoding !== void 0 && typeof encoding !== "string") {
          throw new TypeError("encoding must be a string");
        }
        if (typeof encoding === "string" && !Buffer3.isEncoding(encoding)) {
          throw new TypeError("Unknown encoding: " + encoding);
        }
        if (val.length === 1) {
          const code = val.charCodeAt(0);
          if (encoding === "utf8" && code < 128 || encoding === "latin1") {
            val = code;
          }
        }
      } else if (typeof val === "number") {
        val = val & 255;
      } else if (typeof val === "boolean") {
        val = Number(val);
      }
      if (start < 0 || this.length < start || this.length < end) {
        throw new RangeError("Out of range index");
      }
      if (end <= start) {
        return this;
      }
      start = start >>> 0;
      end = end === void 0 ? this.length : end >>> 0;
      if (!val) val = 0;
      let i;
      if (typeof val === "number") {
        for (i = start; i < end; ++i) {
          this[i] = val;
        }
      } else {
        const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);
        const len = bytes.length;
        if (len === 0) {
          throw new TypeError('The value "' + val + '" is invalid for argument "value"');
        }
        for (i = 0; i < end - start; ++i) {
          this[i + start] = bytes[i % len];
        }
      }
      return this;
    };
    var errors = {};
    function E(sym, getMessage, Base) {
      errors[sym] = class NodeError extends Base {
        constructor() {
          super();
          Object.defineProperty(this, "message", {
            value: getMessage.apply(this, arguments),
            writable: true,
            configurable: true
          });
          this.name = `${this.name} [${sym}]`;
          this.stack;
          delete this.name;
        }
        get code() {
          return sym;
        }
        set code(value) {
          Object.defineProperty(this, "code", {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        }
        toString() {
          return `${this.name} [${sym}]: ${this.message}`;
        }
      };
    }
    E(
      "ERR_BUFFER_OUT_OF_BOUNDS",
      function(name) {
        if (name) {
          return `${name} is outside of buffer bounds`;
        }
        return "Attempt to access memory outside buffer bounds";
      },
      RangeError
    );
    E(
      "ERR_INVALID_ARG_TYPE",
      function(name, actual) {
        return `The "${name}" argument must be of type number. Received type ${typeof actual}`;
      },
      TypeError
    );
    E(
      "ERR_OUT_OF_RANGE",
      function(str, range, input) {
        let msg = `The value of "${str}" is out of range.`;
        let received = input;
        if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {
            received = addNumericalSeparator(received);
          }
          received += "n";
        }
        msg += ` It must be ${range}. Received ${received}`;
        return msg;
      },
      RangeError
    );
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) {
        res = `_${val.slice(i - 3, i)}${res}`;
      }
      return `${val.slice(0, i)}${res}`;
    }
    function checkBounds(buf, offset, byteLength2) {
      validateNumber(offset, "offset");
      if (buf[offset] === void 0 || buf[offset + byteLength2] === void 0) {
        boundsError(offset, buf.length - (byteLength2 + 1));
      }
    }
    function checkIntBI(value, min, max, buf, offset, byteLength2) {
      if (value > max || value < min) {
        const n = typeof min === "bigint" ? "n" : "";
        let range;
        if (byteLength2 > 3) {
          if (min === 0 || min === BigInt(0)) {
            range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;
          } else {
            range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;
          }
        } else {
          range = `>= ${min}${n} and <= ${max}${n}`;
        }
        throw new errors.ERR_OUT_OF_RANGE("value", range, value);
      }
      checkBounds(buf, offset, byteLength2);
    }
    function validateNumber(value, name) {
      if (typeof value !== "number") {
        throw new errors.ERR_INVALID_ARG_TYPE(name, "number", value);
      }
    }
    function boundsError(value, length, type) {
      if (Math.floor(value) !== value) {
        validateNumber(value, type);
        throw new errors.ERR_OUT_OF_RANGE(type || "offset", "an integer", value);
      }
      if (length < 0) {
        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
      }
      throw new errors.ERR_OUT_OF_RANGE(
        type || "offset",
        `>= ${type ? 1 : 0} and <= ${length}`,
        value
      );
    }
    var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
    function base64clean(str) {
      str = str.split("=")[0];
      str = str.trim().replace(INVALID_BASE64_RE, "");
      if (str.length < 2) return "";
      while (str.length % 4 !== 0) {
        str = str + "=";
      }
      return str;
    }
    function utf8ToBytes(string, units) {
      units = units || Infinity;
      let codePoint;
      const length = string.length;
      let leadSurrogate = null;
      const bytes = [];
      for (let i = 0; i < length; ++i) {
        codePoint = string.charCodeAt(i);
        if (codePoint > 55295 && codePoint < 57344) {
          if (!leadSurrogate) {
            if (codePoint > 56319) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            } else if (i + 1 === length) {
              if ((units -= 3) > -1) bytes.push(239, 191, 189);
              continue;
            }
            leadSurrogate = codePoint;
            continue;
          }
          if (codePoint < 56320) {
            if ((units -= 3) > -1) bytes.push(239, 191, 189);
            leadSurrogate = codePoint;
            continue;
          }
          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
        } else if (leadSurrogate) {
          if ((units -= 3) > -1) bytes.push(239, 191, 189);
        }
        leadSurrogate = null;
        if (codePoint < 128) {
          if ((units -= 1) < 0) break;
          bytes.push(codePoint);
        } else if (codePoint < 2048) {
          if ((units -= 2) < 0) break;
          bytes.push(
            codePoint >> 6 | 192,
            codePoint & 63 | 128
          );
        } else if (codePoint < 65536) {
          if ((units -= 3) < 0) break;
          bytes.push(
            codePoint >> 12 | 224,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else if (codePoint < 1114112) {
          if ((units -= 4) < 0) break;
          bytes.push(
            codePoint >> 18 | 240,
            codePoint >> 12 & 63 | 128,
            codePoint >> 6 & 63 | 128,
            codePoint & 63 | 128
          );
        } else {
          throw new Error("Invalid code point");
        }
      }
      return bytes;
    }
    function asciiToBytes(str) {
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        byteArray.push(str.charCodeAt(i) & 255);
      }
      return byteArray;
    }
    function utf16leToBytes(str, units) {
      let c, hi, lo;
      const byteArray = [];
      for (let i = 0; i < str.length; ++i) {
        if ((units -= 2) < 0) break;
        c = str.charCodeAt(i);
        hi = c >> 8;
        lo = c % 256;
        byteArray.push(lo);
        byteArray.push(hi);
      }
      return byteArray;
    }
    function base64ToBytes(str) {
      return base64.toByteArray(base64clean(str));
    }
    function blitBuffer(src, dst, offset, length) {
      let i;
      for (i = 0; i < length; ++i) {
        if (i + offset >= dst.length || i >= src.length) break;
        dst[i + offset] = src[i];
      }
      return i;
    }
    function isInstance(obj, type) {
      return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
    }
    function numberIsNaN(obj) {
      return obj !== obj;
    }
    var hexSliceLookupTable = function() {
      const alphabet = "0123456789abcdef";
      const table = new Array(256);
      for (let i = 0; i < 16; ++i) {
        const i16 = i * 16;
        for (let j = 0; j < 16; ++j) {
          table[i16 + j] = alphabet[i] + alphabet[j];
        }
      }
      return table;
    }();
    function defineBigIntMethod(fn) {
      return typeof BigInt === "undefined" ? BufferBigIntNotDefined : fn;
    }
    function BufferBigIntNotDefined() {
      throw new Error("BigInt not supported");
    }
  }
});

// ../../node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "../../node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js"(exports, module2) {
    var buffer = require_buffer();
    var Buffer3 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer3.from && Buffer3.alloc && Buffer3.allocUnsafe && Buffer3.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer3(arg, encodingOrOffset, length);
    }
    SafeBuffer.prototype = Object.create(Buffer3.prototype);
    copyProps(Buffer3, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer3(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer3(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer3(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// ../../node_modules/.pnpm/randombytes@2.1.0/node_modules/randombytes/browser.js
var require_browser = __commonJS({
  "../../node_modules/.pnpm/randombytes@2.1.0/node_modules/randombytes/browser.js"(exports, module2) {
    "use strict";
    var MAX_BYTES = 65536;
    var MAX_UINT32 = 4294967295;
    function oldBrowser() {
      throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
    }
    var Buffer3 = require_safe_buffer().Buffer;
    var crypto = globalThis.crypto || globalThis.msCrypto;
    if (crypto && crypto.getRandomValues) {
      module2.exports = randomBytes;
    } else {
      module2.exports = oldBrowser;
    }
    function randomBytes(size, cb) {
      if (size > MAX_UINT32) throw new RangeError("requested too many random bytes");
      var bytes = Buffer3.allocUnsafe(size);
      if (size > 0) {
        if (size > MAX_BYTES) {
          for (var generated = 0; generated < size; generated += MAX_BYTES) {
            crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES));
          }
        } else {
          crypto.getRandomValues(bytes);
        }
      }
      if (typeof cb === "function") {
        return process.nextTick(function() {
          cb(null, bytes);
        });
      }
      return bytes;
    }
  }
});

// src/index.ts
var index_exports = {};
__export(index_exports, {
  AsgardeoBrowserClient: () => AsgardeoBrowserClient_default,
  AsgardeoSPAClient: () => AsgardeoSPAClient,
  AuthenticationHelper: () => AuthenticationHelper,
  CancelToken: () => import_axios2.CancelToken,
  Hooks: () => Hooks,
  HttpAdapter: () => import_axios2.AxiosAdapter,
  HttpBasicCredentials: () => import_axios2.AxiosBasicCredentials,
  HttpError: () => import_axios2.AxiosError,
  HttpInstance: () => import_axios2.AxiosInstance,
  HttpMethod: () => import_axios2.Method,
  HttpPromise: () => import_axios2.AxiosPromise,
  HttpProxyConfig: () => import_axios2.AxiosProxyConfig,
  HttpRequestTransformer: () => import_axios2.AxiosRequestTransformer,
  HttpResponse: () => import_axios2.AxiosResponse,
  HttpResponseTransformer: () => import_axios2.AxiosResponseTransformer,
  MainThreadClient: () => MainThreadClient,
  ResponseType: () => import_axios2.ResponseType,
  SPAHelper: () => SPAHelper,
  SPAUtils: () => SPAUtils,
  TOKEN_REQUEST_CONFIG_KEY: () => TOKEN_REQUEST_CONFIG_KEY,
  WebWorkerClass: () => WebWorkerClass,
  WebWorkerClient: () => WebWorkerClient,
  createClassObserver: () => createClassObserver,
  createMediaQueryListener: () => createMediaQueryListener,
  detectThemeMode: () => detectThemeMode,
  hasAuthParamsInUrl: () => hasAuthParamsInUrl_default,
  workerReceiver: () => workerReceiver
});
module.exports = __toCommonJS(index_exports);

// src/__legacy__/client.ts
var import_javascript8 = require("@asgardeo/javascript");

// src/__legacy__/clients/main-thread-client.ts
var import_javascript5 = require("@asgardeo/javascript");

// src/__legacy__/constants/messages-types.ts
var INIT = "init";
var SIGN_OUT = "sign-out";
var HTTP_REQUEST = "http-request";
var HTTP_REQUEST_ALL = "http-request-all";
var REQUEST_CUSTOM_GRANT = "request-custom-grant";
var REVOKE_ACCESS_TOKEN = "revoke-access-token";
var REQUEST_START = "request-start";
var REQUEST_SUCCESS = "request-success";
var REQUEST_FINISH = "request-finish";
var GET_OIDC_SERVICE_ENDPOINTS = "get-oidc-service-endpoints";
var GET_BASIC_USER_INFO = "get-basic-user-info";
var GET_DECODED_ID_TOKEN = "get-decoded-id-token";
var GET_DECODED_IDP_ID_TOKEN = "get-decoded-idp-id-token";
var GET_CRYPTO_HELPER = "get-crypto-helper";
var ENABLE_HTTP_HANDLER = "enable_http_handler";
var DISABLE_HTTP_HANDLER = "disable_http_handler";
var GET_AUTH_URL = "get_auth_url";
var REQUEST_ACCESS_TOKEN = "request_get_token";
var IS_AUTHENTICATED = "is_authenticated";
var GET_SIGN_OUT_URL = "get_sign_out_url";
var REFRESH_ACCESS_TOKEN = "refresh_access-token";
var REFRESH_ACCESS_TOKEN_ERR0R = "refresh-access-token-error";
var SET_SESSION_STATE = "set_session_state";
var START_AUTO_REFRESH_TOKEN = "start_auto_refresh_token";
var UPDATE_CONFIG = "update_config";
var GET_ID_TOKEN = "get_id_token";
var CHECK_SESSION_SIGNED_IN = "check_session_signed_in";
var CHECK_SESSION_SIGNED_OUT = "check_session_signed_out";
var GET_CONFIG_DATA = "get_config_data";
var SET_SESSION_STATE_FROM_IFRAME = "set_session_state_from_iframe";

// src/__legacy__/constants/storage.ts
var TOKEN_REQUEST_CONFIG_KEY = "token_request_config";

// src/__legacy__/constants/hooks.ts
var Hooks = /* @__PURE__ */ ((Hooks2) => {
  Hooks2["SignIn"] = "sign-in";
  Hooks2["SignOut"] = "sign-out";
  Hooks2["Initialize"] = "initialize";
  Hooks2["HttpRequestStart"] = "http-request-start";
  Hooks2["HttpRequestFinish"] = "http-request-finish";
  Hooks2["HttpRequestError"] = "http-request-error";
  Hooks2["HttpRequestSuccess"] = "http-request-success";
  Hooks2["RevokeAccessToken"] = "revoke-access-token";
  Hooks2["CustomGrant"] = "custom-grant";
  Hooks2["SignOutFailed"] = "sign-out-failed";
  return Hooks2;
})(Hooks || {});

// src/__legacy__/constants/session-management.ts
var OP_IFRAME = "opIFrame";
var RP_IFRAME = "rpIFrame";
var PROMPT_NONE_IFRAME = "promptNoneIFrame";
var STATE = "Y2hlY2tTZXNzaW9u";
var SILENT_SIGN_IN_STATE = "sign-in-silently";
var INITIALIZED_SILENT_SIGN_IN = "initialized-silent-sign-in";
var PROMPT_NONE_REQUEST_SENT = "promptNoneRequestSent";

// src/__legacy__/constants/parameters.ts
var ERROR = "error";
var ERROR_DESCRIPTION = "error_description";
var CUSTOM_GRANT_CONFIG = "custom_grant_config";
var STATE_QUERY = "state";

// src/__legacy__/constants/errors.ts
var ACCESS_TOKEN_INVALID = "Access token is invalid";

// src/__legacy__/helpers/session-management-helper.ts
var import_javascript2 = require("@asgardeo/javascript");

// src/__legacy__/utils/message-utils.ts
var MessageUtils = class {
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  constructor() {
  }
  /**
   * JSON stringifies the passed object.
   *
   * @param {any} data The data object.
   *
   * @return {ResponseMessage<string>} JSON string.
   */
  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
  static generateSuccessMessage(data) {
    return {
      blob: data?.data instanceof Blob ? data?.data : null,
      data: JSON.stringify(data ?? ""),
      success: true
    };
  }
  /**
   * JSON stringifies the passed object.
   *
   * @param {any} error The error object.
   *
   * @return {ResponseMessage<string>} JSON string.
   */
  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
  static generateFailureMessage(error) {
    if (error?.toJSON) {
      delete error.toJSON;
    }
    return {
      error: JSON.stringify(error ?? ""),
      success: false
    };
  }
};

// src/__legacy__/utils/spa-utils.ts
var import_javascript = require("@asgardeo/javascript");
var _SPAUtils = class _SPAUtils {
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  constructor() {
  }
  static removeAuthorizationCode() {
    const url = location.href;
    history.pushState({}, document.title, url.replace(/\?code=.*$/, ""));
  }
  static getPKCE(pkceKey) {
    return sessionStorage.getItem(pkceKey) ?? "";
  }
  static setPKCE(pkceKey, pkce) {
    sessionStorage.setItem(pkceKey, pkce);
  }
  static setSignOutURL(url, clientId, instanceID) {
    sessionStorage.setItem(
      `${import_javascript.OIDCRequestConstants.SignOut.Storage.StorageKeys.SIGN_OUT_URL}-instance_${instanceID}-${clientId}`,
      url
    );
  }
  static getSignOutUrl(clientId, instanceID) {
    return sessionStorage.getItem(
      `${import_javascript.OIDCRequestConstants.SignOut.Storage.StorageKeys.SIGN_OUT_URL}-instance_${instanceID}-${clientId}`
    ) ?? "";
  }
  static removePKCE(pkceKey) {
    sessionStorage.removeItem(pkceKey);
  }
  /**
   * This method is used to discontinue the execution of the `signIn` method if `callOnlyOnRedirect` is true and
   * the method is not called on being redirected from the authorization server.
   *
   * This method can be used to allow the `signIn` method to be called only
   * on being redirected from the authorization server.
   *
   * @param callOnlyOnRedirect {boolean} - True if the method should only be called on redirect.
   * @param authorizationCode {string} - Authorization code.
   *
   * @returns {boolean} - True if the method should be called.
   */
  static canContinueSignIn(callOnlyOnRedirect, authorizationCode) {
    if (callOnlyOnRedirect && !_SPAUtils.hasErrorInURL() && !_SPAUtils.hasAuthSearchParamsInURL() && !authorizationCode) {
      return false;
    }
    return true;
  }
  /**
   * Specifies if `trySilentSignIn` has been called.
   *
   * @returns {boolean} True if the `trySilentSignIn` method has been called once.
   */
  static isInitializedSilentSignIn() {
    return _SPAUtils.isSilentStatePresentInURL();
  }
  /**
   * Specifies if the `signIn` method has been called.
   *
   * @returns {boolean} True if the `signIn` has been called.
   */
  static wasSignInCalled() {
    if (_SPAUtils.hasErrorInURL() || _SPAUtils.hasAuthSearchParamsInURL()) {
      if (!this.isSilentStatePresentInURL()) {
        return true;
      }
    }
    return false;
  }
  static wasSilentSignInCalled() {
    const silentSignIsInitialized = sessionStorage.getItem(INITIALIZED_SILENT_SIGN_IN);
    const isSilentSignInInitialized = silentSignIsInitialized ? JSON.parse(silentSignIsInitialized) : null;
    return Boolean(isSilentSignInInitialized);
  }
  static async isSignOutSuccessful() {
    if (import_javascript.AsgardeoAuthClient.isSignOutSuccessful(window.location.href)) {
      const newUrl = window.location.href.split("?")[0];
      history.pushState({}, document.title, newUrl);
      await import_javascript.AsgardeoAuthClient.clearSession();
      return true;
    }
    return false;
  }
  static didSignOutFail() {
    if (import_javascript.AsgardeoAuthClient.didSignOutFail(window.location.href)) {
      const url = new URL(window.location.href);
      const error = url.searchParams.get(ERROR);
      const description = url.searchParams.get(ERROR_DESCRIPTION);
      const newUrl = window.location.href.split("?")[0];
      history.pushState({}, document.title, newUrl);
      return {
        description: description ?? "",
        error: error ?? ""
      };
    }
    return false;
  }
  /**
   * Checks if the URL the user agent is redirected to after an authorization request has the state parameter.
   *
   * @returns {boolean} True if there is a session-check state or a silent sign-in state.
   */
  static isSilentStatePresentInURL() {
    const state = new URL(window.location.href).searchParams.get("state");
    return state?.includes(SILENT_SIGN_IN_STATE) ?? false;
  }
  /**
   * Util function to test if `code` and `session_state` are available in the URL as search params.
   * @since 0.2.0
   * @deprecated Use `hasAuthParamsInUrl` from `@asgardeo/browser` instead.
   *
   * @param params - Search params.
   * @return {boolean}
   */
  static hasAuthSearchParamsInURL(params = window.location.search) {
    const AUTH_CODE_REGEXP = /[?&]code=[^&]+/;
    return AUTH_CODE_REGEXP.test(params);
  }
  /**
   * Util function to check if the URL contains an error.
   *
   * @param url - URL to be checked.
   *
   * @returns {boolean} - True if the URL contains an error.
   */
  static hasErrorInURL(url = window.location.href) {
    const urlObject = new URL(url);
    return !!urlObject.searchParams.get(ERROR) && urlObject.searchParams.get(STATE_QUERY) !== import_javascript.OIDCRequestConstants.Params.SIGN_OUT_SUCCESS;
  }
  /**
   * Checks if a prompt none can be sent by checking if a request has already been sent.
   *
   * @since 0.2.3
   *
   * @returns {boolean} - True if a prompt none request has not been sent.
   */
  static canSendPromptNoneRequest() {
    const promptNoneRequestSentRaw = sessionStorage.getItem(PROMPT_NONE_REQUEST_SENT);
    const promptNoneRequestSent = promptNoneRequestSentRaw ? JSON.parse(promptNoneRequestSentRaw) : null;
    return !promptNoneRequestSent;
  }
  /**
   * Sets the status of prompt none request.
   *
   * @since 0.2.3
   *
   * @param canSend {boolean} - True if a prompt none request can be sent.
   */
  static setPromptNoneRequestSent(canSend) {
    sessionStorage.setItem(PROMPT_NONE_REQUEST_SENT, JSON.stringify(canSend));
  }
  /**
   * Waits for a specified amount of time to give the user agent enough time to redirect.
   *
   * @param time {number} - Time in seconds.
   */
  static async waitTillPageRedirect(time) {
    const timeToWait = time ?? 3e3;
    await new Promise((resolve) => setTimeout(resolve, timeToWait * 1e3));
  }
};
/**
 * Waits for a condition before executing the rest of the code in non-blocking manner.
 *
 * @param condition {() => boolean} - Condition to be checked.
 * @param timeout {number} - Time in miliseconds.
 */
__publicField(_SPAUtils, "until", (condition, timeout = 500) => {
  const poll = (done) => condition() ? done() : setTimeout(() => poll(done), timeout);
  return new Promise(poll);
});
var SPAUtils = _SPAUtils;

// src/__legacy__/helpers/session-management-helper.ts
var SessionManagementHelper = /* @__PURE__ */ (() => {
  let _clientID;
  let _checkSessionEndpoint;
  let _sessionState;
  let _interval;
  let _redirectURL;
  let _sessionRefreshInterval;
  let _signOut;
  let _sessionRefreshIntervalTimeout;
  let _checkSessionIntervalTimeout;
  let _storage;
  let _setSessionState;
  let _getSignInUrl;
  const initialize = (clientId, checkSessionEndpoint, getSessionState, interval, sessionRefreshInterval, redirectURL, getSignInUrl) => {
    _clientID = clientId;
    _checkSessionEndpoint = checkSessionEndpoint;
    _sessionState = getSessionState;
    _interval = interval;
    _redirectURL = redirectURL;
    _sessionRefreshInterval = sessionRefreshInterval;
    _getSignInUrl = getSignInUrl;
    if (_interval > -1) {
      initiateCheckSession();
    }
    if (_sessionRefreshInterval > -1) {
      sessionRefreshInterval = setInterval(() => {
        sendPromptNoneRequest();
      }, _sessionRefreshInterval * 1e3);
    }
  };
  const initiateCheckSession = async () => {
    if (!_checkSessionEndpoint || !_clientID || !_redirectURL) {
      return;
    }
    const OP_IFRAME2 = "opIFrame";
    async function checkSession() {
      const sessionState = await _sessionState();
      if (Boolean(_clientID) && Boolean(sessionState)) {
        const message = `${_clientID} ${sessionState}`;
        const rpIFrame2 = document.getElementById(RP_IFRAME);
        const opIframe2 = rpIFrame2?.contentDocument?.getElementById(OP_IFRAME2);
        const win = opIframe2.contentWindow;
        win?.postMessage(message, _checkSessionEndpoint);
      }
    }
    const rpIFrame = document.getElementById(RP_IFRAME);
    const opIframe = rpIFrame?.contentDocument?.getElementById(OP_IFRAME2);
    opIframe.src = _checkSessionEndpoint + "?client_id=" + _clientID + "&redirect_uri=" + _redirectURL;
    _checkSessionIntervalTimeout = setInterval(checkSession, _interval * 1e3);
    listenToResponseFromOPIFrame();
  };
  const reset = () => {
    clearInterval(_checkSessionIntervalTimeout);
    clearInterval(_sessionRefreshIntervalTimeout);
  };
  const listenToResponseFromOPIFrame = () => {
    async function receiveMessage(e) {
      const targetOrigin = _checkSessionEndpoint;
      if (!targetOrigin || targetOrigin?.indexOf(e.origin) < 0 || e?.data?.type === SET_SESSION_STATE_FROM_IFRAME) {
        return;
      }
      if (e.data === "unchanged") {
      } else if (e.data === "error") {
        window.location.href = await _signOut();
      } else if (e.data === "changed") {
        sendPromptNoneRequest();
      }
    }
    window?.addEventListener("message", receiveMessage, false);
  };
  const sendPromptNoneRequest = async () => {
    const rpIFrame = document.getElementById(RP_IFRAME);
    const promptNoneIFrame = rpIFrame?.contentDocument?.getElementById(
      PROMPT_NONE_IFRAME
    );
    if (SPAUtils.canSendPromptNoneRequest()) {
      SPAUtils.setPromptNoneRequestSent(true);
      const receiveMessageListener = (e) => {
        if (e?.data?.type === SET_SESSION_STATE_FROM_IFRAME) {
          _setSessionState(e?.data?.data ?? "");
          window?.removeEventListener("message", receiveMessageListener);
        }
      };
      if (_storage === "browserMemory" /* BrowserMemory */ || _storage === "webWorker" /* WebWorker */) {
        window?.addEventListener("message", receiveMessageListener);
      }
      const promptNoneURL = await _getSignInUrl({
        prompt: "none",
        response_mode: "query",
        state: STATE
      });
      promptNoneIFrame.src = promptNoneURL;
    }
  };
  const receivePromptNoneResponse = async (setSessionState) => {
    const state = new URL(window.location.href).searchParams.get(STATE_QUERY);
    const sessionState = new URL(window.location.href).searchParams.get(import_javascript2.OIDCRequestConstants.Params.SESSION_STATE);
    const parent = window.parent.parent;
    if (state !== null && (state.includes(STATE) || state.includes(SILENT_SIGN_IN_STATE))) {
      const code = new URL(window.location.href).searchParams.get("code");
      if (code !== null && code.length !== 0) {
        if (state.includes(SILENT_SIGN_IN_STATE)) {
          const message = {
            data: {
              code,
              sessionState: sessionState ?? "",
              state
            },
            type: CHECK_SESSION_SIGNED_IN
          };
          sessionStorage.setItem(INITIALIZED_SILENT_SIGN_IN, "false");
          parent.postMessage(message, parent.origin);
          SPAUtils.setPromptNoneRequestSent(false);
          window.location.href = "about:blank";
          await SPAUtils.waitTillPageRedirect();
          return true;
        }
        const newSessionState = new URL(window.location.href).searchParams.get("session_state");
        if (_storage === "localStorage" /* LocalStorage */ || _storage === "sessionStorage" /* SessionStorage */) {
          setSessionState && await setSessionState(newSessionState);
        } else {
          const message = {
            data: newSessionState ?? "",
            type: SET_SESSION_STATE_FROM_IFRAME
          };
          window?.parent?.parent?.postMessage(message);
        }
        SPAUtils.setPromptNoneRequestSent(false);
        window.location.href = "about:blank";
        await SPAUtils.waitTillPageRedirect();
        return true;
      } else {
        if (state.includes(SILENT_SIGN_IN_STATE)) {
          const message = {
            type: CHECK_SESSION_SIGNED_OUT
          };
          window.parent.parent.postMessage(message, parent.origin);
          SPAUtils.setPromptNoneRequestSent(false);
          window.location.href = "about:blank";
          await SPAUtils.waitTillPageRedirect();
          return true;
        }
        SPAUtils.setPromptNoneRequestSent(false);
        const signOutURL = await _signOut();
        await import_javascript2.AsgardeoAuthClient.clearSession();
        parent.location.href = signOutURL;
        window.location.href = "about:blank";
        await SPAUtils.waitTillPageRedirect();
        return true;
      }
    }
    return false;
  };
  return async (signOut, storage, setSessionState) => {
    let rpIFrame = document.createElement("iframe");
    rpIFrame.setAttribute("id", RP_IFRAME);
    rpIFrame.style.display = "none";
    let rpIframeLoaded = false;
    rpIFrame.onload = () => {
      rpIFrame = document.getElementById(RP_IFRAME);
      const rpDoc = rpIFrame?.contentDocument;
      const opIFrame = rpDoc?.createElement("iframe");
      if (opIFrame) {
        opIFrame.setAttribute("id", OP_IFRAME);
        opIFrame.style.display = "none";
      }
      const promptNoneIFrame = rpDoc?.createElement("iframe");
      if (promptNoneIFrame) {
        promptNoneIFrame.setAttribute("id", PROMPT_NONE_IFRAME);
        promptNoneIFrame.style.display = "none";
      }
      opIFrame && rpIFrame?.contentDocument?.body?.appendChild(opIFrame);
      promptNoneIFrame && rpIFrame?.contentDocument?.body?.appendChild(promptNoneIFrame);
      rpIframeLoaded = true;
    };
    document?.body?.appendChild(rpIFrame);
    _signOut = signOut;
    _storage = storage;
    _setSessionState = setSessionState;
    const sleep = () => {
      return new Promise((resolve) => setTimeout(resolve, 1));
    };
    while (rpIframeLoaded === false) {
      await sleep();
    }
    return {
      initialize,
      receivePromptNoneResponse,
      reset
    };
  };
})();

// src/__legacy__/helpers/spa-helper.ts
var import_javascript3 = require("@asgardeo/javascript");
var SPAHelper = class {
  constructor(authClient) {
    __publicField(this, "_authenticationClient");
    __publicField(this, "_storageManager");
    this._authenticationClient = authClient;
    this._storageManager = this._authenticationClient.getStorageManager();
  }
  async refreshAccessTokenAutomatically(authenticationHelper) {
    const shouldRefreshAutomatically = (await this._storageManager.getConfigData())?.periodicTokenRefresh ?? false;
    if (!shouldRefreshAutomatically) {
      return;
    }
    const sessionData = await this._storageManager.getSessionData();
    if (sessionData.refresh_token) {
      const expiryTime = parseInt(sessionData.expires_in);
      const time = expiryTime <= 10 ? expiryTime : expiryTime - 10;
      const timer = setTimeout(async () => {
        await authenticationHelper.refreshAccessToken();
      }, time * 1e3);
      await this._storageManager.setTemporaryDataParameter(
        import_javascript3.TokenConstants.Storage.StorageKeys.REFRESH_TOKEN_TIMER,
        JSON.stringify(timer)
      );
    }
  }
  async getRefreshTimeoutTimer() {
    if (await this._storageManager.getTemporaryDataParameter(import_javascript3.TokenConstants.Storage.StorageKeys.REFRESH_TOKEN_TIMER)) {
      return JSON.parse(
        await this._storageManager.getTemporaryDataParameter(
          import_javascript3.TokenConstants.Storage.StorageKeys.REFRESH_TOKEN_TIMER
        )
      );
    }
    return -1;
  }
  async clearRefreshTokenTimeout(timer) {
    if (timer) {
      clearTimeout(timer);
      return;
    }
    const refreshTimer = await this.getRefreshTimeoutTimer();
    if (refreshTimer !== -1) {
      clearTimeout(refreshTimer);
    }
  }
};

// src/__legacy__/http-client/clients/axios-http-client.ts
var import_axios = __toESM(require("axios"), 1);

// src/__legacy__/http-client/helpers/decorators.ts
function staticDecorator() {
  return (_constructor) => {
  };
}

// src/__legacy__/http-client/clients/axios-http-client.ts
var HttpClient = class {
  /**
   * Private constructor to avoid object instantiation from outside
   * the class.
   *
   * @hideconstructor
   */
  constructor() {
    __publicField(this, "attachToken", () => Promise.resolve());
    __publicField(this, "requestStartCallback", () => null);
    __publicField(this, "requestSuccessCallback", () => null);
    __publicField(this, "requestErrorCallback", () => null);
    __publicField(this, "requestFinishCallback", () => null);
    this.init = this.init.bind(this);
    this.setHttpRequestErrorCallback = this.setHttpRequestErrorCallback.bind(this);
    this.setHttpRequestFinishCallback = this.setHttpRequestFinishCallback.bind(this);
    this.setHttpRequestStartCallback = this.setHttpRequestStartCallback.bind(this);
    this.setHttpRequestSuccessCallback = this.setHttpRequestSuccessCallback.bind(this);
  }
  /**
   * Returns an aggregated instance of type `HttpInstance` of `HttpClient`.
   *
   * @return {any}
   */
  static getInstance() {
    if (this.axiosInstance) {
      return this.axiosInstance;
    }
    this.axiosInstance = import_axios.default.create({
      withCredentials: true
    });
    if (!this.clientInstance) {
      this.clientInstance = new HttpClient();
    }
    this.axiosInstance.interceptors.request.use(async (request) => await this.clientInstance.requestHandler(request));
    this.axiosInstance.interceptors.response.use(
      (response) => this.clientInstance.successHandler(response),
      (error) => this.clientInstance.errorHandler(error)
    );
    this.axiosInstance.all = import_axios.default.all;
    this.axiosInstance.spread = import_axios.default.spread;
    this.axiosInstance.init = this.clientInstance.init;
    this.axiosInstance.enableHandler = this.clientInstance.enableHandler;
    this.axiosInstance.disableHandler = this.clientInstance.disableHandler;
    this.axiosInstance.disableHandlerWithTimeout = this.clientInstance.disableHandlerWithTimeout;
    this.axiosInstance.setHttpRequestStartCallback = this.clientInstance.setHttpRequestStartCallback;
    this.axiosInstance.setHttpRequestSuccessCallback = this.clientInstance.setHttpRequestSuccessCallback;
    this.axiosInstance.setHttpRequestErrorCallback = this.clientInstance.setHttpRequestErrorCallback;
    this.axiosInstance.setHttpRequestFinishCallback = this.clientInstance.setHttpRequestFinishCallback;
    return this.axiosInstance;
  }
  /**
   * Intercepts all the requests.
   * If the `isHandlerEnabled` flag is set to true, fires the `requestStartCallback`
   * and retrieves the access token from the server and attaches it to the request.
   * Else, just returns the original request.
   *
   * @param {HttpRequestConfig} request - Original request.
   * @return {HttpRequestConfig}
   */
  async requestHandler(request) {
    await this.attachToken(request);
    if (request?.shouldEncodeToFormData) {
      const data = request?.data;
      const formData = new FormData();
      Object.keys(data).forEach((key) => {
        formData.append(key, data[key]);
      });
      request.data = formData;
    }
    request.startTimeInMs = (/* @__PURE__ */ new Date()).getTime();
    if (HttpClient.isHandlerEnabled) {
      if (this.requestStartCallback && typeof this.requestStartCallback === "function") {
        this.requestStartCallback(request);
      }
    }
    return request;
  }
  /**
   * Handles response errors.
   * If the `isHandlerEnabled` flag is set to true, fires the `requestErrorCallback`
   * and the `requestFinishCallback` functions. Else, just returns the original error.
   *
   * @param {HttpError} error - Original error.
   * @return {HttpError}
   */
  errorHandler(error) {
    if (HttpClient.isHandlerEnabled) {
      if (this.requestErrorCallback && typeof this.requestErrorCallback === "function") {
        this.requestErrorCallback(error);
      }
      if (this.requestFinishCallback && typeof this.requestFinishCallback === "function") {
        this.requestFinishCallback();
      }
    }
    throw error;
  }
  /**
   * Handles response success.
   * If the `isHandlerEnabled` flag is set to true, fires the `requestSuccessCallback`
   * and the `requestFinishCallback` functions. Else, just returns the original response.
   *
   * @param {HttpResponse} response - Original response.
   * @return {HttpResponse}
   */
  successHandler(response) {
    if (HttpClient.isHandlerEnabled) {
      if (this.requestSuccessCallback && typeof this.requestSuccessCallback === "function") {
        this.requestSuccessCallback(response);
      }
      if (this.requestFinishCallback && typeof this.requestFinishCallback === "function") {
        this.requestFinishCallback();
      }
    }
    return response;
  }
  /**
   * Initializes the Http client.
   *
   * @param isHandlerEnabled - Flag to toggle handler enablement.
   * @param requestStartCallback - Callback function to be triggered on request start.
   * @param requestSuccessCallback - Callback function to be triggered on request success.
   * @param requestErrorCallback - Callback function to be triggered on request error.
   * @param requestFinishCallback - Callback function to be triggered on request error.
   */
  async init(isHandlerEnabled = true, attachToken) {
    HttpClient.isHandlerEnabled = isHandlerEnabled;
    this.attachToken = attachToken;
  }
  /**
   * Enables the handler.
   */
  enableHandler() {
    HttpClient.isHandlerEnabled = true;
  }
  /**
   * Disables the handler.
   */
  disableHandler() {
    HttpClient.isHandlerEnabled = false;
  }
  /**
   * Disables the handler for a given period of time.
   *
   * @param {number} timeout - Timeout in milliseconds.
   */
  disableHandlerWithTimeout(timeout = HttpClient.DEFAULT_HANDLER_DISABLE_TIMEOUT) {
    HttpClient.isHandlerEnabled = false;
    setTimeout(() => {
      HttpClient.isHandlerEnabled = true;
    }, timeout);
  }
  setHttpRequestStartCallback(callback) {
    this.requestStartCallback = callback;
  }
  setHttpRequestSuccessCallback(callback) {
    this.requestSuccessCallback = callback;
  }
  setHttpRequestErrorCallback(callback) {
    this.requestErrorCallback = callback;
  }
  setHttpRequestFinishCallback(callback) {
    this.requestFinishCallback = callback;
  }
};
__publicField(HttpClient, "axiosInstance");
__publicField(HttpClient, "clientInstance");
__publicField(HttpClient, "isHandlerEnabled");
__publicField(HttpClient, "DEFAULT_HANDLER_DISABLE_TIMEOUT", 1e3);
HttpClient = __decorateClass([
  staticDecorator()
], HttpClient);

// src/__legacy__/stores/local-store.ts
var LocalStore = class {
  async setData(key, value) {
    localStorage.setItem(key, value);
  }
  async getData(key) {
    return localStorage.getItem(key) ?? "{}";
  }
  async removeData(key) {
    localStorage.removeItem(key);
  }
};

// src/__legacy__/stores/memory-store.ts
var MemoryStore = class {
  constructor() {
    __publicField(this, "_data");
    this._data = /* @__PURE__ */ new Map();
  }
  async setData(key, value) {
    this._data.set(key, value);
  }
  async getData(key) {
    return this._data?.get(key) ?? "{}";
  }
  async removeData(key) {
    this._data.delete(key);
  }
};

// src/__legacy__/stores/session-store.ts
var SessionStore = class {
  async setData(key, value) {
    sessionStorage.setItem(key, value);
  }
  async getData(key) {
    return sessionStorage.getItem(key) ?? "{}";
  }
  async removeData(key) {
    sessionStorage.removeItem(key);
  }
};

// src/__legacy__/utils/crypto-utils.ts
var import_buffer = __toESM(require_buffer(), 1);
var import_javascript4 = require("@asgardeo/javascript");
var import_base64url = __toESM(require("base64url"), 1);
var import_fast_sha256 = __toESM(require("fast-sha256"), 1);
var import_jose = require("jose");
var import_randombytes = __toESM(require_browser(), 1);
var SPACryptoUtils = class {
  /**
   * Get URL encoded string.
   *
   * @returns {string} base 64 url encoded value.
   */
  base64URLEncode(value) {
    return import_base64url.default.encode(value).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
  }
  base64URLDecode(value) {
    return import_base64url.default.decode(value).toString();
  }
  hashSha256(data) {
    return import_buffer.Buffer.from((0, import_fast_sha256.default)(new TextEncoder().encode(data)));
  }
  generateRandomBytes(length) {
    return (0, import_randombytes.default)(length);
  }
  verifyJwt(idToken, jwk, algorithms, clientId, issuer, subject, clockTolerance, validateJwtIssuer) {
    const jwtVerifyOptions = {
      algorithms,
      audience: clientId,
      clockTolerance,
      subject
    };
    if (validateJwtIssuer ?? true) {
      jwtVerifyOptions["issuer"] = issuer;
    }
    return (0, import_jose.jwtVerify)(
      idToken,
      (0, import_jose.createLocalJWKSet)({
        keys: [jwk]
      }),
      jwtVerifyOptions
    ).then(() => {
      return Promise.resolve(true);
    }).catch((error) => {
      return Promise.reject(
        new import_javascript4.AsgardeoAuthException(
          "SPA-CRYPTO-UTILS-VJ-IV01",
          error?.reason ?? JSON.stringify(error),
          `${error?.code} ${error?.claim}`
        )
      );
    });
  }
};

// src/__legacy__/clients/main-thread-client.ts
var initiateStore = (store) => {
  switch (store) {
    case "localStorage" /* LocalStorage */:
      return new LocalStore();
    case "sessionStorage" /* SessionStorage */:
      return new SessionStore();
    case "browserMemory" /* BrowserMemory */:
      return new MemoryStore();
    default:
      return new SessionStore();
  }
};
var MainThreadClient = async (instanceID, config, getAuthHelper) => {
  const _store = initiateStore(config.storage);
  const _cryptoUtils = new SPACryptoUtils();
  const _authenticationClient = new import_javascript5.AsgardeoAuthClient();
  await _authenticationClient.initialize(config, _store, _cryptoUtils, instanceID);
  const _spaHelper = new SPAHelper(_authenticationClient);
  const _dataLayer = _authenticationClient.getStorageManager();
  const _sessionManagementHelper = await SessionManagementHelper(
    async () => _authenticationClient.getSignOutUrl(),
    config.storage ?? "sessionStorage" /* SessionStorage */,
    (sessionState) => _dataLayer.setSessionDataParameter(
      import_javascript5.OIDCRequestConstants.Params.SESSION_STATE,
      sessionState ?? ""
    )
  );
  const _authenticationHelper = getAuthHelper(_authenticationClient, _spaHelper);
  let _getSignOutURLFromSessionStorage = false;
  const _httpClient = HttpClient.getInstance();
  let _isHttpHandlerEnabled = true;
  let _httpErrorCallback;
  let _httpFinishCallback;
  const attachToken = async (request) => {
    await _authenticationHelper.attachTokenToRequestConfig(request);
  };
  _httpClient?.init && await _httpClient.init(true, attachToken);
  const setHttpRequestStartCallback = (callback) => {
    _httpClient?.setHttpRequestStartCallback && _httpClient.setHttpRequestStartCallback(callback);
  };
  const setHttpRequestSuccessCallback = (callback) => {
    _httpClient?.setHttpRequestSuccessCallback && _httpClient.setHttpRequestSuccessCallback(callback);
  };
  const setHttpRequestFinishCallback = (callback) => {
    _httpClient?.setHttpRequestFinishCallback && _httpClient.setHttpRequestFinishCallback(callback);
  };
  const setHttpRequestErrorCallback = (callback) => {
    _httpErrorCallback = callback;
  };
  const httpRequest = async (requestConfig) => _authenticationHelper.httpRequest(
    _httpClient,
    requestConfig,
    _isHttpHandlerEnabled,
    _httpErrorCallback,
    _httpFinishCallback
  );
  const httpRequestAll = async (requestConfigs) => _authenticationHelper.httpRequestAll(
    requestConfigs,
    _httpClient,
    _isHttpHandlerEnabled,
    _httpErrorCallback,
    _httpFinishCallback
  );
  const getHttpClient = () => _httpClient;
  const enableHttpHandler = () => {
    _authenticationHelper.enableHttpHandler(_httpClient);
    _isHttpHandlerEnabled = true;
    return true;
  };
  const disableHttpHandler = () => {
    _authenticationHelper.disableHttpHandler(_httpClient);
    _isHttpHandlerEnabled = false;
    return true;
  };
  const checkSession = async () => {
    const oidcEndpoints = await _authenticationClient.getOpenIDProviderEndpoints();
    const config2 = await _dataLayer.getConfigData();
    _authenticationHelper.initializeSessionManger(
      config2,
      oidcEndpoints,
      async () => (await _authenticationClient.getUserSession()).sessionState,
      async (params) => _authenticationClient.getSignInUrl(params),
      _sessionManagementHelper
    );
  };
  const shouldStopAuthn = async () => _sessionManagementHelper.receivePromptNoneResponse(async (sessionState) => {
    await _dataLayer.setSessionDataParameter(
      import_javascript5.OIDCRequestConstants.Params.SESSION_STATE,
      sessionState ?? ""
    );
  });
  const setSessionStatus = async (sessionStatus) => {
    await _dataLayer.setSessionStatus(sessionStatus);
  };
  const signIn = async (signInConfig, authorizationCode, sessionState, state, tokenRequestConfig) => {
    const basicUserInfo = await _authenticationHelper.handleSignIn(shouldStopAuthn, checkSession, void 0);
    if (basicUserInfo) {
      return basicUserInfo;
    }
    let resolvedAuthorizationCode;
    let resolvedSessionState;
    let resolvedState;
    let resolvedTokenRequestConfig = { params: {} };
    if (config?.responseMode === "form_post" && authorizationCode) {
      resolvedAuthorizationCode = authorizationCode;
      resolvedSessionState = sessionState ?? "";
      resolvedState = state ?? "";
    } else {
      resolvedAuthorizationCode = new URL(window.location.href).searchParams.get(import_javascript5.OIDCRequestConstants.Params.AUTHORIZATION_CODE) ?? "";
      resolvedSessionState = new URL(window.location.href).searchParams.get(import_javascript5.OIDCRequestConstants.Params.SESSION_STATE) ?? "";
      resolvedState = new URL(window.location.href).searchParams.get(import_javascript5.OIDCRequestConstants.Params.STATE) ?? "";
      SPAUtils.removeAuthorizationCode();
    }
    if (resolvedAuthorizationCode && resolvedState) {
      setSessionStatus("true");
      const storedTokenRequestConfig = await _dataLayer.getTemporaryDataParameter(TOKEN_REQUEST_CONFIG_KEY);
      if (storedTokenRequestConfig && typeof storedTokenRequestConfig === "string") {
        resolvedTokenRequestConfig = JSON.parse(storedTokenRequestConfig);
      }
      return requestAccessToken(
        resolvedAuthorizationCode,
        resolvedSessionState,
        resolvedState,
        resolvedTokenRequestConfig
      );
    }
    return _authenticationClient.getSignInUrl(signInConfig).then(async (url) => {
      if (config.storage === "browserMemory" /* BrowserMemory */ && config.enablePKCE) {
        const pkceKey = (0, import_javascript5.extractPkceStorageKeyFromState)(resolvedState);
        SPAUtils.setPKCE(pkceKey, await _authenticationClient.getPKCECode(resolvedState));
      }
      if (tokenRequestConfig) {
        _dataLayer.setTemporaryDataParameter(TOKEN_REQUEST_CONFIG_KEY, JSON.stringify(tokenRequestConfig));
      }
      if (signInConfig && signInConfig["response_mode"] === "direct") {
        const authorizeUrl = new URL(url);
        return (0, import_javascript5.initializeEmbeddedSignInFlow)({
          url: `${authorizeUrl.origin}${authorizeUrl.pathname}`,
          payload: Object.fromEntries(authorizeUrl.searchParams.entries())
        });
      }
      location.href = url;
      await SPAUtils.waitTillPageRedirect();
      return Promise.resolve({
        allowedScopes: "",
        displayName: "",
        email: "",
        sessionState: "",
        sub: "",
        tenantDomain: "",
        username: ""
      });
    });
  };
  const signOut = async () => {
    if (await _authenticationClient.isSignedIn() && !_getSignOutURLFromSessionStorage) {
      location.href = await _authenticationClient.getSignOutUrl();
    } else {
      location.href = SPAUtils.getSignOutUrl(config.clientId, instanceID);
    }
    _spaHelper.clearRefreshTokenTimeout();
    await _dataLayer.removeOIDCProviderMetaData();
    await _dataLayer.removeTemporaryData();
    await _dataLayer.removeSessionData();
    await _dataLayer.removeSessionStatus();
    await SPAUtils.waitTillPageRedirect();
    return true;
  };
  const enableRetrievingSignOutURLFromSession = (config2) => {
    if (config2.preventSignOutURLUpdate) {
      _getSignOutURLFromSessionStorage = true;
    }
  };
  const exchangeToken = async (config2) => _authenticationHelper.exchangeToken(config2, enableRetrievingSignOutURLFromSession);
  const refreshAccessToken = async () => {
    try {
      return await _authenticationHelper.refreshAccessToken(enableRetrievingSignOutURLFromSession);
    } catch (error) {
      return Promise.reject(error);
    }
  };
  const revokeAccessToken = async () => {
    const timer = await _spaHelper.getRefreshTimeoutTimer();
    return _authenticationClient.revokeAccessToken().then(() => {
      _sessionManagementHelper.reset();
      _spaHelper.clearRefreshTokenTimeout(timer);
      return Promise.resolve(true);
    }).catch((error) => Promise.reject(error));
  };
  const requestAccessToken = async (resolvedAuthorizationCode, resolvedSessionState, resolvedState, tokenRequestConfig) => _authenticationHelper.requestAccessToken(
    resolvedAuthorizationCode,
    resolvedSessionState,
    checkSession,
    void 0,
    resolvedState,
    tokenRequestConfig
  );
  const constructSilentSignInUrl = async (additionalParams = {}) => {
    const config2 = await _dataLayer.getConfigData();
    const urlString = await _authenticationClient.getSignInUrl({
      prompt: "none",
      state: SILENT_SIGN_IN_STATE,
      ...additionalParams
    });
    const urlObject = new URL(urlString);
    urlObject.searchParams.set("response_mode", "query");
    const url = urlObject.toString();
    if (config2.storage === "browserMemory" /* BrowserMemory */ && config2.enablePKCE) {
      const state = urlObject.searchParams.get(import_javascript5.OIDCRequestConstants.Params.STATE);
      SPAUtils.setPKCE(
        (0, import_javascript5.extractPkceStorageKeyFromState)(state ?? ""),
        await _authenticationClient.getPKCECode(state ?? "")
      );
    }
    return url;
  };
  const trySignInSilently = async (additionalParams, tokenRequestConfig) => _authenticationHelper.trySignInSilently(
    constructSilentSignInUrl,
    requestAccessToken,
    _sessionManagementHelper,
    additionalParams,
    tokenRequestConfig
  );
  const getUser = async () => _authenticationHelper.getUser();
  const getDecodedIdToken = async (sessionId) => _authenticationHelper.getDecodedIdToken(sessionId);
  const getCrypto = async () => _authenticationHelper.getCrypto();
  const getIdToken = async () => _authenticationHelper.getIdToken();
  const getOpenIDProviderEndpoints = async () => _authenticationHelper.getOpenIDProviderEndpoints();
  const getAccessToken = async () => _authenticationHelper.getAccessToken();
  const getStorageManager = async () => _authenticationHelper.getStorageManager();
  const getConfigData = async () => _dataLayer.getConfigData();
  const isSignedIn = async () => _authenticationHelper.isSignedIn();
  const isSessionActive = async () => await _dataLayer.getSessionStatus() === "true";
  const reInitialize = async (newConfig) => {
    const existingConfig = await _dataLayer.getConfigData();
    const isCheckSessionIframeDifferent = !(existingConfig && existingConfig.endpoints && existingConfig.endpoints.checkSessionIframe && newConfig && newConfig.endpoints && newConfig.endpoints.checkSessionIframe && existingConfig.endpoints.checkSessionIframe === newConfig.endpoints.checkSessionIframe);
    const config2 = { ...existingConfig, ...newConfig };
    await _authenticationClient.reInitialize(config2);
    if (config2.enableOIDCSessionManagement && isCheckSessionIframeDifferent) {
      _sessionManagementHelper.reset();
      checkSession();
    }
  };
  return {
    disableHttpHandler,
    enableHttpHandler,
    getAccessToken,
    getUser,
    getConfigData,
    getCrypto,
    getStorageManager,
    getDecodedIdToken,
    getHttpClient,
    getIdToken,
    getOpenIDProviderEndpoints,
    httpRequest,
    httpRequestAll,
    isSignedIn,
    isSessionActive,
    refreshAccessToken,
    exchangeToken,
    revokeAccessToken,
    setHttpRequestErrorCallback,
    setHttpRequestFinishCallback,
    setHttpRequestStartCallback,
    setHttpRequestSuccessCallback,
    signIn,
    signOut,
    trySignInSilently,
    reInitialize
  };
};

// src/__legacy__/clients/web-worker-client.ts
var import_javascript7 = require("@asgardeo/javascript");

// src/__legacy__/helpers/authentication-helper.ts
var import_javascript6 = require("@asgardeo/javascript");
var AuthenticationHelper = class {
  constructor(authClient, spaHelper) {
    __publicField(this, "_authenticationClient");
    __publicField(this, "_storageManager");
    __publicField(this, "_spaHelper");
    __publicField(this, "_instanceID");
    __publicField(this, "_isTokenRefreshing");
    this._authenticationClient = authClient;
    this._storageManager = this._authenticationClient.getStorageManager();
    this._spaHelper = spaHelper;
    this._instanceID = this._authenticationClient.getInstanceId();
    this._isTokenRefreshing = false;
  }
  enableHttpHandler(httpClient) {
    httpClient?.enableHandler && httpClient.enableHandler();
  }
  disableHttpHandler(httpClient) {
    httpClient?.disableHandler && httpClient.disableHandler();
  }
  initializeSessionManger(config, oidcEndpoints, getSessionState, getAuthzURL, sessionManagementHelper) {
    sessionManagementHelper.initialize(
      config.clientId,
      oidcEndpoints.checkSessionIframe ?? "",
      getSessionState,
      config.checkSessionInterval ?? 3,
      config.sessionRefreshInterval ?? 300,
      config.afterSignInUrl,
      getAuthzURL
    );
  }
  async exchangeToken(config, enableRetrievingSignOutURLFromSession) {
    let useDefaultEndpoint = true;
    let matches = false;
    if (config?.tokenEndpoint) {
      useDefaultEndpoint = false;
      for (const baseUrl of [
        ...(await this._storageManager.getConfigData())?.resourceServerURLs ?? [],
        config.baseUrl
      ]) {
        if (baseUrl && config.tokenEndpoint?.startsWith(baseUrl)) {
          matches = true;
          break;
        }
      }
    }
    if (config.shouldReplayAfterRefresh) {
      this._storageManager.setTemporaryDataParameter(CUSTOM_GRANT_CONFIG, JSON.stringify(config));
    }
    if (useDefaultEndpoint || matches) {
      return this._authenticationClient.exchangeToken(config).then(async (response) => {
        if (enableRetrievingSignOutURLFromSession && typeof enableRetrievingSignOutURLFromSession === "function") {
          enableRetrievingSignOutURLFromSession(config);
        }
        if (config.returnsSession) {
          this._spaHelper.refreshAccessTokenAutomatically(this);
          return this._authenticationClient.getUser();
        } else {
          return response;
        }
      }).catch((error) => {
        return Promise.reject(error);
      });
    } else {
      return Promise.reject(
        new import_javascript6.AsgardeoAuthException(
          "SPA-MAIN_THREAD_CLIENT-RCG-IV01",
          "Request to the provided endpoint is prohibited.",
          "Requests can only be sent to resource servers specified by the `resourceServerURLs` attribute while initializing the SDK. The specified token endpoint in this request cannot be found among the `resourceServerURLs`"
        )
      );
    }
  }
  async getCustomGrantConfigData() {
    const configString = await this._storageManager.getTemporaryDataParameter(CUSTOM_GRANT_CONFIG);
    if (configString) {
      return JSON.parse(configString);
    } else {
      return null;
    }
  }
  async refreshAccessToken(enableRetrievingSignOutURLFromSession) {
    try {
      await this._authenticationClient.refreshAccessToken();
      const customGrantConfig = await this.getCustomGrantConfigData();
      if (customGrantConfig) {
        await this.exchangeToken(customGrantConfig, enableRetrievingSignOutURLFromSession);
      }
      this._spaHelper.refreshAccessTokenAutomatically(this);
      return this._authenticationClient.getUser();
    } catch (error) {
      const refreshTokenError = {
        type: REFRESH_ACCESS_TOKEN_ERR0R
      };
      window.postMessage(refreshTokenError);
      return Promise.reject(error);
    }
  }
  async retryFailedRequests(failedRequest) {
    const httpClient = failedRequest.httpClient;
    const requestConfig = failedRequest.requestConfig;
    const isHttpHandlerEnabled = failedRequest.isHttpHandlerEnabled;
    const httpErrorCallback = failedRequest.httpErrorCallback;
    const httpFinishCallback = failedRequest.httpFinishCallback;
    await SPAUtils.until(() => !this._isTokenRefreshing);
    try {
      const httpResponse = await httpClient.request(requestConfig);
      return Promise.resolve(httpResponse);
    } catch (error) {
      if (isHttpHandlerEnabled) {
        if (typeof httpErrorCallback === "function") {
          await httpErrorCallback(error);
        }
        if (typeof httpFinishCallback === "function") {
          httpFinishCallback();
        }
      }
      return Promise.reject(error);
    }
  }
  async httpRequest(httpClient, requestConfig, isHttpHandlerEnabled, httpErrorCallback, httpFinishCallback, enableRetrievingSignOutURLFromSession) {
    let matches = false;
    const config = await this._storageManager.getConfigData();
    for (const baseUrl of [...await config?.resourceServerURLs ?? [], config.baseUrl]) {
      if (baseUrl && requestConfig?.url?.startsWith(baseUrl)) {
        matches = true;
        break;
      }
    }
    if (matches) {
      return httpClient.request(requestConfig).then((response) => {
        return Promise.resolve(response);
      }).catch(async (error) => {
        if (error?.response?.status === 401 || !error?.response) {
          if (this._isTokenRefreshing) {
            return this.retryFailedRequests({
              enableRetrievingSignOutURLFromSession,
              httpClient,
              httpErrorCallback,
              httpFinishCallback,
              isHttpHandlerEnabled,
              requestConfig
            });
          }
          this._isTokenRefreshing = true;
          let refreshAccessTokenResponse;
          try {
            refreshAccessTokenResponse = await this.refreshAccessToken(enableRetrievingSignOutURLFromSession);
            this._isTokenRefreshing = false;
          } catch (refreshError) {
            this._isTokenRefreshing = false;
            if (isHttpHandlerEnabled) {
              if (typeof httpErrorCallback === "function") {
                await httpErrorCallback({
                  ...error,
                  code: ACCESS_TOKEN_INVALID
                });
              }
              if (typeof httpFinishCallback === "function") {
                httpFinishCallback();
              }
            }
            throw new import_javascript6.AsgardeoAuthException(
              "SPA-AUTH_HELPER-HR-SE01",
              refreshError?.name ?? "Refresh token request failed.",
              refreshError?.message ?? "An error occurred while trying to refresh the access token following a 401 response from the server."
            );
          }
          if (refreshAccessTokenResponse) {
            try {
              const httpResponse = await httpClient.request(requestConfig);
              return Promise.resolve(httpResponse);
            } catch (error2) {
              if (isHttpHandlerEnabled) {
                if (typeof httpErrorCallback === "function") {
                  await httpErrorCallback(error2);
                }
                if (typeof httpFinishCallback === "function") {
                  httpFinishCallback();
                }
              }
              return Promise.reject(error2);
            }
          }
        }
        if (isHttpHandlerEnabled) {
          if (typeof httpErrorCallback === "function") {
            await httpErrorCallback(error);
          }
          if (typeof httpFinishCallback === "function") {
            httpFinishCallback();
          }
        }
        return Promise.reject(error);
      });
    } else {
      return Promise.reject(
        new import_javascript6.AsgardeoAuthException(
          "SPA-AUTH_HELPER-HR-IV02",
          "Request to the provided endpoint is prohibited.",
          "Requests can only be sent to resource servers specified by the `resourceServerURLs` attribute while initializing the SDK. The specified endpoint in this request cannot be found among the `resourceServerURLs`"
        )
      );
    }
  }
  async httpRequestAll(requestConfigs, httpClient, isHttpHandlerEnabled, httpErrorCallback, httpFinishCallback) {
    let matches = true;
    const config = await this._storageManager.getConfigData();
    for (const requestConfig of requestConfigs) {
      let urlMatches = false;
      for (const baseUrl of [...(await config)?.resourceServerURLs ?? [], config.baseUrl]) {
        if (baseUrl && requestConfig.url?.startsWith(baseUrl)) {
          urlMatches = true;
          break;
        }
      }
      if (!urlMatches) {
        matches = false;
        break;
      }
    }
    const requests = [];
    if (matches) {
      requestConfigs.forEach((request) => {
        requests.push(httpClient.request(request));
      });
      return httpClient?.all && httpClient.all(requests).then((responses) => {
        return Promise.resolve(responses);
      }).catch(async (error) => {
        if (error?.response?.status === 401 || !error?.response) {
          let refreshTokenResponse;
          try {
            refreshTokenResponse = await this._authenticationClient.refreshAccessToken();
          } catch (refreshError) {
            if (isHttpHandlerEnabled) {
              if (typeof httpErrorCallback === "function") {
                await httpErrorCallback({
                  ...error,
                  code: ACCESS_TOKEN_INVALID
                });
              }
              if (typeof httpFinishCallback === "function") {
                httpFinishCallback();
              }
            }
            throw new import_javascript6.AsgardeoAuthException(
              "SPA-AUTH_HELPER-HRA-SE01",
              refreshError?.name ?? "Refresh token request failed.",
              refreshError?.message ?? "An error occurred while trying to refresh the access token following a 401 response from the server."
            );
          }
          if (refreshTokenResponse) {
            return httpClient.all && httpClient.all(requests).then((response) => {
              return Promise.resolve(response);
            }).catch(async (error2) => {
              if (isHttpHandlerEnabled) {
                if (typeof httpErrorCallback === "function") {
                  await httpErrorCallback(error2);
                }
                if (typeof httpFinishCallback === "function") {
                  httpFinishCallback();
                }
              }
              return Promise.reject(error2);
            });
          }
        }
        if (isHttpHandlerEnabled) {
          if (typeof httpErrorCallback === "function") {
            await httpErrorCallback(error);
          }
          if (typeof httpFinishCallback === "function") {
            httpFinishCallback();
          }
        }
        return Promise.reject(error);
      });
    } else {
      throw new import_javascript6.AsgardeoAuthException(
        "SPA-AUTH_HELPER-HRA-IV02",
        "Request to the provided endpoint is prohibited.",
        "Requests can only be sent to resource servers specified by the `resourceServerURLs` attribute while initializing the SDK. The specified endpoint in this request cannot be found among the `resourceServerURLs`"
      );
    }
  }
  async requestAccessToken(authorizationCode, sessionState, checkSession, pkce, state, tokenRequestConfig) {
    const config = await this._storageManager.getConfigData();
    if (config.storage === "browserMemory" /* BrowserMemory */ && config.enablePKCE && sessionState) {
      const pkce2 = SPAUtils.getPKCE((0, import_javascript6.extractPkceStorageKeyFromState)(sessionState));
      await this._authenticationClient.setPKCECode((0, import_javascript6.extractPkceStorageKeyFromState)(sessionState), pkce2);
    } else if (config.storage === "webWorker" /* WebWorker */ && pkce) {
      await this._authenticationClient.setPKCECode(pkce, state ?? "");
    }
    if (authorizationCode) {
      return this._authenticationClient.requestAccessToken(authorizationCode, sessionState ?? "", state ?? "", void 0, tokenRequestConfig).then(async () => {
        if (config.storage !== "webWorker" /* WebWorker */) {
          SPAUtils.setSignOutURL(await this._authenticationClient.getSignOutUrl(), config.clientId, this._instanceID);
          if (this._spaHelper) {
            this._spaHelper.clearRefreshTokenTimeout();
            this._spaHelper.refreshAccessTokenAutomatically(this);
          }
          if (checkSession && typeof checkSession === "function" && config.enableOIDCSessionManagement) {
            checkSession();
          }
        } else {
          if (this._spaHelper) {
            this._spaHelper.refreshAccessTokenAutomatically(this);
          }
        }
        return this._authenticationClient.getUser();
      }).catch((error) => {
        return Promise.reject(error);
      });
    }
    return Promise.reject(
      new import_javascript6.AsgardeoAuthException(
        "SPA-AUTH_HELPER-RAT1-NF01",
        "No authorization code.",
        "No authorization code was found."
      )
    );
  }
  async trySignInSilently(constructSilentSignInUrl, requestAccessToken, sessionManagementHelper, additionalParams, tokenRequestConfig) {
    if (SPAUtils.isInitializedSilentSignIn()) {
      await sessionManagementHelper.receivePromptNoneResponse();
      return Promise.resolve({
        allowedScopes: "",
        displayName: "",
        email: "",
        sessionState: "",
        sub: "",
        tenantDomain: "",
        username: ""
      });
    }
    const rpIFrame = document.getElementById(RP_IFRAME);
    const promptNoneIFrame = rpIFrame?.contentDocument?.getElementById(
      PROMPT_NONE_IFRAME
    );
    try {
      const url = await constructSilentSignInUrl(additionalParams);
      promptNoneIFrame.src = url;
    } catch (error) {
      return Promise.reject(error);
    }
    return new Promise((resolve, reject) => {
      const timer = setTimeout(() => {
        resolve(false);
      }, 1e4);
      const listenToPromptNoneIFrame = async (e) => {
        const data = e.data;
        if (data?.type == CHECK_SESSION_SIGNED_OUT) {
          window.removeEventListener("message", listenToPromptNoneIFrame);
          clearTimeout(timer);
          resolve(false);
        }
        if (data?.type == CHECK_SESSION_SIGNED_IN && data?.data?.code) {
          requestAccessToken(data?.data?.code, data?.data?.sessionState, data?.data?.state, tokenRequestConfig).then((response) => {
            window.removeEventListener("message", listenToPromptNoneIFrame);
            resolve(response);
          }).catch((error) => {
            window.removeEventListener("message", listenToPromptNoneIFrame);
            reject(error);
          }).finally(() => {
            clearTimeout(timer);
          });
        }
      };
      window.addEventListener("message", listenToPromptNoneIFrame);
    });
  }
  async handleSignIn(shouldStopAuthn, checkSession, tryRetrievingUserInfo) {
    const config = await this._storageManager.getConfigData();
    if (await shouldStopAuthn()) {
      return Promise.resolve({
        allowedScopes: "",
        displayName: "",
        email: "",
        sessionState: "",
        sub: "",
        tenantDomain: "",
        username: ""
      });
    }
    if (config.storage !== "webWorker" /* WebWorker */) {
      if (await this._authenticationClient.isSignedIn()) {
        this._spaHelper.clearRefreshTokenTimeout();
        this._spaHelper.refreshAccessTokenAutomatically(this);
        if (config.enableOIDCSessionManagement) {
          checkSession();
        }
        return Promise.resolve(await this._authenticationClient.getUser());
      }
    }
    const error = new URL(window.location.href).searchParams.get(ERROR);
    const errorDescription = new URL(window.location.href).searchParams.get(ERROR_DESCRIPTION);
    if (error) {
      const url = new URL(window.location.href);
      url.searchParams.delete(ERROR);
      url.searchParams.delete(ERROR_DESCRIPTION);
      history.pushState(null, document.title, url.toString());
      throw new import_javascript6.AsgardeoAuthException("SPA-AUTH_HELPER-SI-SE01", error, errorDescription ?? "");
    }
    if (config.storage === "webWorker" /* WebWorker */ && tryRetrievingUserInfo) {
      const basicUserInfo = await tryRetrievingUserInfo();
      if (basicUserInfo) {
        return basicUserInfo;
      }
    }
    return Promise.resolve(void 0);
  }
  async attachTokenToRequestConfig(request) {
    const requestConfig = { attachToken: true, ...request };
    if (requestConfig.attachToken) {
      if (requestConfig.shouldAttachIDPAccessToken) {
        request.headers = {
          ...request.headers,
          Authorization: `Bearer ${await this.getIDPAccessToken()}`
        };
      } else {
        request.headers = {
          ...request.headers,
          Authorization: `Bearer ${await this.getAccessToken()}`
        };
      }
    }
  }
  async getUser() {
    return this._authenticationClient.getUser();
  }
  async getDecodedIdToken(sessionId) {
    return this._authenticationClient.getDecodedIdToken(sessionId);
  }
  async getDecodedIDPIDToken() {
    return this._authenticationClient.getDecodedIdToken();
  }
  async getCrypto() {
    return this._authenticationClient.getCrypto();
  }
  async getIdToken() {
    return this._authenticationClient.getIdToken();
  }
  async getOpenIDProviderEndpoints() {
    return this._authenticationClient.getOpenIDProviderEndpoints();
  }
  async getAccessToken() {
    return this._authenticationClient.getAccessToken();
  }
  async getIDPAccessToken() {
    return (await this._storageManager.getSessionData())?.access_token;
  }
  getStorageManager() {
    return this._storageManager;
  }
  async isSignedIn() {
    return this._authenticationClient.isSignedIn();
  }
};

// src/__legacy__/clients/web-worker-client.ts
var initiateStore2 = (store) => {
  switch (store) {
    case "localStorage" /* LocalStorage */:
      return new LocalStore();
    case "sessionStorage" /* SessionStorage */:
      return new SessionStore();
    case "browserMemory" /* BrowserMemory */:
      return new MemoryStore();
    default:
      return new SessionStore();
  }
};
var WebWorkerClient = async (instanceID, config, webWorker, getAuthHelper) => {
  let httpClientHandlers;
  const _requestTimeout = config?.requestTimeout ?? 6e4;
  let _isHttpHandlerEnabled = true;
  let _getSignOutURLFromSessionStorage = false;
  const _store = initiateStore2(config.storage);
  const _cryptoUtils = new SPACryptoUtils();
  const _authenticationClient = new import_javascript7.AsgardeoAuthClient();
  await _authenticationClient.initialize(config, _store, _cryptoUtils, instanceID);
  const _spaHelper = new SPAHelper(_authenticationClient);
  const _sessionManagementHelper = await SessionManagementHelper(
    async () => {
      const message = {
        type: SIGN_OUT
      };
      try {
        const signOutURL = await communicate(message);
        return signOutURL;
      } catch {
        return SPAUtils.getSignOutUrl(config.clientId, instanceID);
      }
    },
    config.storage,
    (sessionState) => setSessionState(sessionState)
  );
  const _authenticationHelper = getAuthHelper(
    _authenticationClient,
    _spaHelper
  );
  const worker = new webWorker();
  const communicate = (message) => {
    const channel = new MessageChannel();
    worker.postMessage(message, [channel.port2]);
    return new Promise((resolve, reject) => {
      const timer = setTimeout(() => {
        reject(
          new import_javascript7.AsgardeoAuthException(
            "SPA-WEB_WORKER_CLIENT-COM-TO01",
            "Operation timed out.",
            "No response was received from the web worker for " + _requestTimeout / 1e3 + " since dispatching the request"
          )
        );
      }, _requestTimeout);
      return channel.port1.onmessage = ({ data }) => {
        clearTimeout(timer);
        channel.port1.close();
        channel.port2.close();
        if (data?.success) {
          const responseData = data?.data ? JSON.parse(data?.data) : null;
          if (data?.blob) {
            responseData.data = data?.blob;
          }
          resolve(responseData);
        } else {
          reject(data.error ? JSON.parse(data.error) : null);
        }
      };
    });
  };
  const exchangeToken = (requestParams) => {
    const message = {
      data: requestParams,
      type: REQUEST_CUSTOM_GRANT
    };
    return communicate(message).then((response) => {
      if (requestParams.preventSignOutURLUpdate) {
        _getSignOutURLFromSessionStorage = true;
      }
      return Promise.resolve(response);
    }).catch((error) => {
      return Promise.reject(error);
    });
  };
  const httpRequest = (config2) => {
    if (config2?.data && config2?.data instanceof FormData) {
      config2.data = { ...Object.fromEntries((config2?.data).entries()), formData: true };
    }
    const message = {
      data: config2,
      type: HTTP_REQUEST
    };
    return communicate(message).then((response) => {
      return Promise.resolve(response);
    }).catch(async (error) => {
      if (_isHttpHandlerEnabled) {
        if (typeof httpClientHandlers.requestErrorCallback === "function") {
          await httpClientHandlers.requestErrorCallback(error);
        }
        if (typeof httpClientHandlers.requestFinishCallback === "function") {
          httpClientHandlers.requestFinishCallback();
        }
      }
      return Promise.reject(error);
    });
  };
  const httpRequestAll = (configs) => {
    const message = {
      data: configs,
      type: HTTP_REQUEST_ALL
    };
    return communicate(message).then((response) => {
      return Promise.resolve(response);
    }).catch(async (error) => {
      if (_isHttpHandlerEnabled) {
        if (typeof httpClientHandlers.requestErrorCallback === "function") {
          await httpClientHandlers.requestErrorCallback(error);
        }
        if (typeof httpClientHandlers.requestFinishCallback === "function") {
          httpClientHandlers.requestFinishCallback();
        }
      }
      return Promise.reject(error);
    });
  };
  const enableHttpHandler = () => {
    const message = {
      type: ENABLE_HTTP_HANDLER
    };
    return communicate(message).then(() => {
      _isHttpHandlerEnabled = true;
      return Promise.resolve(true);
    }).catch((error) => {
      return Promise.reject(error);
    });
  };
  const disableHttpHandler = () => {
    const message = {
      type: DISABLE_HTTP_HANDLER
    };
    return communicate(message).then(() => {
      _isHttpHandlerEnabled = false;
      return Promise.resolve(true);
    }).catch((error) => {
      return Promise.reject(error);
    });
  };
  const initialize = () => {
    if (!httpClientHandlers) {
      httpClientHandlers = {
        requestErrorCallback: () => Promise.resolve(),
        requestFinishCallback: () => null,
        requestStartCallback: () => null,
        requestSuccessCallback: () => null
      };
    }
    worker.onmessage = ({ data }) => {
      switch (data.type) {
        case REQUEST_FINISH:
          httpClientHandlers?.requestFinishCallback && httpClientHandlers?.requestFinishCallback();
          break;
        case REQUEST_START:
          httpClientHandlers?.requestStartCallback && httpClientHandlers?.requestStartCallback();
          break;
        case REQUEST_SUCCESS:
          httpClientHandlers?.requestSuccessCallback && httpClientHandlers?.requestSuccessCallback(data.data ? JSON.parse(data.data) : null);
          break;
      }
    };
    const message = {
      data: config,
      type: INIT
    };
    return communicate(message).then(() => {
      return Promise.resolve(true);
    }).catch((error) => {
      return Promise.reject(error);
    });
  };
  const setSessionState = (sessionState) => {
    const message = {
      data: sessionState,
      type: SET_SESSION_STATE
    };
    return communicate(message);
  };
  const startAutoRefreshToken = () => {
    const message = {
      type: START_AUTO_REFRESH_TOKEN
    };
    return communicate(message);
  };
  const checkSession = async () => {
    const oidcEndpoints = await getOpenIDProviderEndpoints();
    const config2 = await getConfigData();
    _authenticationHelper.initializeSessionManger(
      config2,
      oidcEndpoints,
      async () => (await _authenticationClient.getUserSession()).sessionState,
      async (params) => (await getSignInUrl(params)).authorizationURL,
      _sessionManagementHelper
    );
  };
  const constructSilentSignInUrl = async (additionalParams = {}) => {
    const config2 = await getConfigData();
    const message = {
      data: {
        prompt: "none",
        state: SILENT_SIGN_IN_STATE,
        ...additionalParams
      },
      type: GET_AUTH_URL
    };
    const response = await communicate(
      message
    );
    const pkceKey = (0, import_javascript7.extractPkceStorageKeyFromState)(
      new URL(response.authorizationURL).searchParams.get(import_javascript7.OIDCRequestConstants.Params.STATE) ?? ""
    );
    response.pkce && config2.enablePKCE && SPAUtils.setPKCE(pkceKey, response.pkce);
    const urlString = response.authorizationURL;
    const urlObject = new URL(urlString);
    urlObject.searchParams.set("response_mode", "query");
    const url = urlObject.toString();
    return url;
  };
  const trySignInSilently = async (additionalParams, tokenRequestConfig) => {
    return await _authenticationHelper.trySignInSilently(
      constructSilentSignInUrl,
      requestAccessToken,
      _sessionManagementHelper,
      additionalParams,
      tokenRequestConfig
    );
  };
  const getSignInUrl = async (params) => {
    const config2 = await getConfigData();
    const message = {
      data: params,
      type: GET_AUTH_URL
    };
    return communicate(message).then(
      async (response) => {
        if (response.pkce && config2.enablePKCE) {
          const pkceKey = (0, import_javascript7.extractPkceStorageKeyFromState)(
            new URL(response.authorizationURL).searchParams.get(import_javascript7.OIDCRequestConstants.Params.STATE) ?? ""
          );
          SPAUtils.setPKCE(pkceKey, response.pkce);
        }
        return Promise.resolve(response);
      }
    );
  };
  const requestAccessToken = async (resolvedAuthorizationCode, resolvedSessionState, resolvedState, tokenRequestConfig) => {
    const config2 = await getConfigData();
    const pkceKey = (0, import_javascript7.extractPkceStorageKeyFromState)(resolvedState);
    const message = {
      data: {
        code: resolvedAuthorizationCode,
        pkce: config2.enablePKCE ? SPAUtils.getPKCE(pkceKey) : void 0,
        sessionState: resolvedSessionState,
        state: resolvedState,
        tokenRequestConfig
      },
      type: REQUEST_ACCESS_TOKEN
    };
    config2.enablePKCE && SPAUtils.removePKCE(pkceKey);
    return communicate(message).then((response) => {
      const message2 = {
        type: GET_SIGN_OUT_URL
      };
      return communicate(message2).then((url) => {
        SPAUtils.setSignOutURL(url, config2.clientId, instanceID);
        if (config2.enableOIDCSessionManagement) {
          checkSession();
        }
        startAutoRefreshToken();
        return Promise.resolve(response);
      }).catch((error) => {
        return Promise.reject(error);
      });
    }).catch((error) => {
      return Promise.reject(error);
    });
  };
  const shouldStopAuthn = async () => {
    return await _sessionManagementHelper.receivePromptNoneResponse(async (sessionState) => {
      return setSessionState(sessionState);
    });
  };
  const tryRetrievingUserInfo = async () => {
    if (await isSignedIn()) {
      await startAutoRefreshToken();
      if (config.enableOIDCSessionManagement) {
        checkSession();
      }
      return getUser();
    }
    return Promise.resolve(void 0);
  };
  const signIn = async (params, authorizationCode, sessionState, state, tokenRequestConfig) => {
    const basicUserInfo = await _authenticationHelper.handleSignIn(
      shouldStopAuthn,
      checkSession,
      tryRetrievingUserInfo
    );
    if (basicUserInfo) {
      return basicUserInfo;
    } else {
      let resolvedAuthorizationCode;
      let resolvedSessionState;
      let resolvedState;
      if (config?.responseMode === "form_post" && authorizationCode) {
        resolvedAuthorizationCode = authorizationCode;
        resolvedSessionState = sessionState ?? "";
        resolvedState = state ?? "";
      } else {
        resolvedAuthorizationCode = new URL(window.location.href).searchParams.get(import_javascript7.OIDCRequestConstants.Params.AUTHORIZATION_CODE) ?? "";
        resolvedSessionState = new URL(window.location.href).searchParams.get(import_javascript7.OIDCRequestConstants.Params.SESSION_STATE) ?? "";
        resolvedState = new URL(window.location.href).searchParams.get(import_javascript7.OIDCRequestConstants.Params.STATE) ?? "";
        SPAUtils.removeAuthorizationCode();
      }
      if (resolvedAuthorizationCode && resolvedState) {
        return requestAccessToken(resolvedAuthorizationCode, resolvedSessionState, resolvedState, tokenRequestConfig);
      }
      return getSignInUrl(params).then(async (response) => {
        location.href = response.authorizationURL;
        await SPAUtils.waitTillPageRedirect();
        return Promise.resolve({
          allowedScopes: "",
          displayName: "",
          email: "",
          sessionState: "",
          sub: "",
          tenantDomain: "",
          username: ""
        });
      }).catch((error) => {
        return Promise.reject(error);
      });
    }
  };
  const signOut = () => {
    return new Promise((resolve, reject) => {
      if (!_getSignOutURLFromSessionStorage) {
        const message = {
          type: SIGN_OUT
        };
        return communicate(message).then(async (response) => {
          window.location.href = response;
          await SPAUtils.waitTillPageRedirect();
          return resolve(true);
        }).catch((error) => {
          return reject(error);
        });
      } else {
        window.location.href = SPAUtils.getSignOutUrl(config.clientId, instanceID);
        return SPAUtils.waitTillPageRedirect().then(() => {
          return Promise.resolve(true);
        });
      }
    });
  };
  const revokeAccessToken = () => {
    const message = {
      type: REVOKE_ACCESS_TOKEN
    };
    return communicate(message).then((response) => {
      _sessionManagementHelper.reset();
      return Promise.resolve(response);
    }).catch((error) => {
      return Promise.reject(error);
    });
  };
  const getOpenIDProviderEndpoints = () => {
    const message = {
      type: GET_OIDC_SERVICE_ENDPOINTS
    };
    return communicate(message).then((response) => {
      return Promise.resolve(response);
    }).catch((error) => {
      return Promise.reject(error);
    });
  };
  const getConfigData = () => {
    const message = {
      type: GET_CONFIG_DATA
    };
    return communicate(message).then((response) => {
      return Promise.resolve(response);
    }).catch((error) => {
      return Promise.reject(error);
    });
  };
  const getUser = () => {
    const message = {
      type: GET_BASIC_USER_INFO
    };
    return communicate(message).then((response) => {
      return Promise.resolve(response);
    }).catch((error) => {
      return Promise.reject(error);
    });
  };
  const getDecodedIdToken = (sessionId) => {
    const message = {
      type: GET_DECODED_ID_TOKEN
    };
    return communicate(message).then((response) => {
      return Promise.resolve(response);
    }).catch((error) => {
      return Promise.reject(error);
    });
  };
  const getDecodedIDPIDToken = () => {
    const message = {
      type: GET_DECODED_IDP_ID_TOKEN
    };
    return communicate(message).then((response) => {
      return Promise.resolve(response);
    }).catch((error) => {
      return Promise.reject(error);
    });
  };
  const getCrypto = () => {
    const message = {
      type: GET_CRYPTO_HELPER
    };
    return communicate(message).then((response) => {
      return Promise.resolve(response);
    }).catch((error) => {
      return Promise.reject(error);
    });
  };
  const getIdToken = () => {
    const message = {
      type: GET_ID_TOKEN
    };
    return communicate(message).then((response) => {
      return Promise.resolve(response);
    }).catch((error) => {
      return Promise.reject(error);
    });
  };
  const isSignedIn = () => {
    const message = {
      type: IS_AUTHENTICATED
    };
    return communicate(message).then((response) => {
      return Promise.resolve(response);
    }).catch((error) => {
      return Promise.reject(error);
    });
  };
  const refreshAccessToken = () => {
    const message = {
      type: REFRESH_ACCESS_TOKEN
    };
    return communicate(message);
  };
  const setHttpRequestSuccessCallback = (callback) => {
    if (callback && typeof callback === "function") {
      httpClientHandlers.requestSuccessCallback = callback;
    }
  };
  const setHttpRequestErrorCallback = (callback) => {
    if (callback && typeof callback === "function") {
      httpClientHandlers.requestErrorCallback = callback;
    }
  };
  const setHttpRequestStartCallback = (callback) => {
    if (callback && typeof callback === "function") {
      httpClientHandlers.requestStartCallback = callback;
    }
  };
  const setHttpRequestFinishCallback = (callback) => {
    if (callback && typeof callback === "function") {
      httpClientHandlers.requestFinishCallback = callback;
    }
  };
  const reInitialize = async (newConfig) => {
    const existingConfig = await getConfigData();
    const isCheckSessionIframeDifferent = !(existingConfig && existingConfig.endpoints && existingConfig.endpoints.checkSessionIframe && newConfig && newConfig.endpoints && newConfig.endpoints.checkSessionIframe && existingConfig.endpoints.checkSessionIframe === newConfig.endpoints.checkSessionIframe);
    const config2 = { ...existingConfig, ...newConfig };
    const message = {
      data: config2,
      type: UPDATE_CONFIG
    };
    await communicate(message);
    if (config2.enableOIDCSessionManagement && isCheckSessionIframeDifferent) {
      _sessionManagementHelper.reset();
      checkSession();
    }
  };
  return {
    disableHttpHandler,
    enableHttpHandler,
    getUser,
    getConfigData,
    getCrypto,
    getDecodedIDPIDToken,
    getDecodedIdToken,
    getIdToken,
    getOpenIDProviderEndpoints,
    httpRequest,
    httpRequestAll,
    initialize,
    isSignedIn,
    refreshAccessToken,
    exchangeToken,
    revokeAccessToken,
    setHttpRequestErrorCallback,
    setHttpRequestFinishCallback,
    setHttpRequestStartCallback,
    setHttpRequestSuccessCallback,
    signIn,
    signOut,
    trySignInSilently,
    reInitialize
  };
};

// src/__legacy__/client.ts
var DefaultConfig = {
  autoLogoutOnTokenRefreshError: false,
  checkSessionInterval: 3,
  enableOIDCSessionManagement: false,
  periodicTokenRefresh: false,
  sessionRefreshInterval: 300,
  storage: "sessionStorage" /* SessionStorage */
};
var _AsgardeoSPAClient = class _AsgardeoSPAClient {
  constructor(id) {
    __publicField(this, "_client");
    __publicField(this, "_storage");
    __publicField(this, "_authHelper", AuthenticationHelper);
    // protected _worker: new () => Worker = WorkerFile;
    __publicField(this, "_worker", null);
    __publicField(this, "_initialized", false);
    __publicField(this, "_startedInitialize", false);
    __publicField(this, "_onSignInCallback", () => null);
    __publicField(this, "_onSignOutCallback", () => null);
    __publicField(this, "_onSignOutFailedCallback", () => null);
    __publicField(this, "_onEndUserSession", () => null);
    __publicField(this, "_onInitialize", () => null);
    __publicField(this, "_onCustomGrant", /* @__PURE__ */ new Map());
    __publicField(this, "_instanceID");
    this._instanceID = id;
  }
  instantiateAuthHelper(authHelper) {
    if (authHelper) {
      this._authHelper = authHelper;
    } else {
      this._authHelper = AuthenticationHelper;
    }
  }
  // public instantiateWorker(worker: new () => Worker) {
  //   if (worker) {
  //     this._worker = worker;
  //   } else {
  //     this._worker = WorkerFile;
  //   }
  // }
  /**
   * This method specifies if the `AsgardeoSPAClient` has been initialized or not.
   *
   * @return {Promise<boolean>} - Resolves to `true` if the client has been initialized.
   *
   * @memberof AsgardeoSPAClient
   *
   * @private
   */
  async isInitialized() {
    if (!this._startedInitialize) {
      return false;
    }
    let iterationToWait = 0;
    const sleep = () => {
      return new Promise((resolve) => setTimeout(resolve, 1));
    };
    while (!this._initialized) {
      if (iterationToWait === 1e4) {
        console.warn("It is taking longer than usual for the object to be initialized");
      }
      await sleep();
      iterationToWait++;
    }
    return true;
  }
  /**
   * This method checks if the SDK is initialized and the user is authenticated.
   *
   * @param validateAuthentication - should user's authenticated status be checked as part of validation
   *
   * @return {Promise<boolean>} - A Promise that resolves with `true` if the SDK is initialized and the
   * user is authenticated.
   *
   * @memberof AsgardeoSPAClient
   *
   * @private
   */
  async _validateMethod(validateAuthentication = true) {
    if (!await this.isInitialized()) {
      return Promise.reject(
        new import_javascript8.AsgardeoAuthException(
          "SPA-AUTH_CLIENT-VM-NF01",
          "The SDK is not initialized.",
          "The SDK must be initialized first."
        )
      );
    }
    if (validateAuthentication && !await this.isSignedIn()) {
      return Promise.reject(
        new import_javascript8.AsgardeoAuthException(
          "SPA-AUTH_CLIENT-VM-IV02",
          "The user is not authenticated.",
          "The user must be authenticated first."
        )
      );
    }
    return true;
  }
  /**
   * This method returns the instance of the singleton class.
   * If an ID is provided, it will return the instance with the given ID.
   * If no ID is provided, it will return the default instance value 0.
   *
   * @return {AsgardeoSPAClient} - Returns the instance of the singleton class.
   *
   * @example
   * ```
   * const auth = AsgardeoSPAClient.getInstance();
   * ```
   *
   * @link https://github.com/asgardeo/asgardeo-auth-spa-sdk/tree/master#getinstance
   *
   * @memberof AsgardeoSPAClient
   *
   * @preserve
   */
  static getInstance(id) {
    if (id && this._instances?.get(id)) {
      return this._instances.get(id);
    } else if (!id && this._instances?.get(0)) {
      return this._instances.get(0);
    }
    if (id) {
      this._instances.set(id, new _AsgardeoSPAClient(id));
      return this._instances.get(id);
    }
    this._instances.set(0, new _AsgardeoSPAClient(0));
    return this._instances.get(0);
  }
  /**
   * This method initializes the `AsgardeoSPAClient` instance.
   *
   * @param {ConfigInterface} config The config object to initialize with.
   *
   * @return {Promise<boolean>} - Resolves to `true` if initialization is successful.
   *
   * @example
   * ```
   * auth.initialize({
   *     afterSignInUrl: "http://localhost:3000/sign-in",
   *     clientId: "client ID",
   *     baseUrl: "https://api.asgardeo.io"
   * });
   * ```
   *
   * @link https://github.com/asgardeo/asgardeo-auth-spa-sdk/tree/master#initialize
   *
   * @memberof AsgardeoSPAClient
   *
   * @preserve
   */
  async initialize(config, authHelper, workerFile) {
    this._storage = config.storage ?? "sessionStorage" /* SessionStorage */;
    this._initialized = false;
    this._startedInitialize = true;
    authHelper && this.instantiateAuthHelper(authHelper);
    const _config = await this._client?.getConfigData();
    if (!(this._storage === "webWorker" /* WebWorker */)) {
      const mainThreadClientConfig = config;
      const defaultConfig = { ...DefaultConfig };
      const mergedConfig = {
        ...defaultConfig,
        ...mainThreadClientConfig
      };
      if (!this._client || this._client && (!_config || Object.keys(_config)?.length === 0)) {
        this._client = await MainThreadClient(
          this._instanceID,
          mergedConfig,
          (authClient, spaHelper) => {
            return new this._authHelper(authClient, spaHelper);
          }
        );
      }
      this._initialized = true;
      if (this._onInitialize) {
        this._onInitialize(true);
      }
      if (!mergedConfig.autoLogoutOnTokenRefreshError) {
        return Promise.resolve(true);
      }
      window.addEventListener("message", (event) => {
        if (event?.data?.type === REFRESH_ACCESS_TOKEN_ERR0R) {
          this.signOut();
        }
      });
      return Promise.resolve(true);
    } else {
      if (!this._client || this._client && (!_config || Object.keys(_config)?.length === 0)) {
        const webWorkerClientConfig = config;
        this._client = await WebWorkerClient(
          this._instanceID,
          {
            ...DefaultConfig,
            ...webWorkerClientConfig
          },
          this._worker,
          (authClient, spaHelper) => {
            return new this._authHelper(authClient, spaHelper);
          }
        );
        return this._client.initialize().then(() => {
          if (this._onInitialize) {
            this._onInitialize(true);
          }
          this._initialized = true;
          return Promise.resolve(true);
        }).catch((error) => {
          return Promise.reject(error);
        });
      }
      return Promise.resolve(true);
    }
  }
  /**
   * This method returns a Promise that resolves with the basic user information obtained from the ID token.
   *
   * @return {Promise<User>} - A promise that resolves with the user information.
   *
   * @example
   * ```
   * auth.getUser().then((response) => {
   *    // console.log(response);
   * }).catch((error) => {
   *    // console.error(error);
   * });
   * ```
   *
   * @link https://github.com/asgardeo/asgardeo-auth-spa-sdk/tree/master#getuserinfo
   *
   * @memberof AsgardeoSPAClient
   *
   * @preserve
   */
  async getUser() {
    await this._validateMethod();
    return this._client?.getUser();
  }
  /**
   * This method initiates the authentication flow. This should be called twice.
   *  1. To initiate the authentication flow.
   *  2. To obtain the access token after getting the authorization code.
   *
   * To satisfy the second condition, one of the two strategies mentioned below can be used:
   *  1. Redirect the user back to the same login page that initiated the authentication flow.
   *  2. Call the `signIn()` method in the page the user is redirected to after authentication.
   *
   * **To fire a callback function after signing in, use the `on()` method.**
   * **To learn more about the `on()` method:**
   * @see {@link https://github.com/asgardeo/asgardeo-auth-spa-sdk/tree/master#on}
   *
   * @param {SignInConfig} config - The sign-in config.
   * The `SignInConfig` object has these two attributes in addition to any custom key-value pairs.
   *  1. fidp - Specifies the FIDP parameter that is used to take the user directly to an IdP login page.
   *  2. forceInit: Specifies if the OIDC Provider Meta Data should be loaded again from the `well-known`
   * endpoint.
   *  3. Any other parameters that should be appended to the authorization request.
   * @param {string} authorizationCode - The authorization code. (Optional)
   * @param {string} sessionState - The session state. (Optional)
   * @param {string} state - The state. (Optional)
   *
   * @return {Promise<User>} - A promise that resolves with the user information.
   *
   * @example
   * ```
   * auth.signIn();
   * ```
   *
   * @link https://github.com/asgardeo/asgardeo-auth-spa-sdk/tree/master#signin
   *
   * @memberof AsgardeoSPAClient
   *
   * @preserve
   */
  async signIn(config, authorizationCode, sessionState, state, tokenRequestConfig) {
    await this.isInitialized();
    if (!SPAUtils.canContinueSignIn(Boolean(config?.callOnlyOnRedirect), authorizationCode)) {
      return void 0;
    }
    delete config?.callOnlyOnRedirect;
    return this._client?.signIn(config, authorizationCode, sessionState, state, tokenRequestConfig).then((response) => {
      if (this._onSignInCallback) {
        this._onSignInCallback(response);
      }
      return response;
    });
  }
  /**
   * This method allows you to sign in silently.
   * First, this method sends a prompt none request to see if there is an active user session in the identity server.
   * If there is one, then it requests the access token and stores it. Else, it returns false.
   *
   * If this method is to be called on page load and the `signIn` method is also to be called on page load,
   * then it is advisable to call this method after the `signIn` call.
   *
   * @return {Promise<User | boolean>} - A Promise that resolves with the user information after signing in
   * or with `false` if the user is not signed in.
   *
   * @example
   *```
   * auth.trySignInSilently()
   *```
   */
  async trySignInSilently(additionalParams, tokenRequestConfig) {
    await this.isInitialized();
    if (SPAUtils.wasSignInCalled()) {
      return void 0;
    }
    return this._client?.trySignInSilently(additionalParams, tokenRequestConfig).then((response) => {
      if (this._onSignInCallback && response) {
        this._onSignInCallback(response);
      }
      return response;
    });
  }
  /**
   * This method initiates the sign-out flow.
   *
   * **To fire a callback function after signing out, use the `on()` method.**
   * **To learn more about the `on()` method:**
   * @see {@link https://github.com/asgardeo/asgardeo-auth-spa-sdk/tree/master#on}
   *
   * @return {Promise<boolean>} - Returns a promise that resolves with `true` if sign out is successful.
   *
   * @example
   * ```
   * auth.signOut();
   * ```
   *
   * @link https://github.com/asgardeo/asgardeo-auth-spa-sdk/tree/master#signout
   *
   * @memberof AsgardeoSPAClient
   *
   * @preserve
   */
  async signOut() {
    await this._validateMethod(false);
    const signOutResponse = await this._client?.signOut() ?? false;
    return signOutResponse;
  }
  /**
   * This method sends an API request to a protected endpoint.
   * The access token is automatically attached to the header of the request.
   * This is the only way by which protected endpoints can be accessed
   * when the web worker is used to store session information.
   *
   * @param {HttpRequestConfig} config -  The config object containing attributes necessary to send a request.
   *
   * @return {Promise<HttpResponse>} - Returns a Promise that resolves with the response to the request.
   *
   * @example
   * ```
   *  const requestConfig = {
   *      headers: {
   *          "Accept": "application/json",
   *          "Access-Control-Allow-Origin": "https://api.asgardeo.io/myaccount",
   *          "Content-Type": "application/scim+json"
   *      },
   *      method: "GET",
   *      url: "https://api.asgardeo.io/scim2/me"
   *  };
   *
   *  return auth.httpRequest(requestConfig)
   *     .then((response) => {
   *           // console.log(response);
   *      })
   *      .catch((error) => {
   *           // console.error(error);
   *      });
   * ```
   *
   * @link https://github.com/asgardeo/asgardeo-auth-spa-sdk/tree/master#httprequest
   *
   * @memberof AsgardeoSPAClient
   *
   * @preserve
   */
  async httpRequest(config) {
    await this._validateMethod(false);
    return this._client?.httpRequest(config);
  }
  /**
   * This method sends multiple API requests to a protected endpoint.
   * The access token is automatically attached to the header of the request.
   * This is the only way by which multiple requests can be sent to protected endpoints
   * when the web worker is used to store session information.
   *
   * @param {HttpRequestConfig[]} config -  The config object containing attributes necessary to send a request.
   *
   * @return {Promise<HttpResponse[]>} - Returns a Promise that resolves with the responses to the requests.
   *
   * @example
   * ```
   *  const requestConfig = {
   *      headers: {
   *          "Accept": "application/json",
   *          "Content-Type": "application/scim+json"
   *      },
   *      method: "GET",
   *      url: "https://api.asgardeo.io/scim2/me"
   *  };
   *
   *  const requestConfig2 = {
   *      headers: {
   *          "Accept": "application/json",
   *          "Content-Type": "application/scim+json"
   *      },
   *      method: "GET",
   *      url: "https://api.asgardeo.io/scim2/me"
   *  };
   *
   *  return auth.httpRequest([requestConfig, requestConfig2])
   *     .then((responses) => {
   *           response.forEach((response)=>{
   *              // console.log(response);
   *           });
   *      })
   *      .catch((error) => {
   *           // console.error(error);
   *      });
   * ```
   *
   * @link https://github.com/asgardeo/asgardeo-auth-spa-sdk/tree/master#httprequestall
   *
   * @memberof AsgardeoSPAClient
   *
   * @preserve
   */
  async httpRequestAll(config) {
    await this._validateMethod(false);
    return this._client?.httpRequestAll(config);
  }
  /**
   * This method allows you to send a request with a custom grant.
   *
   * @param {CustomGrantRequestParams} config - The request parameters.
   *
   * @return {Promise<HttpResponse<any> | SignInResponse>} - A Promise that resolves with
   * the value returned by the custom grant request.
   *
   * @example
   * ```
   * auth.customGrant({
   *   attachToken: false,
   *   data: {
   *       client_id: "{{clientId}}",
   *       grant_type: "account_switch",
   *       scope: "{{scope}}",
   *       token: "{{token}}",
   *   },
   *   id: "account-switch",
   *   returnResponse: true,
   *   returnsSession: true,
   *   signInRequired: true
   * });
   * ```
   *
   * @link https://github.com/asgardeo/asgardeo-auth-spa-sdk/tree/master#customgrant
   *
   * @memberof AsgardeoSPAClient
   *
   * @preserve
   */
  async exchangeToken(config) {
    if (config.signInRequired) {
      await this._validateMethod();
    } else {
      await this._validateMethod();
    }
    if (!config.id) {
      return Promise.reject(
        new import_javascript8.AsgardeoAuthException(
          "SPA-AUTH_CLIENT-RCG-NF01",
          "The custom grant request id not found.",
          "The id attribute of the custom grant config object passed as an argument should have a value."
        )
      );
    }
    const customGrantResponse = await this._client?.exchangeToken(config);
    const customGrantCallback = this._onCustomGrant.get(config.id);
    customGrantCallback && customGrantCallback(this._onCustomGrant?.get(config.id));
    return customGrantResponse;
  }
  /**
   * This method ends a user session. The access token is revoked and the session information is destroyed.
   *
   * **To fire a callback function after ending user session, use the `on()` method.**
   * **To learn more about the `on()` method:**
   * @see {@link https://github.com/asgardeo/asgardeo-auth-spa-sdk/tree/master#on}
   *
   * @return {Promise<boolean>} - A promise that resolves with `true` if the process is successful.
   *
   * @example
   * ```
   * auth.endUserSession();
   * ```
   *
   * @link https://github.com/asgardeo/asgardeo-auth-spa-sdk/tree/master#endusersession
   *
   * @memberof AsgardeoSPAClient
   *
   * @preserve
   */
  async revokeAccessToken() {
    await this._validateMethod();
    const revokeAccessToken = await this._client?.revokeAccessToken();
    this._onEndUserSession && await this._onEndUserSession(revokeAccessToken);
    return revokeAccessToken;
  }
  /**
   * This method returns a Promise that resolves with an object containing the service endpoints.
   *
   * @return {Promise<ServiceResourcesType} - A Promise that resolves with an object containing the service endpoints.
   *
   * @example
   * ```
   * auth.getServiceEndpoints().then((endpoints) => {
   *      // console.log(endpoints);
   *  }).error((error) => {
   *      // console.error(error);
   *  });
   * ```
   *
   * @link https://github.com/asgardeo/asgardeo-auth-spa-sdk/tree/master#getserviceendpoints
   *
   * @memberof AsgardeoSPAClient
   *
   * @preserve
   */
  async getOpenIDProviderEndpoints() {
    await this.isInitialized();
    return this._client?.getOpenIDProviderEndpoints();
  }
  /**
   * This methods returns the Axios http client.
   *
   * @return {HttpClientInstance} - The Axios HTTP client.
   *
   * @memberof AsgardeoSPAClient
   *
   * @preserve
   */
  getHttpClient() {
    if (this._client) {
      if (this._storage !== "webWorker" /* WebWorker */) {
        const mainThreadClient = this._client;
        return mainThreadClient.getHttpClient();
      }
      throw new import_javascript8.AsgardeoAuthException(
        "SPA-AUTH_CLIENT-GHC-IV01",
        "Http client cannot be returned.",
        "The http client cannot be returned when the storage type is set to webWorker."
      );
    }
    throw new import_javascript8.AsgardeoAuthException(
      "SPA-AUTH_CLIENT-GHC-NF02",
      "The SDK is not initialized.",
      "The SDK has not been initialized yet. Initialize the SDK using the initialize method before calling this method."
    );
  }
  /**
   * This method decodes the payload of the id token and returns it.
   *
   * @return {Promise<DecodedIdTokenPayloadInterface>} - A Promise that resolves with
   * the decoded payload of the id token.
   *
   * @example
   * ```
   * auth.getDecodedIdToken().then((response)=>{
   *     // console.log(response);
   * }).catch((error)=>{
   *     // console.error(error);
   * });
   * ```
   * @link https://github.com/asgardeo/asgardeo-auth-spa-sdk/tree/master#getdecodedidtoken
   *
   * @memberof AsgardeoSPAClient
   *
   * @preserve
   */
  async getDecodedIdToken(sessionId) {
    await this._validateMethod();
    return this._client?.getDecodedIdToken(sessionId);
  }
  /**
   * This method returns the IsomorphicCrypto instance.
   *
   * @return {Promise<DecodedIdTokenPayloadInterface>} - A Promise that resolves with
   * the IsomorphicCrypto instance.
   *
   * @example
   * ```
   * auth.getCrypto().then((response)=>{
   *     // console.log(response);
   * }).catch((error)=>{
   *     // console.error(error);
   * });
   * ```
   * @link https://github.com/asgardeo/asgardeo-auth-spa-sdk/tree/master#getCrypto
   *
   * @memberof AsgardeoSPAClient
   *
   * @preserve
   */
  async getCrypto() {
    await this._validateMethod();
    return this._client?.getCrypto();
  }
  /**
   * This method return the ID token.
   *
   * @return {Promise<string>} - A Promise that resolves with the ID token.
   *
   * @example
   * ```
   * const idToken = await auth.getIdToken();
   * ```
   *
   * @link https://github.com/asgardeo/asgardeo-auth-js-sdk/tree/master#getIdToken
   *
   * @memberof AsgardeoAuthClient
   *
   * @preserve
   */
  async getIdToken() {
    await this._validateMethod();
    return this._client?.getIdToken();
  }
  /**
   * This method return a Promise that resolves with the access token.
   *
   * **This method will not return the access token if the storage type is set to `webWorker`.**
   *
   * @return {Promise<string>} - A Promise that resolves with the access token.
   *
   * @example
   * ```
   *   auth.getAccessToken().then((token) => {
   *       // console.log(token);
   *   }).catch((error) => {
   *       // console.error(error);
   *   });
   * ```
   *
   * @link https://github.com/asgardeo/asgardeo-auth-spa-sdk/tree/master#getaccesstoken
   *
   * @memberof AsgardeoSPAClient
   *
   * @preserve
   */
  async getAccessToken() {
    await this._validateMethod();
    if (this._storage && [("webWorker" /* WebWorker */, "browserMemory" /* BrowserMemory */)].includes(this._storage)) {
      return Promise.reject(
        new import_javascript8.AsgardeoAuthException(
          "SPA-AUTH_CLIENT-GAT-IV01",
          "The access token cannot be returned.",
          "The access token cannot be returned when the storage type is set to webWorker or browserMemory."
        )
      );
    }
    const mainThreadClient = this._client;
    return mainThreadClient.getAccessToken();
  }
  /**
   * This method return a Promise that resolves with the idp access token.
   *
   * **This method will not return the access token if the storage type is set to `webWorker`.**
   *
   * @return {Promise<string>} - A Promise that resolves with the idp access token.
   *
   * @example
   * ```
   *   auth.getIDPAccessToken().then((token) => {
   *       // console.log(token);
   *   }).catch((error) => {
   *       // console.error(error);
   *   });
   * ```
   *
   * @link https://github.com/asgardeo/asgardeo-auth-spa-sdk/tree/master#getaccesstoken
   *
   * @memberof AsgardeoSPAClient
   *
   * @preserve
   */
  async getIDPAccessToken() {
    await this._validateMethod();
    if (this._storage && [("webWorker" /* WebWorker */, "browserMemory" /* BrowserMemory */)].includes(this._storage)) {
      return Promise.reject(
        new import_javascript8.AsgardeoAuthException(
          "SPA-AUTH_CLIENT-GIAT-IV01",
          "The access token cannot be returned.",
          "The access token cannot be returned when the storage type is set to webWorker or browserMemory."
        )
      );
    }
    const mainThreadClient = this._client;
    return mainThreadClient.getAccessToken();
  }
  /**
   * This method return a Promise that resolves with the data layer object.
   *
   * **This method will not return the data layer object, if the storage type is set to `webWorker`.**
   *
   * @return {Promise<string>} - A Promise that resolves with the data layer object.
   *
   * @example
   * ```
   *   auth.getStorageManager().then((dataLayer) => {
   *       // console.log(dataLayer);
   *   }).catch((error) => {
   *       // console.error(error);
   *   });
   * ```
   *
   * @link https://github.com/asgardeo/asgardeo-auth-spa-sdk/tree/master#getdatalayer
   *
   * @memberof AsgardeoSPAClient
   *
   * @preserve
   */
  async getStorageManager() {
    await this._validateMethod();
    if (this._storage && [("webWorker" /* WebWorker */, "browserMemory" /* BrowserMemory */)].includes(this._storage)) {
      return Promise.reject(
        new import_javascript8.AsgardeoAuthException(
          "SPA-AUTH_CLIENT-GDL-IV01",
          "The data layer cannot be returned.",
          "The data layer cannot be returned when the storage type is set to webWorker or browserMemory."
        )
      );
    }
    const mainThreadClient = this._client;
    return mainThreadClient.getStorageManager();
  }
  /**
   * This method return a Promise that resolves with the config data stored in the storage.
   *
   * @return - A Promise that resolves with the config data.
   *
   * @example
   * ```
   * auth.getConfigData().then((configData) => {
   *     // console.log(configData);
   * }).catch((error) => {
   *    // console.error(error);
   * });
   * ```
   *
   * @link https://github.com/asgardeo/asgardeo-auth-spa-sdk/tree/main#getConfigData
   *
   * @memberof AsgardeoSPAClient
   *
   * @preserve
   */
  async getConfigData() {
    return this._client?.getConfigData();
  }
  /**
   * This method refreshes the access token.
   *
   * @return {TokenResponseInterface} - A Promise that resolves with an object containing
   * information about the refreshed access token.
   *
   * @example
   * ```
   * auth.refreshToken().then((response)=>{
   *      // console.log(response);
   * }).catch((error)=>{
   *      // console.error(error);
   * });
   * ```
   *
   * @link https://github.com/asgardeo/asgardeo-auth-spa-sdk/tree/master#refreshtoken
   *
   * @memberof AsgardeoSPAClient
   *
   * @preserve
   */
  async refreshAccessToken() {
    await this._validateMethod(false);
    return this._client?.refreshAccessToken();
  }
  /**
   * This method specifies if the user is authenticated or not.
   *
   * @return {Promise<boolean>} - A Promise that resolves with `true` if the user is authenticated.
   *
   * @memberof AsgardeoSPAClient
   *
   * @preserve
   */
  async isSignedIn() {
    await this.isInitialized();
    return this._client?.isSignedIn();
  }
  /**
   * This method specifies if there is an active session in the browser or not.
   *
   * @return {Promise<boolean>} - A Promise that resolves with `true` if there is a session.
   *
   * @memberof AsgardeoSPAClient
   *
   * @preserve
   */
  async isSessionActive() {
    await this.isInitialized();
    if (this._storage && [("webWorker" /* WebWorker */, "browserMemory" /* BrowserMemory */)].includes(this._storage)) {
      return Promise.reject(
        new import_javascript8.AsgardeoAuthException(
          "SPA-AUTH_CLIENT-ISA-IV01",
          "The active session cannot be returned.",
          "The active session cannot be returned when the storage type is set to webWorker or browserMemory."
        )
      );
    }
    const mainThreadClient = this._client;
    return mainThreadClient?.isSessionActive();
  }
  async on(hook, callback, id) {
    await this.isInitialized();
    if (callback && typeof callback === "function") {
      switch (hook) {
        case "sign-in" /* SignIn */:
          this._onSignInCallback = callback;
          break;
        case "sign-out" /* SignOut */:
          this._onSignOutCallback = callback;
          if (await SPAUtils.isSignOutSuccessful()) {
            this._onSignOutCallback();
          }
          break;
        case "revoke-access-token" /* RevokeAccessToken */:
          this._onEndUserSession = callback;
          break;
        case "initialize" /* Initialize */:
          this._onInitialize = callback;
          break;
        case "http-request-error" /* HttpRequestError */:
          this._client?.setHttpRequestErrorCallback(callback);
          break;
        case "http-request-finish" /* HttpRequestFinish */:
          this._client?.setHttpRequestFinishCallback(callback);
          break;
        case "http-request-start" /* HttpRequestStart */:
          this._client?.setHttpRequestStartCallback(callback);
          break;
        case "http-request-success" /* HttpRequestSuccess */:
          this._client?.setHttpRequestSuccessCallback(callback);
          break;
        case "custom-grant" /* CustomGrant */:
          id && this._onCustomGrant.set(id, callback);
          break;
        case "sign-out-failed" /* SignOutFailed */: {
          this._onSignOutFailedCallback = callback;
          const signOutFail = SPAUtils.didSignOutFail();
          if (signOutFail) {
            this._onSignOutFailedCallback(signOutFail);
          }
          break;
        }
        default:
          throw new import_javascript8.AsgardeoAuthException("SPA-AUTH_CLIENT-ON-IV01", "Invalid hook.", "The provided hook is invalid.");
      }
    } else {
      throw new import_javascript8.AsgardeoAuthException(
        "SPA-AUTH_CLIENT-ON-IV02",
        "Invalid callback function.",
        "The provided callback function is invalid."
      );
    }
  }
  /**
   * This method enables callback functions attached to the http client.
   *
   * @return {Promise<boolean>} - A promise that resolves with True.
   *
   * @example
   * ```
   * auth.enableHttpHandler();
   * ```
   *
   * @link https://github.com/asgardeo/asgardeo-auth-spa-sdk/tree/master#enableHttpHandler
   *
   * @memberof AsgardeoSPAClient
   *
   * @preserve
   */
  async enableHttpHandler() {
    await this.isInitialized();
    return this._client?.enableHttpHandler();
  }
  /**
   * This method disables callback functions attached to the http client.
   *
   * @return {Promise<boolean>} - A promise that resolves with True.
   *
   * @example
   * ```
   * auth.disableHttpHandler();
   * ```
   *
   * @link https://github.com/asgardeo/asgardeo-auth-spa-sdk/tree/master#disableHttpHandler
   *
   * @memberof AsgardeoSPAClient
   *
   * @preserve
   */
  async disableHttpHandler() {
    await this.isInitialized();
    return this._client?.disableHttpHandler();
  }
  /**
   * This method updates the configuration that was passed into the constructor when instantiating this class.
   *
   * @param {Partial<AuthClientConfig<T>>} config - A config object to update the SDK configurations with.
   *
   * @example
   * ```
   * const config = {
   *     afterSignInUrl: "http://localhost:3000/sign-in",
   *     clientId: "client ID",
   *     baseUrl: "https://api.asgardeo.io"
   * }
   * const auth.reInitialize(config);
   * ```
   * @link https://github.com/asgardeo/asgardeo-auth-spa-sdk/tree/master/lib#reInitialize
   *
   * @memberof AsgardeoAuthClient
   *
   * @preserve
   */
  async reInitialize(config) {
    await this.isInitialized();
    if (this._storage === "webWorker" /* WebWorker */) {
      const client = this._client;
      await client.reInitialize(config);
    } else {
      const client = this._client;
      await client.reInitialize(config);
    }
    return;
  }
};
__publicField(_AsgardeoSPAClient, "_instances", /* @__PURE__ */ new Map());
var AsgardeoSPAClient = _AsgardeoSPAClient;

// src/__legacy__/models/http-client.ts
var import_axios2 = require("axios");

// src/__legacy__/models/web-worker.ts
var WebWorkerClass = class {
  constructor() {
    __publicField(this, "onmessage", () => null);
    __publicField(this, "postMessage", () => null);
  }
};

// src/__legacy__/worker/worker-receiver.ts
var import_javascript10 = require("@asgardeo/javascript");

// src/__legacy__/worker/worker-core.ts
var import_javascript9 = require("@asgardeo/javascript");
var WebWorkerCore = async (config, getAuthHelper) => {
  const _store = new MemoryStore();
  const _cryptoUtils = new SPACryptoUtils();
  const _authenticationClient = new import_javascript9.AsgardeoAuthClient();
  await _authenticationClient.initialize(config, _store, _cryptoUtils);
  const _spaHelper = new SPAHelper(_authenticationClient);
  const _authenticationHelper = getAuthHelper(
    _authenticationClient,
    _spaHelper
  );
  const _dataLayer = _authenticationClient.getStorageManager();
  const _httpClient = HttpClient.getInstance();
  const attachToken = async (request) => {
    await _authenticationHelper.attachTokenToRequestConfig(request);
  };
  _httpClient?.init && await _httpClient.init(true, attachToken);
  const setHttpRequestStartCallback = (callback) => {
    _httpClient?.setHttpRequestStartCallback && _httpClient.setHttpRequestStartCallback(callback);
  };
  const setHttpRequestSuccessCallback = (callback) => {
    _httpClient?.setHttpRequestSuccessCallback && _httpClient.setHttpRequestSuccessCallback(callback);
  };
  const setHttpRequestFinishCallback = (callback) => {
    _httpClient?.setHttpRequestFinishCallback && _httpClient.setHttpRequestFinishCallback(callback);
  };
  const httpRequest = async (requestConfig) => {
    return await _authenticationHelper.httpRequest(_httpClient, requestConfig);
  };
  const httpRequestAll = async (requestConfigs) => {
    return await _authenticationHelper.httpRequestAll(requestConfigs, _httpClient);
  };
  const enableHttpHandler = () => {
    _authenticationHelper.enableHttpHandler(_httpClient);
  };
  const disableHttpHandler = () => {
    _authenticationHelper.disableHttpHandler(_httpClient);
  };
  const getSignInUrl = async (params) => {
    return _authenticationClient.getSignInUrl(params).then(async (url) => {
      const urlObject = new URL(url);
      const state = urlObject.searchParams.get(import_javascript9.OIDCRequestConstants.Params.STATE) ?? "";
      const pkce = await _authenticationClient.getPKCECode(state);
      return { authorizationURL: url, pkce };
    }).catch((error) => Promise.reject(error));
  };
  const startAutoRefreshToken = async () => {
    _spaHelper.clearRefreshTokenTimeout();
    _spaHelper.refreshAccessTokenAutomatically(_authenticationHelper);
    return;
  };
  const requestAccessToken = async (authorizationCode, sessionState, pkce, state) => {
    return await _authenticationHelper.requestAccessToken(authorizationCode, sessionState, void 0, pkce, state);
  };
  const signOut = async () => {
    _spaHelper.clearRefreshTokenTimeout();
    return await _authenticationClient.getSignOutUrl();
  };
  const getSignOutUrl = async () => {
    return await _authenticationClient.getSignOutUrl();
  };
  const exchangeToken = async (config2) => {
    return await _authenticationHelper.exchangeToken(config2);
  };
  const refreshAccessToken = async () => {
    try {
      return await _authenticationHelper.refreshAccessToken();
    } catch (error) {
      return Promise.reject(error);
    }
  };
  const revokeAccessToken = async () => {
    const timer = await _spaHelper.getRefreshTimeoutTimer();
    return _authenticationClient.revokeAccessToken().then(() => {
      _spaHelper.clearRefreshTokenTimeout(timer);
      return Promise.resolve(true);
    }).catch((error) => Promise.reject(error));
  };
  const getUser = async () => {
    return _authenticationHelper.getUser();
  };
  const getDecodedIdToken = async (sessionId) => {
    return _authenticationHelper.getDecodedIdToken(sessionId);
  };
  const getCrypto = async () => {
    return _authenticationHelper.getCrypto();
  };
  const getDecodedIDPIDToken = async () => {
    return _authenticationHelper.getDecodedIDPIDToken();
  };
  const getIdToken = async () => {
    return _authenticationHelper.getIdToken();
  };
  const getOpenIDProviderEndpoints = async () => {
    return _authenticationHelper.getOpenIDProviderEndpoints();
  };
  const getAccessToken = () => {
    return _authenticationHelper.getAccessToken();
  };
  const isSignedIn = () => {
    return _authenticationHelper.isSignedIn();
  };
  const setSessionState = async (sessionState) => {
    await _dataLayer.setSessionDataParameter(
      import_javascript9.OIDCRequestConstants.Params.SESSION_STATE,
      sessionState
    );
    return;
  };
  const reInitialize = async (config2) => {
    await _authenticationClient.reInitialize(config2);
    return;
  };
  const getConfigData = async () => {
    return _dataLayer.getConfigData();
  };
  return {
    disableHttpHandler,
    enableHttpHandler,
    getAccessToken,
    getSignInUrl,
    getUser,
    getConfigData,
    getCrypto,
    getDecodedIDPIDToken,
    getDecodedIdToken,
    getIdToken,
    getOpenIDProviderEndpoints,
    getSignOutUrl,
    httpRequest,
    httpRequestAll,
    isSignedIn,
    refreshAccessToken,
    requestAccessToken,
    exchangeToken,
    revokeAccessToken,
    setHttpRequestFinishCallback,
    setHttpRequestStartCallback,
    setHttpRequestSuccessCallback,
    setSessionState,
    signOut,
    startAutoRefreshToken,
    reInitialize
  };
};

// src/__legacy__/worker/worker-receiver.ts
var workerReceiver = (getAuthHelper) => {
  const ctx = self;
  let webWorker;
  ctx.onmessage = async ({ data, ports }) => {
    const port = ports[0];
    if (data.type !== INIT && !webWorker) {
      port.postMessage(
        MessageUtils.generateFailureMessage(
          new import_javascript10.AsgardeoAuthException(
            "SPA-CLIENT_WORKER-ONMSG-NF01",
            "The web worker has not been initialized yet.",
            "The initialize method needs to be called before the specified operation can be carried out."
          )
        )
      );
      return;
    }
    switch (data.type) {
      case INIT:
        try {
          const config = { ...data.data };
          webWorker = await WebWorkerCore(config, getAuthHelper);
          webWorker.setHttpRequestFinishCallback(onRequestFinishCallback);
          webWorker.setHttpRequestStartCallback(onRequestStartCallback);
          webWorker.setHttpRequestSuccessCallback(onRequestSuccessCallback);
          port.postMessage(MessageUtils.generateSuccessMessage());
        } catch (error) {
          port.postMessage(MessageUtils.generateFailureMessage(error));
        }
        break;
      case GET_AUTH_URL:
        webWorker.getSignInUrl(data?.data).then((response) => {
          port.postMessage(MessageUtils.generateSuccessMessage(response));
        }).catch((error) => {
          port.postMessage(MessageUtils.generateFailureMessage(error));
        });
        break;
      case REQUEST_ACCESS_TOKEN:
        webWorker.requestAccessToken(data?.data?.code, data?.data?.sessionState, data?.data?.pkce, data?.data?.state).then((response) => {
          port.postMessage(MessageUtils.generateSuccessMessage(response));
        }).catch((error) => {
          port.postMessage(MessageUtils.generateFailureMessage(error));
        });
        break;
      case HTTP_REQUEST: {
        const request = data.data;
        const requestData = request?.data;
        if (data.data?.data?.formData === true) {
          const formData = new FormData();
          for (const key in requestData) {
            if (key === "formData") {
              continue;
            }
            formData.append(key, requestData[key]);
          }
          request.data = formData;
        }
        webWorker.httpRequest(request).then((response) => {
          port.postMessage(MessageUtils.generateSuccessMessage(response));
        }).catch((error) => {
          port.postMessage(MessageUtils.generateFailureMessage(error));
        });
        break;
      }
      case HTTP_REQUEST_ALL:
        webWorker.httpRequestAll(data.data).then((response) => {
          port.postMessage(MessageUtils.generateSuccessMessage(response));
        }).catch((error) => {
          port.postMessage(MessageUtils.generateFailureMessage(error));
        });
        break;
      case SIGN_OUT:
        try {
          port.postMessage(MessageUtils.generateSuccessMessage(await webWorker.signOut()));
        } catch (error) {
          port.postMessage(MessageUtils.generateFailureMessage(error));
        }
        break;
      case REQUEST_CUSTOM_GRANT:
        webWorker.exchangeToken(data.data).then((response) => {
          port.postMessage(MessageUtils.generateSuccessMessage(response));
        }).catch((error) => {
          port.postMessage(MessageUtils.generateFailureMessage(error));
        });
        break;
      case REVOKE_ACCESS_TOKEN:
        webWorker.revokeAccessToken().then((response) => {
          port.postMessage(MessageUtils.generateSuccessMessage(response));
        }).catch((error) => {
          port.postMessage(MessageUtils.generateFailureMessage(error));
        });
        break;
      case GET_OIDC_SERVICE_ENDPOINTS:
        try {
          port.postMessage(MessageUtils.generateSuccessMessage(await webWorker.getOpenIDProviderEndpoints()));
        } catch (error) {
          port.postMessage(MessageUtils.generateFailureMessage(error));
        }
        break;
      case GET_BASIC_USER_INFO:
        try {
          port.postMessage(MessageUtils.generateSuccessMessage(await webWorker.getUser()));
        } catch (error) {
          port.postMessage(MessageUtils.generateFailureMessage(error));
        }
        break;
      case GET_DECODED_ID_TOKEN:
        try {
          port.postMessage(MessageUtils.generateSuccessMessage(await webWorker.getDecodedIdToken()));
        } catch (error) {
          port.postMessage(MessageUtils.generateFailureMessage(error));
        }
        break;
      case GET_CRYPTO_HELPER:
        try {
          port.postMessage(MessageUtils.generateSuccessMessage(await webWorker.getCrypto()));
        } catch (error) {
          port.postMessage(MessageUtils.generateFailureMessage(error));
        }
        break;
      case GET_ID_TOKEN:
        try {
          port.postMessage(MessageUtils.generateSuccessMessage(await webWorker.getIdToken()));
        } catch (error) {
          port.postMessage(MessageUtils.generateFailureMessage(error));
        }
        break;
      case ENABLE_HTTP_HANDLER:
        webWorker.enableHttpHandler();
        port.postMessage(MessageUtils.generateSuccessMessage());
        break;
      case DISABLE_HTTP_HANDLER:
        webWorker.disableHttpHandler();
        port.postMessage(MessageUtils.generateSuccessMessage());
        break;
      case IS_AUTHENTICATED:
        try {
          port.postMessage(MessageUtils.generateSuccessMessage(await webWorker.isSignedIn()));
        } catch (error) {
          port.postMessage(MessageUtils.generateFailureMessage(error));
        }
        break;
      case GET_SIGN_OUT_URL:
        try {
          port.postMessage(MessageUtils.generateSuccessMessage(await webWorker.getSignOutUrl()));
        } catch (error) {
          port.postMessage(MessageUtils.generateFailureMessage(error));
        }
        break;
      case REFRESH_ACCESS_TOKEN:
        try {
          port.postMessage(MessageUtils.generateSuccessMessage(await webWorker.refreshAccessToken()));
        } catch (error) {
          port.postMessage(MessageUtils.generateFailureMessage(error));
        }
        break;
      case START_AUTO_REFRESH_TOKEN:
        try {
          port.postMessage(MessageUtils.generateSuccessMessage(webWorker.startAutoRefreshToken()));
        } catch (error) {
          port.postMessage(MessageUtils.generateFailureMessage(error));
        }
        break;
      case SET_SESSION_STATE:
        try {
          port.postMessage(MessageUtils.generateSuccessMessage(await webWorker.setSessionState(data?.data)));
        } catch (error) {
          port.postMessage(MessageUtils.generateFailureMessage(error));
        }
        break;
      case UPDATE_CONFIG:
        try {
          port.postMessage(MessageUtils.generateSuccessMessage(await webWorker.reInitialize(data?.data)));
        } catch (error) {
          port.postMessage(MessageUtils.generateFailureMessage(error));
        }
        break;
      case GET_CONFIG_DATA:
        try {
          port.postMessage(MessageUtils.generateSuccessMessage(await webWorker.getConfigData()));
        } catch (error) {
          port.postMessage(MessageUtils.generateFailureMessage(error));
        }
        break;
      default:
        port?.postMessage(
          MessageUtils.generateFailureMessage(
            new import_javascript10.AsgardeoAuthException(
              "SPA-CLIENT_WORKER-ONMSG-IV02",
              "The message type is invalid.",
              `The message type provided, ${data.type}, is invalid.`
            )
          )
        );
    }
  };
  const onRequestStartCallback = () => {
    ctx.postMessage({ type: REQUEST_START });
  };
  const onRequestSuccessCallback = (response) => {
    ctx.postMessage({ data: JSON.stringify(response ?? ""), type: REQUEST_SUCCESS });
  };
  const onRequestFinishCallback = () => {
    ctx.postMessage({ type: REQUEST_FINISH });
  };
};

// src/utils/hasAuthParamsInUrl.ts
var hasAuthParamsInUrl = (params = window.location.search) => {
  const MATCHER = /[?&]code=[^&]+/;
  return MATCHER.test(params);
};
var hasAuthParamsInUrl_default = hasAuthParamsInUrl;

// src/AsgardeoBrowserClient.ts
var import_javascript11 = require("@asgardeo/javascript");
var AsgardeoBrowserClient = class extends import_javascript11.AsgardeoJavaScriptClient {
};
var AsgardeoBrowserClient_default = AsgardeoBrowserClient;

// src/index.ts
__reExport(index_exports, require("@asgardeo/javascript"), module.exports);

// src/theme/themeDetection.ts
var detectThemeMode = (mode, config = {}) => {
  const {
    darkClass = "dark",
    lightClass = "light",
    targetElement = typeof document !== "undefined" ? document.documentElement : null
  } = config;
  if (mode === "light") return "light";
  if (mode === "dark") return "dark";
  if (mode === "system") {
    if (typeof window !== "undefined" && window.matchMedia) {
      return window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
    }
    return "light";
  }
  if (mode === "class") {
    if (!targetElement) {
      console.warn("ThemeDetection: targetElement is required for class-based detection, falling back to light mode");
      return "light";
    }
    const classList = targetElement.classList;
    if (classList.contains(darkClass)) {
      return "dark";
    }
    if (classList.contains(lightClass)) {
      return "light";
    }
    return "light";
  }
  return "light";
};
var createClassObserver = (targetElement, callback, config = {}) => {
  const { darkClass = "dark", lightClass = "light" } = config;
  const observer = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      if (mutation.type === "attributes" && mutation.attributeName === "class") {
        const classList = targetElement.classList;
        if (classList.contains(darkClass)) {
          callback(true);
        } else if (classList.contains(lightClass)) {
          callback(false);
        }
      }
    });
  });
  observer.observe(targetElement, {
    attributes: true,
    attributeFilter: ["class"]
  });
  return observer;
};
var createMediaQueryListener = (callback) => {
  if (typeof window === "undefined" || !window.matchMedia) {
    return null;
  }
  const mediaQuery = window.matchMedia("(prefers-color-scheme: dark)");
  const handleChange = (e) => {
    callback(e.matches);
  };
  if (mediaQuery.addEventListener) {
    mediaQuery.addEventListener("change", handleChange);
  } else {
    mediaQuery.addListener(handleChange);
  }
  return mediaQuery;
};
/*! Bundled license information:

ieee754/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)

buffer/index.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
*/

      if (typeof window !== 'undefined' && !window.Buffer) {
        window.Buffer = require('buffer/').Buffer;
      }
    
//# sourceMappingURL=index.js.map
